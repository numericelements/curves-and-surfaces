{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/controllers/CurveSceneController.ts","webpack:///./src/controllers/NoSlidingStrategy.ts","webpack:///./src/controllers/SlidingStrategy.ts","webpack:///./src/main.ts","webpack:///./src/mathematics/BSpline_R1_to_R1.ts","webpack:///./src/mathematics/BSpline_R1_to_R2.ts","webpack:///./src/mathematics/BSpline_R1_to_R2_DifferentialProperties.ts","webpack:///./src/mathematics/BernsteinDecomposition_R1_to_R1.ts","webpack:///./src/mathematics/BinomialCoefficient.ts","webpack:///./src/mathematics/CholeskyDecomposition.ts","webpack:///./src/mathematics/DenseMatrix.ts","webpack:///./src/mathematics/DiagonalMatrix.ts","webpack:///./src/mathematics/MathVectorBasicOperations.ts","webpack:///./src/mathematics/OptimizationProblem_BSpline_R1_to_R2_inflection.ts","webpack:///./src/mathematics/Optimizer.ts","webpack:///./src/mathematics/Piegl_Tiller_NURBS_Book.ts","webpack:///./src/mathematics/SquareMatrix.ts","webpack:///./src/mathematics/SymmetricMatrix.ts","webpack:///./src/mathematics/TrustRegionSubproblem.ts","webpack:///./src/mathematics/Vector_2d.ts","webpack:///./src/models/CurveModel.ts","webpack:///./src/views/ClickButtonView.ts","webpack:///./src/views/ControlPointsShaders.ts","webpack:///./src/views/ControlPointsView.ts","webpack:///./src/views/ControlPolygonShaders.ts","webpack:///./src/views/ControlPolygonView.ts","webpack:///./src/views/CurvatureExtremaShaders.ts","webpack:///./src/views/CurvatureExtremaView.ts","webpack:///./src/views/CurveShaders.ts","webpack:///./src/views/CurveView.ts","webpack:///./src/views/InflectionsView.ts","webpack:///./src/views/InsertKnotButtonShaders.ts","webpack:///./src/webgl/cuon-utils.ts","webpack:///./src/webgl/webgl-utils.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,wDAAsB;AACjD,0BAA0B,mBAAO,CAAC,oEAA4B;AAC9D,6BAA6B,mBAAO,CAAC,0EAA+B;AACpE,8BAA8B,mBAAO,CAAC,4EAAgC;AACtE,2BAA2B,mBAAO,CAAC,sEAA6B;AAChE,qBAAqB,mBAAO,CAAC,0DAAuB;AACpD,kBAAkB,mBAAO,CAAC,oDAAoB;AAC9C,gCAAgC,mBAAO,CAAC,gFAAkC;AAC1E,wBAAwB,mBAAO,CAAC,gEAA0B;AAC1D,gCAAgC,mBAAO,CAAC,gFAAkC;AAC1E,6BAA6B,mBAAO,CAAC,0EAA+B;AACpE,wBAAwB,mBAAO,CAAC,gEAA0B;AAC1D,wBAAwB,mBAAO,CAAC,+DAAmB;AACnD,0BAA0B,mBAAO,CAAC,mEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC/Ga;AACb,8CAA8C,cAAc;AAC5D;AACA,wDAAwD,mBAAO,CAAC,4IAAgE;AAChI,kBAAkB,mBAAO,CAAC,gEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACzFa;AACb,8CAA8C,cAAc;AAC5D;AACA,wDAAwD,mBAAO,CAAC,4IAAgE;AAChI,kBAAkB,mBAAO,CAAC,gEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACzFa;AACb,8CAA8C,cAAc;AAC5D;AACA,UAAU,2BAA2B;AACrC,6BAA6B,mBAAO,CAAC,qFAAoC;AACzE,oBAAoB,mBAAO,CAAC,uDAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;ACzGa;AACb,8CAA8C,cAAc;AAC5D;AACA,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,6BAA6B;AACxD;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,6BAA6B;AACxD;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC3Na;AACb,8CAA8C,cAAc;AAC5D;AACA,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,kBAAkB,mBAAO,CAAC,mDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAmD;AAC1F,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,6BAA6B;AACxD;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Oa;AACb,8CAA8C,cAAc;AAC5D;AACA,yBAAyB,mBAAO,CAAC,iEAAoB;AACrD,wCAAwC,mBAAO,CAAC,+FAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD,2BAA2B,4CAA4C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACtGa;AACb,8CAA8C,cAAc;AAC5D;AACA,4BAA4B,mBAAO,CAAC,uEAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACnHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACrGa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC9Fa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFa;AACb,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,yDAAgB;AAC7C,oBAAoB,mBAAO,CAAC,uDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnPa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D;AACA,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,yBAAyB,mBAAO,CAAC,iEAAoB;AACrD,wCAAwC,mBAAO,CAAC,+FAAmC;AACnF,uBAAuB,mBAAO,CAAC,6DAAkB;AACjD,oBAAoB,mBAAO,CAAC,uDAAe;AAC3C,wBAAwB,mBAAO,CAAC,+DAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA,iFAAiF;AACjF;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,+BAA+B,OAAO;AACtC;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E;AACA;AACA;AACA,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC91Ba;AACb,8CAA8C,cAAc;AAC5D;AACA,8BAA8B,mBAAO,CAAC,2EAAyB;AAC/D,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,wBAAwB,mBAAO,CAAC,+DAAmB;AACnD,8BAA8B,mBAAO,CAAC,2EAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD,wCAAwC,qBAAqB;AAC7D,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,QAAQ;AACvC,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC9Pa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,uCAAuC,UAAU;AACjD;AACA;AACA,yCAAyC;AACzC,2BAA2B,QAAQ;AACnC;AACA,iCAAiC;AACjC,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpJa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,2BAA2B,mBAAmB;AAC9C;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC1Ia;AACb,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,yDAAgB;AAC7C,uBAAuB,mBAAO,CAAC,6DAAkB;AACjD,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC/Ma;AACb,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,yDAAgB;AAC7C,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,kCAAkC,mBAAO,CAAC,mFAA6B;AACvE,8BAA8B,mBAAO,CAAC,2EAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;;;;;;;;;;;;;AC/iBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC7Ca;AACb,8CAA8C,cAAc;AAC5D;AACA,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,kBAAkB,mBAAO,CAAC,gEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACvGa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACnJa;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,sCAAsC;AACtC,oCAAoC;AACpC,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,uCAAuC;AACvC,mCAAmC;AACnC,qDAAqD;AACrD,cAAc;AACd;AACA,qDAAqD;AACrD,qCAAqC;AACrC,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,yDAAyD;AACzD,mEAAmE;AACnE,oDAAoD;AACpD,mDAAmD;AACnD,oCAAoC;AACpC,oEAAoE;AACpE,oEAAoE;AACpE,6DAA6D;AAC7D,6DAA6D;AAC7D,uDAAuD;AACvD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACvDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC7Ka;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0BAA0B;AAC1B,qDAAqD;AACrD,cAAc;AACd;AACA,4CAA4C;AAC5C,mFAAmF;AACnF,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;AC5Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACvHa;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,sCAAsC;AACtC,oCAAoC;AACpC,0BAA0B;AAC1B,uCAAuC;AACvC,qDAAqD;AACrD,cAAc;AACd;AACA,qDAAqD;AACrD,kCAAkC;AAClC,oCAAoC;AACpC,0BAA0B;AAC1B,mEAAmE;AACnE,0CAA0C;AAC1C,yCAAyC;AACzC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACrCa;AACb,8CAA8C,cAAc;AAC5D;AACA,UAAU,kDAAkD;AAC5D,UAAU,2BAA2B;AACrC,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,gDAAgD,mBAAO,CAAC,4HAAwD;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACxKa;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0BAA0B;AAC1B,qDAAqD;AACrD,cAAc;AACd;AACA,uDAAuD;AACvD,iCAAiC;AACjC,0BAA0B;AAC1B,uCAAuC;AACvC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACxHa;AACb,8CAA8C,cAAc;AAC5D;AACA,UAAU,kDAAkD;AAC5D,UAAU,2BAA2B;AACrC,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,gDAAgD,mBAAO,CAAC,4HAAwD;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACxKa;AACb,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,sCAAsC;AACtC,oCAAoC;AACpC,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,uCAAuC;AACvC,mCAAmC;AACnC,qDAAqD;AACrD,cAAc;AACd;AACA,qDAAqD;AACrD,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,oEAAoE;AACpE,oEAAoE;AACpE,qEAAqE;AACrE,qEAAqE;AACrE,6DAA6D,EAAE;AAC/D,oHAAoH;AACpH,6DAA6D,EAAE;AAC/D,qHAAqH;AACrH,0DAA0D,EAAE;AAC5D,uHAAuH;AACvH,0DAA0D,EAAE;AAC5D,uHAAuH;AACvH,0DAA0D,EAAE;AAC5D,yHAAyH;AACzH,0DAA0D,EAAE;AAC5D,wBAAwB;AACxB,4DAA4D,EAAE;AAC9D,oDAAoD,EAAE;AACtD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;ACxDa;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,sCAAsC,aAAa,cAAc,gBAAgB,kBAAkB;AACnG;AACA,kDAAkD,aAAa,cAAc;AAC7E;AACA,6CAA6C,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,+BAA+B;AAC9C;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveSceneController = void 0;\nvar CurveModel_1 = require(\"../models/CurveModel\");\nvar ControlPointsView_1 = require(\"../views/ControlPointsView\");\nvar ControlPointsShaders_1 = require(\"../views/ControlPointsShaders\");\nvar ControlPolygonShaders_1 = require(\"../views/ControlPolygonShaders\");\nvar ControlPolygonView_1 = require(\"../views/ControlPolygonView\");\nvar CurveShaders_1 = require(\"../views/CurveShaders\");\nvar CurveView_1 = require(\"../views/CurveView\");\nvar InsertKnotButtonShaders_1 = require(\"../views/InsertKnotButtonShaders\");\nvar ClickButtonView_1 = require(\"../views/ClickButtonView\");\nvar CurvatureExtremaShaders_1 = require(\"../views/CurvatureExtremaShaders\");\nvar CurvatureExtremaView_1 = require(\"../views/CurvatureExtremaView\");\nvar InflectionsView_1 = require(\"../views/InflectionsView\");\nvar SlidingStrategy_1 = require(\"./SlidingStrategy\");\nvar NoSlidingStrategy_1 = require(\"./NoSlidingStrategy\");\nvar CurveSceneController = /** @class */ (function () {\n    function CurveSceneController(canvas, gl) {\n        this.canvas = canvas;\n        this.gl = gl;\n        this.selectedControlPoint = null;\n        this.dragging = false;\n        this.curveModel = new CurveModel_1.CurveModel();\n        this.controlPointsShaders = new ControlPointsShaders_1.ControlPointsShaders(this.gl);\n        this.controlPointsView = new ControlPointsView_1.ControlPointsView(this.curveModel.spline, this.controlPointsShaders, 1, 1, 1);\n        this.controlPolygonShaders = new ControlPolygonShaders_1.ControlPolygonShaders(this.gl);\n        this.controlPolygonView = new ControlPolygonView_1.ControlPolygonView(this.curveModel.spline, this.controlPolygonShaders, false);\n        this.curveShaders = new CurveShaders_1.CurveShaders(this.gl);\n        this.curveView = new CurveView_1.CurveView(this.curveModel.spline, this.curveShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.insertKnotButtonShaders = new InsertKnotButtonShaders_1.InsertKnotButtonShaders(this.gl);\n        this.insertKnotButtonView = new ClickButtonView_1.ClickButtonView(-0.8, 0.8, this.insertKnotButtonShaders);\n        this.curvatureExtremaShaders = new CurvatureExtremaShaders_1.CurvatureExtremaShaders(this.gl);\n        this.curvatureExtremaView = new CurvatureExtremaView_1.CurvatureExtremaView(this.curveModel.spline, this.curvatureExtremaShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.inflectionsView = new InflectionsView_1.InflectionsView(this.curveModel.spline, this.curvatureExtremaShaders, 216 / 255, 120 / 255, 120 / 255, 1);\n        this.curveModel.registerObserver(this.controlPointsView);\n        this.curveModel.registerObserver(this.controlPolygonView);\n        this.curveModel.registerObserver(this.curveView);\n        this.curveModel.registerObserver(this.curvatureExtremaView);\n        this.curveModel.registerObserver(this.inflectionsView);\n        this.curveControl = new SlidingStrategy_1.SlidingStrategy(this.curveModel);\n        this.sliding = true;\n    }\n    CurveSceneController.prototype.renderFrame = function () {\n        var px = 100, size = Math.min(window.innerWidth, window.innerHeight) - px;\n        this.canvas.width = size;\n        this.canvas.height = size;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clearColor(0.3, 0.3, 0.3, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.curveView.renderFrame();\n        this.curvatureExtremaView.renderFrame();\n        this.inflectionsView.renderFrame();\n        this.controlPolygonView.renderFrame();\n        this.controlPointsView.renderFrame();\n        this.insertKnotButtonView.renderFrame();\n    };\n    CurveSceneController.prototype.toggleControlOfCurvatureExtrema = function () {\n        this.curveControl.toggleControlOfCurvatureExtrema();\n    };\n    CurveSceneController.prototype.toggleControlOfInflections = function () {\n        this.curveControl.toggleControlOfInflections();\n    };\n    CurveSceneController.prototype.toggleSliding = function () {\n        if (this.sliding === true) {\n            this.sliding = false;\n            this.curveControl = new NoSlidingStrategy_1.NoSlidingStrategy(this.curveModel);\n        }\n        else {\n            this.sliding = true;\n            this.curveControl = new SlidingStrategy_1.SlidingStrategy(this.curveModel);\n        }\n    };\n    CurveSceneController.prototype.leftMouseDown_event = function (ndcX, ndcY, deltaSquared) {\n        if (deltaSquared === void 0) { deltaSquared = 0.01; }\n        if (this.insertKnotButtonView.selected(ndcX, ndcY) && this.selectedControlPoint !== null) {\n            var cp = this.selectedControlPoint;\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this.curveModel.spline.controlPoints.length - 1) {\n                cp -= 1;\n            }\n            var grevilleAbscissae = this.curveModel.spline.grevilleAbscissae();\n            if (cp != null) {\n                this.curveModel.spline.insertKnot(grevilleAbscissae[cp]);\n                this.curveControl.resetCurve(this.curveModel);\n                this.curveModel.notifyObservers();\n            }\n        }\n        this.selectedControlPoint = this.controlPointsView.controlPointSelection(ndcX, ndcY, deltaSquared);\n        this.controlPointsView.setSelected(this.selectedControlPoint);\n        if (this.selectedControlPoint !== null) {\n            this.dragging = true;\n        }\n    };\n    CurveSceneController.prototype.leftMouseDragged_event = function (ndcX, ndcY) {\n        var x = ndcX, y = ndcY, selectedControlPoint = this.controlPointsView.getSelectedControlPoint();\n        if (selectedControlPoint != null && this.dragging === true) {\n            this.curveModel.setControlPoint(selectedControlPoint, x, y);\n            this.curveControl.optimize(selectedControlPoint, x, y);\n            this.curveModel.notifyObservers();\n        }\n    };\n    CurveSceneController.prototype.leftMouseUp_event = function () {\n        this.dragging = false;\n    };\n    return CurveSceneController;\n}());\nexports.CurveSceneController = CurveSceneController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoSlidingStrategy = void 0;\nvar OptimizationProblem_BSpline_R1_to_R2_inflection_1 = require(\"../mathematics/OptimizationProblem_BSpline_R1_to_R2_inflection\");\nvar Optimizer_1 = require(\"../mathematics/Optimizer\");\nvar NoSlidingStrategy = /** @class */ (function () {\n    function NoSlidingStrategy(curveModel) {\n        this.activeOptimizer = true;\n        this.curveModel = curveModel;\n        this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone());\n        this.optimizer = this.newOptimizer(this.optimizationProblem);\n    }\n    NoSlidingStrategy.prototype.setWeightingFactor = function (optimizationProblem) {\n        optimizationProblem.weigthingFactors[0] = 10;\n        optimizationProblem.weigthingFactors[this.curveModel.spline.controlPoints.length] = 10;\n        optimizationProblem.weigthingFactors[this.curveModel.spline.controlPoints.length - 1] = 10;\n        optimizationProblem.weigthingFactors[this.curveModel.spline.controlPoints.length * 2 - 1] = 10;\n    };\n    NoSlidingStrategy.prototype.newOptimizer = function (optimizationProblem) {\n        this.setWeightingFactor(optimizationProblem);\n        return new Optimizer_1.Optimizer(optimizationProblem);\n    };\n    NoSlidingStrategy.prototype.resetCurve = function (curveModel) {\n        this.curveModel = curveModel;\n        this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone());\n        this.optimizer = this.newOptimizer(this.optimizationProblem);\n    };\n    NoSlidingStrategy.prototype.toggleControlOfCurvatureExtrema = function () {\n        if (this.activeOptimizer === false) {\n            this.activeOptimizer = true;\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else {\n            console.log(\"Error in logic of toggle control over curvature extrema\");\n        }\n    };\n    NoSlidingStrategy.prototype.toggleControlOfInflections = function () {\n        if (this.activeOptimizer === false) {\n            this.activeOptimizer = true;\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else {\n            console.log(\"Error in logic of toggle control over inflections\");\n        }\n    };\n    NoSlidingStrategy.prototype.toggleSliding = function () {\n        throw new Error(\"Method not implemented.\");\n    };\n    NoSlidingStrategy.prototype.optimize = function (selectedControlPoint, ndcX, ndcY) {\n        if (this.activeOptimizer === false)\n            return;\n        var p = this.curveModel.spline.controlPoints[selectedControlPoint];\n        this.curveModel.setControlPoint(selectedControlPoint, ndcX, ndcY);\n        this.optimizationProblem.setTargetSpline(this.curveModel.spline);\n        try {\n            this.optimizer.optimize_using_trust_region(10e-8, 100, 800);\n            this.curveModel.setSpline(this.optimizationProblem.spline.clone());\n        }\n        catch (e) {\n            this.curveModel.setControlPoint(selectedControlPoint, p.x, p.y);\n            console.log(e);\n        }\n    };\n    return NoSlidingStrategy;\n}());\nexports.NoSlidingStrategy = NoSlidingStrategy;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SlidingStrategy = void 0;\nvar OptimizationProblem_BSpline_R1_to_R2_inflection_1 = require(\"../mathematics/OptimizationProblem_BSpline_R1_to_R2_inflection\");\nvar Optimizer_1 = require(\"../mathematics/Optimizer\");\nvar SlidingStrategy = /** @class */ (function () {\n    function SlidingStrategy(curveModel) {\n        this.activeOptimizer = true;\n        this.curveModel = curveModel;\n        this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone());\n        this.optimizer = this.newOptimizer(this.optimizationProblem);\n    }\n    SlidingStrategy.prototype.setWeightingFactor = function (optimizationProblem) {\n        optimizationProblem.weigthingFactors[0] = 10;\n        optimizationProblem.weigthingFactors[this.curveModel.spline.controlPoints.length] = 10;\n        optimizationProblem.weigthingFactors[this.curveModel.spline.controlPoints.length - 1] = 10;\n        optimizationProblem.weigthingFactors[this.curveModel.spline.controlPoints.length * 2 - 1] = 10;\n    };\n    SlidingStrategy.prototype.newOptimizer = function (optimizationProblem) {\n        this.setWeightingFactor(optimizationProblem);\n        return new Optimizer_1.Optimizer(optimizationProblem);\n    };\n    SlidingStrategy.prototype.resetCurve = function (curveModel) {\n        this.curveModel = curveModel;\n        this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone());\n        this.optimizer = this.newOptimizer(this.optimizationProblem);\n    };\n    SlidingStrategy.prototype.toggleControlOfCurvatureExtrema = function () {\n        if (this.activeOptimizer === false) {\n            this.activeOptimizer = true;\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else {\n            console.log(\"Error in logic of toggle control over curvature extrema\");\n        }\n    };\n    SlidingStrategy.prototype.toggleControlOfInflections = function () {\n        if (this.activeOptimizer === false) {\n            this.activeOptimizer = true;\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else if (this.optimizationProblem.activeControl === OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.curvatureExtrema) {\n            this.optimizationProblem = new OptimizationProblem_BSpline_R1_to_R2_inflection_1.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(this.curveModel.spline.clone(), this.curveModel.spline.clone(), OptimizationProblem_BSpline_R1_to_R2_inflection_1.ActiveControl.both);\n            this.optimizer = this.newOptimizer(this.optimizationProblem);\n        }\n        else {\n            console.log(\"Error in logic of toggle control over inflections\");\n        }\n    };\n    SlidingStrategy.prototype.toggleSliding = function () {\n        throw new Error(\"Method not implemented.\");\n    };\n    SlidingStrategy.prototype.optimize = function (selectedControlPoint, ndcX, ndcY) {\n        if (this.activeOptimizer === false)\n            return;\n        var p = this.curveModel.spline.controlPoints[selectedControlPoint];\n        this.curveModel.setControlPoint(selectedControlPoint, ndcX, ndcY);\n        this.optimizationProblem.setTargetSpline(this.curveModel.spline);\n        try {\n            this.optimizer.optimize_using_trust_region(10e-8, 100, 800);\n            this.curveModel.setSpline(this.optimizationProblem.spline.clone());\n        }\n        catch (e) {\n            this.curveModel.setControlPoint(selectedControlPoint, p.x, p.y);\n            console.log(e);\n        }\n    };\n    return SlidingStrategy;\n}());\nexports.SlidingStrategy = SlidingStrategy;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.main = void 0;\n//import { OvalCurveSceneController } from \"./controllers/OvalCurveSceneController\"\nvar CurveSceneController_1 = require(\"./controllers/CurveSceneController\");\nvar webgl_utils_1 = require(\"./webgl/webgl-utils\");\nfunction main() {\n    var canvas = document.getElementById(\"webgl\");\n    var toggleButtonCurvatureExtrema = document.getElementById(\"toggleButtonCurvatureExtrema\");\n    var toggleButtonInflection = document.getElementById(\"toggleButtonInflections\");\n    var toggleButtonSliding = document.getElementById(\"toggleButtonSliding\");\n    var gl = webgl_utils_1.WebGLUtils().setupWebGL(canvas);\n    if (!gl) {\n        console.log('Failed to get the rendering context for WebGL');\n        return;\n    }\n    var sceneController = new CurveSceneController_1.CurveSceneController(canvas, gl);\n    // let sceneController = new OvalCurveSceneController(canvas, gl)\n    function mouse_get_NormalizedDeviceCoordinates(event) {\n        var x, y, rect = canvas.getBoundingClientRect(), ev;\n        ev = event;\n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2);\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2);\n        return [x, y];\n    }\n    function touch_get_NormalizedDeviceCoordinates(event) {\n        var x, y, rect = canvas.getBoundingClientRect(), ev;\n        ev = event.touches[0];\n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2);\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2);\n        return [x, y];\n    }\n    //function click(ev, canvas) {\n    function mouse_click(ev) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDown_event(c[0], c[1], 0.0005);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    //function drag(ev, canvas) {\n    function mouse_drag(ev) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDragged_event(c[0], c[1]);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    function mouse_stop_drag(ev) {\n        sceneController.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    //function click(ev, canvas) {\n    function touch_click(ev) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDown_event(c[0], c[1]);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    //function drag(ev, canvas) {\n    function touch_drag(ev) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDragged_event(c[0], c[1]);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    function touch_stop_drag(ev) {\n        sceneController.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    function toggleControlOfCurvatureExtrema() {\n        sceneController.toggleControlOfCurvatureExtrema();\n    }\n    function toggleControlOfInflections() {\n        sceneController.toggleControlOfInflections();\n    }\n    function toggleSliding() {\n        sceneController.toggleSliding();\n    }\n    canvas.addEventListener('mousedown', mouse_click, false);\n    canvas.addEventListener('mousemove', mouse_drag, false);\n    canvas.addEventListener('mouseup', mouse_stop_drag, false);\n    canvas.addEventListener('touchstart', touch_click, false);\n    canvas.addEventListener('touchmove', touch_drag, false);\n    canvas.addEventListener('touchend', touch_stop_drag, false);\n    toggleButtonCurvatureExtrema.addEventListener('click', toggleControlOfCurvatureExtrema);\n    toggleButtonInflection.addEventListener('click', toggleControlOfInflections);\n    toggleButtonSliding.addEventListener('click', toggleSliding);\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\"touchstart\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchend\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchmove\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    sceneController.renderFrame();\n}\nexports.main = main;\nmain();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BSpline_R1_to_R1 = void 0;\nvar Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Piegl_Tiller_NURBS_Book_2 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Piegl_Tiller_NURBS_Book_3 = require(\"./Piegl_Tiller_NURBS_Book\");\n/**\n * A B-Spline function from a one dimensional real space to a one dimensional real space\n */\nvar BSpline_R1_to_R1 = /** @class */ (function () {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    function BSpline_R1_to_R1(controlPoints, knots) {\n        if (controlPoints === void 0) { controlPoints = [0]; }\n        if (knots === void 0) { knots = [0, 1]; }\n        this._controlPoints = [];\n        this._knots = [];\n        this._degree = 0;\n        this._controlPoints = controlPoints;\n        this._knots = knots;\n        this._degree = this._knots.length - this._controlPoints.length - 1;\n        if (this._degree < 0) {\n            throw new Error(\"Negative degree BSpline_R1_to_R1 are not supported\");\n        }\n    }\n    Object.defineProperty(BSpline_R1_to_R1.prototype, \"controlPoints\", {\n        get: function () {\n            return this._controlPoints;\n        },\n        set: function (controlPoints) {\n            this._controlPoints = controlPoints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BSpline_R1_to_R1.prototype, \"knots\", {\n        get: function () {\n            return this._knots;\n        },\n        set: function (knots) {\n            this._knots = knots;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BSpline_R1_to_R1.prototype, \"degree\", {\n        get: function () {\n            return this._degree;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BSpline_R1_to_R1.prototype.setControlPoint = function (index, value) {\n        this._controlPoints[index] = value;\n    };\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    BSpline_R1_to_R1.prototype.evaluate = function (u) {\n        var span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        var basis = Piegl_Tiller_NURBS_Book_2.basisFunctions(span, u, this._knots, this._degree);\n        var result = 0;\n        for (var i = 0; i < this.degree + 1; i += 1) {\n            result += basis[i] * this._controlPoints[span - this._degree + i];\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.derivative = function () {\n        var newControlPoints = [];\n        var newKnots = [];\n        for (var i = 0; i < this.controlPoints.length - 1; i += 1) {\n            newControlPoints[i] = (this.controlPoints[i + 1] - (this.controlPoints[i])) * (this.degree / (this.knots[i + this.degree + 1] - this.knots[i + 1]));\n        }\n        newKnots = this.knots.slice(1, this.knots.length - 1);\n        return new BSpline_R1_to_R1(newControlPoints, newKnots);\n    };\n    BSpline_R1_to_R1.prototype.bernsteinDecomposition = function () {\n        // Piegl_Tiller_NURBS_BOOK.ts\n        return Piegl_Tiller_NURBS_Book_3.decomposeFunction(this);\n    };\n    BSpline_R1_to_R1.prototype.distinctKnots = function () {\n        var result = [this.knots[0]];\n        var temp = result[0];\n        for (var i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.zeros = function (tolerance) {\n        if (tolerance === void 0) { tolerance = 10e-8; }\n        //see : chapter 11 : Computing Zeros of Splines by Tom Lyche and Knut Morken for u_star method\n        var spline = new BSpline_R1_to_R1(this.controlPoints.slice(), this.knots.slice());\n        var greville = spline.grevilleAbscissae();\n        var maxError = tolerance * 2;\n        var vertexIndex = [];\n        while (maxError > tolerance) {\n            var cpLeft = spline.controlPoints[0];\n            vertexIndex = [];\n            var maximum = 0;\n            for (var index = 1; index < spline.controlPoints.length; index += 1) {\n                var cpRight = spline.controlPoints[index];\n                if (cpLeft <= 0 && cpRight > 0) {\n                    vertexIndex.push(index);\n                }\n                if (cpLeft >= 0 && cpRight < 0) {\n                    vertexIndex.push(index);\n                }\n                cpLeft = cpRight;\n            }\n            for (var i = 0; i < vertexIndex.length; i += 1) {\n                var uLeft = greville[vertexIndex[i] - 1];\n                var uRight = greville[vertexIndex[i]];\n                if (uRight - uLeft > maximum) {\n                    maximum = uRight - uLeft;\n                }\n                if (uRight - uLeft > tolerance) {\n                    spline.insertKnot((uLeft + uRight) / 2);\n                    greville = spline.grevilleAbscissae();\n                }\n            }\n            maxError = maximum;\n        }\n        var result = [];\n        for (var i = 0; i < vertexIndex.length; i += 1) {\n            result.push(greville[vertexIndex[i]]);\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.grevilleAbscissae = function () {\n        var result = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var sum = 0;\n            for (var j = i + 1; j < i + this.degree + 1; j += 1) {\n                sum += this.knots[j];\n            }\n            result.push(sum / this.degree);\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.insertKnot = function (u, times) {\n        if (times === void 0) { times = 1; }\n        if (times <= 0) {\n            return;\n        }\n        var index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this.knots, this.degree);\n        var multiplicity = 0;\n        var newControlPoints = [];\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (var t = 0; t < times; t += 1) {\n            for (var i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (var i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                var alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = this.controlPoints[i - 1] * (1 - alpha) + this.controlPoints[i] * alpha;\n            }\n            for (var i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this.knots.splice(index + 1, 0, u);\n            this.controlPoints = newControlPoints.slice();\n        }\n    };\n    BSpline_R1_to_R1.prototype.knotMultiplicity = function (indexFromFindSpan) {\n        var result = 0;\n        var i = 0;\n        while (this.knots[indexFromFindSpan + i] === this.knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    };\n    /**\n     * Return a deep copy of this b-spline\n     */\n    BSpline_R1_to_R1.prototype.clone = function () {\n        return new BSpline_R1_to_R1(this.controlPoints.slice(), this.knots.slice());\n    };\n    BSpline_R1_to_R1.prototype.clamp = function (u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        var index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this.knots, this.degree);\n        var newControlPoints = [];\n        var multiplicity = 0;\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        var times = this.degree - multiplicity + 1;\n        for (var t = 0; t < times; t += 1) {\n            for (var i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (var i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                var alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = this.controlPoints[i - 1] * (1 - alpha) + this.controlPoints[i] * alpha;\n            }\n            for (var i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this.knots.splice(index + 1, 0, u);\n            this.controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    };\n    return BSpline_R1_to_R1;\n}());\nexports.BSpline_R1_to_R1 = BSpline_R1_to_R1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.create_BSpline_R1_to_R2 = exports.BSpline_R1_to_R2 = void 0;\nvar Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Piegl_Tiller_NURBS_Book_2 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Vector_2d_1 = require(\"./Vector_2d\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nvar BSpline_R1_to_R2 = /** @class */ (function () {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    function BSpline_R1_to_R2(controlPoints, knots) {\n        if (controlPoints === void 0) { controlPoints = [new Vector_2d_1.Vector_2d(0, 0)]; }\n        if (knots === void 0) { knots = [0, 1]; }\n        this._controlPoints = [];\n        this._knots = [];\n        this._degree = 0;\n        this._controlPoints = controlPoints;\n        this._knots = knots;\n        this._degree = this._knots.length - this._controlPoints.length - 1;\n        if (this._degree < 0) {\n            throw new Error(\"Negative degree BSpline_R1_to_R2 are not supported\");\n        }\n    }\n    Object.defineProperty(BSpline_R1_to_R2.prototype, \"controlPoints\", {\n        get: function () {\n            return this._controlPoints;\n        },\n        set: function (controlPoints) {\n            this._controlPoints = controlPoints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BSpline_R1_to_R2.prototype.visibleControlPoints = function () {\n        return this.controlPoints;\n    };\n    Object.defineProperty(BSpline_R1_to_R2.prototype, \"knots\", {\n        get: function () {\n            return this._knots;\n        },\n        set: function (knots) {\n            this._knots = knots;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BSpline_R1_to_R2.prototype, \"degree\", {\n        get: function () {\n            return this._degree;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BSpline_R1_to_R2.prototype.setControlPoint = function (index, value) {\n        this._controlPoints[index] = value;\n    };\n    BSpline_R1_to_R2.prototype.setControlPoints = function (controlPoints) {\n        this.controlPoints = controlPoints;\n    };\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    BSpline_R1_to_R2.prototype.evaluate = function (u) {\n        var span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        var basis = Piegl_Tiller_NURBS_Book_2.basisFunctions(span, u, this._knots, this._degree);\n        var result = new Vector_2d_1.Vector_2d(0, 0);\n        for (var i = 0; i < this.degree + 1; i += 1) {\n            result.x += basis[i] * this._controlPoints[span - this._degree + i].x;\n            result.y += basis[i] * this._controlPoints[span - this._degree + i].y;\n        }\n        return result;\n    };\n    /**\n     * Return a deep copy of this b-spline\n     */\n    BSpline_R1_to_R2.prototype.clone = function () {\n        var cloneControlPoints = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            cloneControlPoints.push(new Vector_2d_1.Vector_2d(this.controlPoints[i].x, this.controlPoints[i].y));\n        }\n        return new BSpline_R1_to_R2(cloneControlPoints, this.knots.slice());\n    };\n    BSpline_R1_to_R2.prototype.optimizerStep = function (step) {\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            this.controlPoints[i].x += step[i];\n            this.controlPoints[i].y += step[i + this.controlPoints.length];\n        }\n    };\n    BSpline_R1_to_R2.prototype.getControlPointsX = function () {\n        var result = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            result.push(this.controlPoints[i].x);\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.getControlPointsY = function () {\n        var result = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            result.push(this.controlPoints[i].y);\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.distinctKnots = function () {\n        var result = [this.knots[0]];\n        var temp = result[0];\n        for (var i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.moveControlPoint = function (i, deltaX, deltaY) {\n        if (i < 0 || i >= this.controlPoints.length - this.degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        this.controlPoints[i].x += deltaX;\n        this.controlPoints[i].y += deltaY;\n    };\n    BSpline_R1_to_R2.prototype.insertKnot = function (u, times) {\n        if (times === void 0) { times = 1; }\n        // Piegl and Tiller, The NURBS book, p: 151\n        if (times <= 0) {\n            return;\n        }\n        var index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this.knots, this.degree), multiplicity = 0, i = 0, t = 0, newControlPoints, alpha = 0;\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (t = 0; t < times; t += 1) {\n            newControlPoints = [];\n            for (i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = (this.controlPoints[i - 1].multiply(1 - alpha)).add(this.controlPoints[i].multiply(alpha));\n            }\n            for (i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    };\n    BSpline_R1_to_R2.prototype.knotMultiplicity = function (indexFromFindSpan) {\n        var result = 0, i = 0;\n        while (this.knots[indexFromFindSpan + i] === this.knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.grevilleAbscissae = function () {\n        var result = [], i, j, sum;\n        for (i = 0; i < this.controlPoints.length; i += 1) {\n            sum = 0;\n            for (j = i + 1; j < i + this.degree + 1; j += 1) {\n                sum += this.knots[j];\n            }\n            result.push(sum / this.degree);\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.clamp = function (u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        var index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this.knots, this.degree);\n        var newControlPoints = [];\n        var multiplicity = 0;\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        var times = this.degree - multiplicity + 1;\n        for (var t = 0; t < times; t += 1) {\n            for (var i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (var i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                var alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = (this.controlPoints[i - 1].multiply(1 - alpha)).add(this.controlPoints[i].multiply(alpha));\n            }\n            for (var i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this.knots.splice(index + 1, 0, u);\n            this.controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    };\n    /**\n     *\n     * @param from Parametric position where the section start\n     * @param to Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    BSpline_R1_to_R2.prototype.section = function (from, to) {\n        var spline = this.clone();\n        spline.clamp(from);\n        spline.clamp(to);\n        //const newFromSpan = findSpan(from, spline._knots, spline._degree)\n        //const newToSpan = findSpan(to, spline._knots, spline._degree)\n        var newFromSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(from, spline._knots, spline._degree);\n        var newToSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(to, spline._knots, spline._degree);\n        var newKnots = [];\n        var newControlPoints = [];\n        for (var i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (var i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector_2d_1.Vector_2d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSpline_R1_to_R2(newControlPoints, newKnots);\n    };\n    return BSpline_R1_to_R2;\n}());\nexports.BSpline_R1_to_R2 = BSpline_R1_to_R2;\nfunction create_BSpline_R1_to_R2(controlPoints, knots) {\n    var newControlPoints = [];\n    for (var i = 0, n = controlPoints.length; i < n; i += 1) {\n        newControlPoints.push(new Vector_2d_1.Vector_2d(controlPoints[i][0], controlPoints[i][1]));\n    }\n    return new BSpline_R1_to_R2(newControlPoints, knots);\n}\nexports.create_BSpline_R1_to_R2 = create_BSpline_R1_to_R2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BSpline_R1_to_R2_DifferentialProperties = void 0;\nvar BSpline_R1_to_R1_1 = require(\"./BSpline_R1_to_R1\");\nvar BernsteinDecomposition_R1_to_R1_1 = require(\"./BernsteinDecomposition_R1_to_R1\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nvar BSpline_R1_to_R2_DifferentialProperties = /** @class */ (function () {\n    function BSpline_R1_to_R2_DifferentialProperties(spline) {\n        this.spline = spline;\n    }\n    BSpline_R1_to_R2_DifferentialProperties.prototype.expensiveComputation = function (spline) {\n        var sx = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(spline.getControlPointsX(), spline.knots);\n        var sy = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(spline.getControlPointsY(), spline.knots);\n        var sxu = sx.derivative();\n        var syu = sy.derivative();\n        var sxuu = sxu.derivative();\n        var syuu = syu.derivative();\n        var sxuuu = sxuu.derivative();\n        var syuuu = syuu.derivative();\n        var bdsxu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxu.bernsteinDecomposition());\n        var bdsyu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syu.bernsteinDecomposition());\n        var bdsxuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxuu.bernsteinDecomposition());\n        var bdsyuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syuu.bernsteinDecomposition());\n        var bdsxuuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxuuu.bernsteinDecomposition());\n        var bdsyuuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syuuu.bernsteinDecomposition());\n        var h1 = (bdsxu.multiply(bdsxu)).add((bdsyu.multiply(bdsyu)));\n        var h2 = (bdsxu.multiply(bdsyuuu)).subtract((bdsyu.multiply(bdsxuuu)));\n        var h3 = (bdsxu.multiply(bdsxuu)).add((bdsyu.multiply(bdsyuu)));\n        var h4 = (bdsxu.multiply(bdsyuu)).subtract((bdsyu.multiply(bdsxuu)));\n        return {\n            h1: h1,\n            h2: h2,\n            h3: h3,\n            h4: h4\n        };\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.curvatureNumerator = function () {\n        var e = this.expensiveComputation(this.spline);\n        var distinctKnots = this.spline.distinctKnots();\n        var controlPoints = e.h4.flattenControlPointsArray();\n        var curvatureNumeratorDegree = 2 * this.spline.degree - 3;\n        var knots = [];\n        for (var i = 0; i < distinctKnots.length; i += 1) {\n            for (var j = 0; j < curvatureNumeratorDegree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSpline_R1_to_R1_1.BSpline_R1_to_R1(controlPoints, knots);\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.h1 = function () {\n        var e = this.expensiveComputation(this.spline);\n        var distinctKnots = this.spline.distinctKnots();\n        var controlPoints = e.h1.flattenControlPointsArray();\n        var h1Degree = 2 * this.spline.degree - 2;\n        var knots = [];\n        for (var i = 0; i < distinctKnots.length; i += 1) {\n            for (var j = 0; j < h1Degree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSpline_R1_to_R1_1.BSpline_R1_to_R1(controlPoints, knots);\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.inflections = function (curvatureNumerator) {\n        if (!curvatureNumerator) {\n            curvatureNumerator = this.curvatureNumerator();\n        }\n        var zeros = curvatureNumerator.zeros();\n        var result = [];\n        for (var i = 0; i < zeros.length; i += 1) {\n            result.push(this.spline.evaluate(zeros[i]));\n        }\n        return result;\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.curvatureDerivativeNumerator = function () {\n        var e = this.expensiveComputation(this.spline);\n        var bd_curvatureDerivativeNumerator = (e.h1.multiply(e.h2)).subtract(e.h3.multiply(e.h4).multiplyByScalar(3));\n        var distinctKnots = this.spline.distinctKnots();\n        var controlPoints = bd_curvatureDerivativeNumerator.flattenControlPointsArray();\n        var curvatureDerivativeNumeratorDegree = 4 * this.spline.degree - 6;\n        var knots = [];\n        for (var i = 0; i < distinctKnots.length; i += 1) {\n            for (var j = 0; j < curvatureDerivativeNumeratorDegree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSpline_R1_to_R1_1.BSpline_R1_to_R1(controlPoints, knots);\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.curvatureExtrema = function (curvatureDerivativeNumerator) {\n        if (!curvatureDerivativeNumerator) {\n            curvatureDerivativeNumerator = this.curvatureDerivativeNumerator();\n        }\n        var zeros = curvatureDerivativeNumerator.zeros();\n        var result = [];\n        for (var i = 0; i < zeros.length; i += 1) {\n            result.push(this.spline.evaluate(zeros[i]));\n        }\n        return result;\n    };\n    return BSpline_R1_to_R2_DifferentialProperties;\n}());\nexports.BSpline_R1_to_R2_DifferentialProperties = BSpline_R1_to_R2_DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BernsteinDecomposition_R1_to_R1 = void 0;\nvar BinomialCoefficient_1 = require(\"./BinomialCoefficient\");\n/**\n* A Bernstein decomposition of a B-Spline function from a one dimensional real space to a one dimensional real space\n*/\nvar BernsteinDecomposition_R1_to_R1 = /** @class */ (function () {\n    /**\n     *\n     * @param controlPointsArray An array of array of control points\n     */\n    function BernsteinDecomposition_R1_to_R1(controlPointsArray) {\n        this.controlPointsArray = controlPointsArray;\n    }\n    BernsteinDecomposition_R1_to_R1.prototype.add = function (bd) {\n        var result = [];\n        for (var i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (var j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] + bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.subtract = function (bd) {\n        var result = [];\n        for (var i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (var j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] - bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.multiply = function (bd) {\n        return new BernsteinDecomposition_R1_to_R1(this.bernsteinMultiplicationArray(this.controlPointsArray, bd.controlPointsArray));\n    };\n    /**\n     *\n     * @param bd: BernsteinDecomposition_R1_to_R1\n     * @param index: Index of the basis function\n     */\n    BernsteinDecomposition_R1_to_R1.prototype.multiplyRange = function (bd, start, lessThan) {\n        var result = [];\n        for (var i = start; i < lessThan; i += 1) {\n            result[i - start] = this.bernsteinMultiplication(this.controlPointsArray[i], bd.controlPointsArray[i]);\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.bernsteinMultiplicationArray = function (f, g) {\n        var result = [];\n        for (var i = 0; i < f.length; i += 1) {\n            result[i] = this.bernsteinMultiplication(f[i], g[i]);\n        }\n        return result;\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.bernsteinMultiplication = function (f, g) {\n        var f_degree = f.length - 1;\n        var g_degree = g.length - 1;\n        var result = [];\n        /*\n        for (let k = 0; k < f_degree + g_degree + 1; k += 1) {\n            let cp = 0;\n            for (let i = Math.max(0, k - g_degree); i < Math.min(f_degree, k) + 1; i += 1) {\n                let bfu = binomialCoefficient(f_degree, i);\n                let bgu = binomialCoefficient(g_degree, k - i);\n                let bfugu = binomialCoefficient(f_degree + g_degree, k);\n                cp += bfu * bgu / bfugu * f[i] * g[k - i];\n            }\n            result[k] = cp;\n        }\n        */\n        /*\n        BernsteinDecomposition_R1_to_R1.flopsCounter += 1\n        if (BernsteinDecomposition_R1_to_R1.flopsCounter % 1000 === 0) {\n          //console.log(\"Bernstein Multiplication\")\n          //console.log(BernsteinDecomposition_R1_to_R1.flopsCounter)\n        }\n        */\n        for (var k = 0; k < f_degree + g_degree + 1; k += 1) {\n            var cp = 0;\n            for (var i = Math.max(0, k - g_degree); i < Math.min(f_degree, k) + 1; i += 1) {\n                var bfu = BernsteinDecomposition_R1_to_R1.binomial(f_degree, i);\n                var bgu = BernsteinDecomposition_R1_to_R1.binomial(g_degree, k - i);\n                var bfugu = BernsteinDecomposition_R1_to_R1.binomial(f_degree + g_degree, k);\n                cp += bfu * bgu / bfugu * f[i] * g[k - i];\n            }\n            result[k] = cp;\n        }\n        return result;\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.multiplyByScalar = function (value) {\n        var result = [];\n        for (var i = 0; i < this.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (var j = 0; j < this.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] * value;\n            }\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.flattenControlPointsArray = function () {\n        //return this.controlPointsArray.flat();\n        return this.controlPointsArray.reduce(function (acc, val) {\n            return acc.concat(val);\n        }, []);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.subset = function (start, lessThan) {\n        return new BernsteinDecomposition_R1_to_R1(this.controlPointsArray.slice(start, lessThan));\n    };\n    BernsteinDecomposition_R1_to_R1.binomial = BinomialCoefficient_1.memoizedBinomialCoefficient();\n    BernsteinDecomposition_R1_to_R1.flopsCounter = 0;\n    return BernsteinDecomposition_R1_to_R1;\n}());\nexports.BernsteinDecomposition_R1_to_R1 = BernsteinDecomposition_R1_to_R1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memoizedBinomialCoefficient = exports.binomialCoefficient = void 0;\nfunction binomialCoefficient(n, k) {\n    var result = 1;\n    if (n < k || k < 0) {\n        return 0;\n    }\n    // take advantage of symmetry\n    if (k > n - k) {\n        k = n - k;\n    }\n    for (var x = n - k + 1; x <= n; x += 1) {\n        result *= x;\n    }\n    for (var x = 1; x <= k; x += 1) {\n        result /= x;\n    }\n    return result;\n}\nexports.binomialCoefficient = binomialCoefficient;\n;\nfunction memoizedBinomialCoefficient() {\n    var cache = [];\n    return function (n, k) {\n        if (cache[n] !== undefined && cache[n][k] !== undefined) {\n            return cache[n][k];\n        }\n        else {\n            if (cache[n] === undefined) {\n                cache[n] = [];\n            }\n            var result = binomialCoefficient(n, k);\n            cache[n][k] = result;\n            return result;\n        }\n    };\n}\nexports.memoizedBinomialCoefficient = memoizedBinomialCoefficient;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CholeskyDecomposition = void 0;\n/**\n * A decomposition of a positive-definite matirx into a product of a lower triangular matrix and its conjugate transpose\n */\nvar CholeskyDecomposition = /** @class */ (function () {\n    /**\n     * The values of the decomposition are stored in the lower triangular portion of the matrix g\n     * @param matrix Matrix\n     */\n    function CholeskyDecomposition(matrix) {\n        this.success = false;\n        this.CLOSE_TO_ZERO = 10e-8;\n        this.firstNonPositiveDefiniteLeadingSubmatrixSize = -1;\n        this.g = matrix.squareMatrix();\n        var n = this.g.shape[0];\n        if (this.g.get(0, 0) < this.CLOSE_TO_ZERO) {\n            return;\n        }\n        var sqrtGjj = Math.sqrt(this.g.get(0, 0));\n        for (var i = 0; i < n; i += 1) {\n            this.g.divideAt(i, 0, sqrtGjj);\n        }\n        for (var j = 1; j < n; j += 1) {\n            for (var i = j; i < n; i += 1) {\n                var sum = 0;\n                for (var k = 0; k < j; k += 1) {\n                    sum += this.g.get(i, k) * this.g.get(j, k);\n                }\n                this.g.substractAt(i, j, sum);\n            }\n            if (this.g.get(j, j) < this.CLOSE_TO_ZERO) {\n                this.firstNonPositiveDefiniteLeadingSubmatrixSize = j + 1;\n                return;\n            }\n            sqrtGjj = Math.sqrt(this.g.get(j, j));\n            for (var i = j; i < n; i += 1) {\n                this.g.divideAt(i, j, sqrtGjj);\n            }\n        }\n        for (var j = 0; j < n; j += 1) {\n            for (var i = 0; i < j; i += 1) {\n                this.g.set(i, j, 0);\n            }\n        }\n        this.success = true;\n    }\n    /**\n     * Solve the linear system\n     * @param b Vector\n     * @return The vector x\n     * @throws If the Cholesky decomposition failed\n     */\n    CholeskyDecomposition.prototype.solve = function (b) {\n        'use strict';\n        // See Numerical Recipes Third Edition p. 101\n        if (!this.success) {\n            throw new Error(\"CholeskyDecomposistion.success === false\");\n        }\n        if (b.length !== this.g.shape[0]) {\n            throw new Error(\"The size of the cholesky decomposed matrix g and the vector b do not match\");\n        }\n        var n = this.g.shape[0];\n        var x = b.slice();\n        // Ly = b\n        for (var i = 0; i < n; i += 1) {\n            var sum = b[i];\n            for (var k = i - 1; k >= 0; k -= 1) {\n                sum -= this.g.get(i, k) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        // LT x = Y\n        for (var i = n - 1; i >= 0; i -= 1) {\n            var sum = x[i];\n            for (var k = i + 1; k < n; k += 1) {\n                sum -= this.g.get(k, i) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        return x;\n    };\n    /**\n     * Solve the linear equation Lower triangular matrix LT * x = b\n     * @param b Vector\n     */\n    CholeskyDecomposition.prototype.solve_LT_result_equal_b = function (b) {\n        var n = this.g.shape[0];\n        var x = b.slice();\n        for (var i = 0; i < n; i += 1) {\n            var sum = b[i];\n            for (var k = i - 1; k >= 0; k -= 1) {\n                sum -= this.g.get(i, k) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        return x;\n    };\n    return CholeskyDecomposition;\n}());\nexports.CholeskyDecomposition = CholeskyDecomposition;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DenseMatrix = void 0;\n/**\n * A dense matrix\n */\nvar DenseMatrix = /** @class */ (function () {\n    /**\n     * Create a square matrix\n     * @param nrows Number of rows\n     * @param ncols Number of columns\n     * @param data A row after row flat array\n     * @throws If data length is not equal to nrows*ncols\n     */\n    function DenseMatrix(nrows, ncols, data) {\n        this._shape = [nrows, ncols];\n        if (data) {\n            if (data.length !== this.shape[0] * this.shape[1]) {\n                throw new Error(\"Dense matrix constructor expect the data to have nrows*ncols length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            for (var i = 0; i < this.shape[0] * this.shape[1]; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    Object.defineProperty(DenseMatrix.prototype, \"shape\", {\n        /**\n         * Returns the shape of the matrix : [number of rows, number of columns]\n         */\n        get: function () {\n            return this._shape;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Return the corresponding index in the flat row by row data vector\n     * @param row The row index\n     * @param column The column index\n     */\n    DenseMatrix.prototype.dataIndex = function (row, column) {\n        var n = row * this.shape[1] + column;\n        return n;\n    };\n    /**\n     * Return the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    DenseMatrix.prototype.get = function (row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    };\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    DenseMatrix.prototype.set = function (row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    };\n    /**\n     * Check that the column index is inside appropriate range\n     * @param index The column index\n     * @throws If index is out of range\n     */\n    DenseMatrix.prototype.checkColumnRange = function (index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"DenseMatrix column index out of range\");\n        }\n    };\n    /**\n     * Check that the row index is inside appropriate range\n     * @param index The row index\n     * @throws If index is out of range\n     */\n    DenseMatrix.prototype.checkRowRange = function (index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"DenseMatrix row index out of range\");\n        }\n    };\n    return DenseMatrix;\n}());\nexports.DenseMatrix = DenseMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.identityMatrix = exports.DiagonalMatrix = void 0;\n/**\n * An identity matrix\n */\nvar DiagonalMatrix = /** @class */ (function () {\n    /**\n     * Create a Symmetric Matrix\n     * @param size The number of rows or the number columns\n     * @param data The matrix data in a flat vector\n     */\n    function DiagonalMatrix(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size) {\n                throw new Error(\"Diagonal matrix constructor expect the data to have size length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            var n = size;\n            for (var i = 0; i < n; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    Object.defineProperty(DiagonalMatrix.prototype, \"shape\", {\n        /**\n         * Returns the shape of the matrix : [number of rows, number of columns]\n         */\n        get: function () {\n            return this._shape;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n * Returns the value at a given row and column position\n * @param row The row index\n * @param column The column index\n * @return Scalar\n * @throws If an index is out of range\n */\n    DiagonalMatrix.prototype.get = function (row, column) {\n        this.checkRange(row, column);\n        return this.data[row];\n    };\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    DiagonalMatrix.prototype.set = function (row, column, value) {\n        this.checkRange(row, column);\n        this.data[row] = value;\n    };\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    DiagonalMatrix.prototype.checkRange = function (row, column) {\n        if (row < 0 || row >= this.shape[0] || row != column) {\n            throw new Error(\"DiagonalMatrix index is out of range\");\n        }\n    };\n    return DiagonalMatrix;\n}());\nexports.DiagonalMatrix = DiagonalMatrix;\nfunction identityMatrix(n) {\n    var result = new DiagonalMatrix(n);\n    for (var i = 0; i < n; i += 1) {\n        result.set(i, i, 1);\n    }\n    return result;\n}\nexports.identityMatrix = identityMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sign = exports.containsNaN = exports.randomVector = exports.isZeroVector = exports.product_v1_v2t = exports.product_v_vt = exports.zeroVector = exports.norm1 = exports.norm = exports.squaredNorm = exports.addSecondVectorToFirst = exports.addTwoVectors = exports.dotProduct = exports.saxpy2 = exports.saxpy = exports.divideVectorByScalar = exports.multiplyVectorByScalar = void 0;\nvar SquareMatrix_1 = require(\"./SquareMatrix\");\nvar DenseMatrix_1 = require(\"./DenseMatrix\");\n/**\n * Multiply a vector by a scalar\n * @param vector vector\n * @param value scalar\n */\nfunction multiplyVectorByScalar(vector, value) {\n    var result = [];\n    for (var i = 0; i < vector.length; i += 1) {\n        result.push(vector[i] * value);\n    }\n    return result;\n}\nexports.multiplyVectorByScalar = multiplyVectorByScalar;\n/**\n * Divide a vector by a scalar\n * @param vector Vector\n * @param value Scalar\n * @throws If the scalar value is zero\n */\nfunction divideVectorByScalar(vector, value) {\n    if (value === 0) {\n        throw new Error(\"Division by zero\");\n    }\n    var result = [];\n    for (var i = 0; i < vector.length; i += 1) {\n        result.push(vector[i] / value);\n    }\n    return result;\n}\nexports.divideVectorByScalar = divideVectorByScalar;\n/**\n * A standard function in basic linear algebra : y = ax + y\n * @param a Scalar\n * @param x Vector\n * @param y Vector\n * @throws If x and y have different length\n */\nfunction saxpy(a, x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    for (var i = 0; i < x.length; i += 1) {\n        y[i] += a * x[i];\n    }\n}\nexports.saxpy = saxpy;\n/**\n * A standard function in basic linear algebra : z = ax + y\n * @param a Scalar\n * @param x Vector\n * @param y Vector\n * @returns ax + y\n * @throws If x and y have different length\n */\nfunction saxpy2(a, x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    var result = [];\n    for (var i = 0; i < x.length; i += 1) {\n        result.push(a * x[i] + y[i]);\n    }\n    return result;\n}\nexports.saxpy2 = saxpy2;\n/**\n * Compute the dot product of two vectors\n * @param x Vector\n * @param y Vector\n * @return The scalar result\n * @throws If x and y have different length\n */\nfunction dotProduct(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Making the dot product of two vectors of different length\");\n    }\n    var result = 0;\n    for (var i = 0; i < x.length; i += 1) {\n        result += x[i] * y[i];\n    }\n    return result;\n}\nexports.dotProduct = dotProduct;\n/**\n * Add two vectors\n * @param x Vector\n * @param y Vector\n * @return Vector\n * @throws If x and y have different length\n */\nfunction addTwoVectors(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    var result = [];\n    for (var i = 0; i < x.length; i += 1) {\n        result.push(x[i] + y[i]);\n    }\n    return result;\n}\nexports.addTwoVectors = addTwoVectors;\n/**\n * Add the second vector to the first vector\n * @param x Vector\n * @param y Vector\n * @throws If x and y have different length\n */\nfunction addSecondVectorToFirst(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    for (var i = 0; i < x.length; i += 1) {\n        x[i] += y[i];\n    }\n}\nexports.addSecondVectorToFirst = addSecondVectorToFirst;\n/**\n * Compute the square of the norm\n * @param v Vector\n * @return Non negative scalar\n */\nfunction squaredNorm(v) {\n    var result = 0;\n    for (var i = 0; i < v.length; i += 1) {\n        result += v[i] * v[i];\n    }\n    return result;\n}\nexports.squaredNorm = squaredNorm;\n/**\n * Compute the norm\n * @param v Vector\n * @return Non negative scalar\n */\nfunction norm(v) {\n    return Math.sqrt(squaredNorm(v));\n}\nexports.norm = norm;\n/**\n * Compute the norm p = 1\n * @param v Vector\n * @return Non negative scalar\n */\nfunction norm1(v) {\n    var result = 0;\n    for (var i = 0; i < v.length; i += 1) {\n        result += Math.abs(v[i]);\n    }\n    return result;\n}\nexports.norm1 = norm1;\n/**\n * Create a zero vector of size n\n * @param n Size\n */\nfunction zeroVector(n) {\n    var result = [];\n    for (var i = 0; i < n; i += 1) {\n        result.push(0);\n    }\n    return result;\n}\nexports.zeroVector = zeroVector;\n;\n/**\n * Compute the product of a vector and its transpose\n * @param v Vector\n */\nfunction product_v_vt(v) {\n    var n = v.length;\n    var result = new SquareMatrix_1.SquareMatrix(n);\n    for (var i = 0; i < n; i += 1) {\n        for (var j = 0; j < n; j += 1) {\n            result.set(i, j, v[i] * v[j]);\n        }\n    }\n    return result;\n}\nexports.product_v_vt = product_v_vt;\n/**\n * Compute the product of a first vector with the transpose of a second vector\n * @param v1 The first vector taken as a column vector\n * @param v2 The second vector taken after transposition as a row vector\n */\nfunction product_v1_v2t(v1, v2) {\n    var m = v1.length;\n    var n = v2.length;\n    var result = new DenseMatrix_1.DenseMatrix(m, n);\n    for (var i = 0; i < m; i += 1) {\n        for (var j = 0; j < n; j += 1) {\n            result.set(i, j, v1[i] * v2[j]);\n        }\n    }\n    return result;\n}\nexports.product_v1_v2t = product_v1_v2t;\nfunction isZeroVector(v) {\n    var n = v.length;\n    for (var i = 0; i < v.length; i += 1) {\n        if (v[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isZeroVector = isZeroVector;\n/**\n * Returns a vector filled with random values between 0 and 1\n * @param n The size of the random vector\n */\nfunction randomVector(n) {\n    var result = [];\n    for (var i = 0; i < n; i += 1) {\n        result.push((Math.random() - 0.5) * 10e8);\n        //result.push((Math.random())*10e8)\n    }\n    return result;\n}\nexports.randomVector = randomVector;\nfunction containsNaN(v) {\n    var n = v.length;\n    for (var i = 0; i < v.length; i += 1) {\n        if (isNaN(v[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.containsNaN = containsNaN;\n/**\n * Return the sign of a number.\n * It returns 1 if the number is positive, -1 if the number is negative and 0 if it is zero or minus zero\n * The standard Math.sign() function doesn't work with Windows Internet Explorer\n * @param x Number\n */\nfunction sign(x) {\n    return x ? x < 0 ? -1 : 1 : 0;\n}\nexports.sign = sign;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection = exports.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection = exports.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection = exports.OptimizationProblem_BSpline_R1_to_R2_inflection = exports.ActiveControl = void 0;\nvar MathVectorBasicOperations_1 = require(\"./MathVectorBasicOperations\");\nvar BSpline_R1_to_R1_1 = require(\"./BSpline_R1_to_R1\");\nvar BernsteinDecomposition_R1_to_R1_1 = require(\"./BernsteinDecomposition_R1_to_R1\");\nvar DiagonalMatrix_1 = require(\"./DiagonalMatrix\");\nvar DenseMatrix_1 = require(\"./DenseMatrix\");\nvar SymmetricMatrix_1 = require(\"./SymmetricMatrix\");\nvar ExpensiveComputationResults = /** @class */ (function () {\n    function ExpensiveComputationResults(bdsxu, bdsyu, bdsxuu, bdsyuu, bdsxuuu, bdsyuuu, h1, h2, h3, h4) {\n        this.bdsxu = bdsxu;\n        this.bdsyu = bdsyu;\n        this.bdsxuu = bdsxuu;\n        this.bdsyuu = bdsyuu;\n        this.bdsxuuu = bdsxuuu;\n        this.bdsyuuu = bdsyuuu;\n        this.h1 = h1;\n        this.h2 = h2;\n        this.h3 = h3;\n        this.h4 = h4;\n    }\n    return ExpensiveComputationResults;\n}());\nvar ActiveControl;\n(function (ActiveControl) {\n    ActiveControl[ActiveControl[\"curvatureExtrema\"] = 0] = \"curvatureExtrema\";\n    ActiveControl[ActiveControl[\"inflections\"] = 1] = \"inflections\";\n    ActiveControl[ActiveControl[\"both\"] = 2] = \"both\";\n})(ActiveControl = exports.ActiveControl || (exports.ActiveControl = {}));\nvar OptimizationProblem_BSpline_R1_to_R2_inflection = /** @class */ (function () {\n    //public activeControl: ActiveControl = ActiveControl.both\n    function OptimizationProblem_BSpline_R1_to_R2_inflection(target, initial, activeControl) {\n        if (activeControl === void 0) { activeControl = ActiveControl.both; }\n        this.activeControl = activeControl;\n        this.curvatureExtremaConstraintsSign = [];\n        this.curvatureExtremaInactiveConstraints = [];\n        this.inflectionConstraintsSign = [];\n        this.inflectionInactiveConstraints = [];\n        //private _hessian_f: SymmetricMatrixInterface[] | undefined = undefined\n        this._hessian_f = undefined;\n        this.isComputingHessian = false;\n        this.Dh5xx = [];\n        this.Dh6_7xy = [];\n        this.Dh8_9xx = [];\n        this.Dh10_11xy = [];\n        this.spline = initial.clone();\n        this._target = target.clone();\n        var n = this.spline.controlPoints.length;\n        this._numberOfIndependentVariables = n * 2;\n        var diracControlPoints = MathVectorBasicOperations_1.zeroVector(n);\n        this.Dsu = [];\n        this.Dsuu = [];\n        this.Dsuuu = [];\n        for (var i = 0; i < n; i += 1) {\n            diracControlPoints[i] = 1;\n            var s = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(diracControlPoints.slice(), this.spline.knots.slice());\n            var su = s.derivative();\n            var suu = su.derivative();\n            var suuu = suu.derivative();\n            this.Dsu.push(new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(su.bernsteinDecomposition()));\n            this.Dsuu.push(new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(suu.bernsteinDecomposition()));\n            this.Dsuuu.push(new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(suuu.bernsteinDecomposition()));\n            diracControlPoints[i] = 0;\n        }\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        this._hessian_f0 = DiagonalMatrix_1.identityMatrix(this.numberOfIndependentVariables);\n        var e = this.expensiveComputation(this.spline);\n        var curvatureNumerator = this.curvatureNumerator(e.h4);\n        this.inflectionTotalNumberOfConstraints = curvatureNumerator.length;\n        var g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaTotalNumberOfConstraints = g.length;\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        this.curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g);\n        this._curvatureExtremaNumberOfActiveConstraints = g.length - this.curvatureExtremaInactiveConstraints.length;\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        this.inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator);\n        this._inflectionNumberOfActiveConstraints = curvatureNumerator.length - this.inflectionInactiveConstraints.length;\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this.inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this.inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n        if (this.isComputingHessian) {\n            this.prepareForHessianComputation(this.Dsu, this.Dsuu, this.Dsuuu);\n            this._hessian_f = this.compute_hessian_f(e.bdsxu, e.bdsyu, e.bdsxuu, e.bdsyuu, e.bdsxuuu, e.bdsyuuu, e.h1, e.h2, e.h3, e.h4, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n        }\n    }\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"targetSpline\", {\n        set: function (spline) {\n            this._target = spline;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"curvatureExtremaConstraintsFreeIndices\", {\n        get: function () {\n            return this.curvatureExtremaInactiveConstraints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"inflectionConstraintsFreeIndices\", {\n        get: function () {\n            return this.inflectionInactiveConstraints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"numberOfIndependentVariables\", {\n        get: function () {\n            return this._numberOfIndependentVariables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"numberOfConstraints\", {\n        get: function () {\n            return this._curvatureExtremaNumberOfActiveConstraints + this._inflectionNumberOfActiveConstraints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"f0\", {\n        get: function () {\n            return this._f0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"gradient_f0\", {\n        get: function () {\n            return this._gradient_f0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"hessian_f0\", {\n        get: function () {\n            return this._hessian_f0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"f\", {\n        get: function () {\n            if (MathVectorBasicOperations_1.containsNaN(this._f)) {\n                throw new Error(\"OptimizationProblem_BSpline_R1_to_R2 contains Nan in its f vector\");\n            }\n            return this._f;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"gradient_f\", {\n        get: function () {\n            return this._gradient_f;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_inflection.prototype, \"hessian_f\", {\n        get: function () {\n            return this._hessian_f;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.step = function (deltaX) {\n        this.spline.optimizerStep(deltaX);\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        var e = this.expensiveComputation(this.spline);\n        var g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        this.curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g);\n        this._curvatureExtremaNumberOfActiveConstraints = g.length - this.curvatureExtremaInactiveConstraints.length;\n        var curvatureNumerator = this.curvatureNumerator(e.h4);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        this.inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator);\n        this._inflectionNumberOfActiveConstraints = curvatureNumerator.length - this.inflectionInactiveConstraints.length;\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this.inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this.inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n        if (this.isComputingHessian) {\n            this._hessian_f = this.compute_hessian_f(e.bdsxu, e.bdsyu, e.bdsxuu, e.bdsyuu, e.bdsxuuu, e.bdsyuuu, e.h1, e.h2, e.h3, e.h4, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n        }\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.computeConstraintsSign = function (controlPoints) {\n        var result = [];\n        for (var i = 0, n = controlPoints.length; i < n; i += 1) {\n            if (controlPoints[i] > 0) {\n                result.push(-1);\n            }\n            else {\n                result.push(1);\n            }\n        }\n        //console.log(result.length)\n        return result;\n    };\n    /**\n     * Some contraints are set inactive to allowed the point of curvature extrema to slide along the curve.\n     * A curvature extremum is located between two coefficient of different signs.\n     * For the general case, the smallest coefficient in absolute value is chosen to be free.\n     * For the specific case of two successive sign changes, the coefficient in the middle is chosen.\n     *\n     * @param constraintsSign The vector of sign for the constraints: sign f_i <= 0\n     * @param controlPoints The vector of value of the function: f_i\n     */\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.computeInactiveConstraints = function (constraintsSign, controlPoints) {\n        var result = [];\n        /*\n        let previousSign = constraintsSign[0];\n        for (let i = 1, n = constraintsSign.length; i < n; i += 1) {\n            if (previousSign !== constraintsSign[i]) {\n                if (i + 1 < n - 1 && constraintsSign[i+1] !== constraintsSign[i]){\n                    result.push(i)\n                    i += 1\n                } else if (Math.pow(controlPoints[i - 1], 2) < Math.pow(controlPoints[i], 2)) {\n                    result.push(i - 1);\n                } else {\n                    result.push(i);\n                }\n            }\n            previousSign = constraintsSign[i];\n        }\n        */\n        //console.log(result)\n        var signChangesIntervals = [];\n        var previousSign = constraintsSign[0];\n        for (var i = 1, n = constraintsSign.length; i < n; i += 1) {\n            if (previousSign !== constraintsSign[i]) {\n                signChangesIntervals.push(i - 1);\n            }\n            previousSign = constraintsSign[i];\n        }\n        var identicalSuccessiveControlPoints = [];\n        for (var i = 0, n = constraintsSign.length; i < n - 1; i += 1) {\n            if (controlPoints[i] === controlPoints[i + 1]) {\n                identicalSuccessiveControlPoints.push(i);\n            }\n        }\n        for (var i = 0, n = signChangesIntervals.length; i < n; i += 1) {\n            if (i < n - 1 && signChangesIntervals[i] + 1 === signChangesIntervals[i + 1]) {\n                result.push(signChangesIntervals[i] + 1);\n                i += 1;\n            }\n            else {\n                if (Math.pow(controlPoints[signChangesIntervals[i]], 2) < Math.pow(controlPoints[signChangesIntervals[i] + 1], 2)) {\n                    result.push(signChangesIntervals[i]);\n                }\n                else {\n                    result.push(signChangesIntervals[i] + 1);\n                }\n            }\n        }\n        var result1 = [];\n        for (var i = 0, n = result.length; i < n; i += 1) {\n            if (result[i] !== 0 && controlPoints[result[i] - 1] === controlPoints[result[i]]) {\n                if (i == 0) {\n                    result1.push(result[i] - 1);\n                }\n                if (i !== 0 && result[i - 1] !== result[i] - 1) {\n                    result1.push(result[i] - 1);\n                }\n            }\n            result1.push(result[i]);\n            if (result[i] !== controlPoints.length - 2 && controlPoints[result[i]] === controlPoints[result[i] + 1]) {\n                if (i == result.length - 1) {\n                    result1.push(result[i] + 1);\n                }\n                if (i !== result.length - 1 && result[i + 1] !== result[i] + 1) {\n                    result1.push(result[i] + 1);\n                }\n            }\n        }\n        return result1;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_gradient_f0 = function (spline) {\n        var result = [];\n        var n = spline.controlPoints.length;\n        for (var i = 0; i < n; i += 1) {\n            result.push(spline.controlPoints[i].x - this._target.controlPoints[i].x);\n        }\n        for (var i = 0; i < n; i += 1) {\n            result.push(spline.controlPoints[i].y - this._target.controlPoints[i].y);\n        }\n        return result;\n    };\n    //f0: function to minimize\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_f0 = function (gradient_f0) {\n        var result = 0;\n        var n = gradient_f0.length;\n        for (var i = 0; i < n; i += 1) {\n            result += Math.pow(gradient_f0[i], 2);\n        }\n        return 0.5 * result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.curvatureNumerator = function (h4) {\n        return h4.flattenControlPointsArray();\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.curvatureDerivativeNumerator = function (h1, h2, h3, h4) {\n        var g = (h1.multiply(h2)).subtract(h3.multiply(h4).multiplyByScalar(3));\n        var result = g.flattenControlPointsArray();\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.g = function () {\n        var e = this.expensiveComputation(this.spline);\n        return this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.gradient_g = function () {\n        var e = this.expensiveComputation(this.spline);\n        return this.gradient_curvatureDerivativeNumerator(e.bdsxu, e.bdsyu, e.bdsxuu, e.bdsyuu, e.bdsxuuu, e.bdsyuuu, e.h1, e.h2, e.h3, e.h4);\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_curvatureExtremaConstraints = function (curvatureDerivativeNumerator, constraintsSign, inactiveConstraints) {\n        var result = [];\n        for (var i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureDerivativeNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_inflectionConstraints = function (curvatureNumerator, constraintsSign, inactiveConstraints) {\n        var result = [];\n        for (var i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_f = function (curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        //let result: number[] = []\n        if (this.activeControl === ActiveControl.both) {\n            var r1 = this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            var r2 = this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n            return r1.concat(r2);\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.expensiveComputation = function (spline) {\n        var sx = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(spline.getControlPointsX(), spline.knots), sy = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(spline.getControlPointsY(), spline.knots), sxu = sx.derivative(), syu = sy.derivative(), sxuu = sxu.derivative(), syuu = syu.derivative(), sxuuu = sxuu.derivative(), syuuu = syuu.derivative(), bdsxu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxu.bernsteinDecomposition()), bdsyu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syu.bernsteinDecomposition()), bdsxuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxuu.bernsteinDecomposition()), bdsyuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syuu.bernsteinDecomposition()), bdsxuuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxuuu.bernsteinDecomposition()), bdsyuuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syuuu.bernsteinDecomposition()), h1 = (bdsxu.multiply(bdsxu)).add(bdsyu.multiply(bdsyu)), h2 = (bdsxu.multiply(bdsyuuu)).subtract(bdsyu.multiply(bdsxuuu)), h3 = (bdsxu.multiply(bdsxuu)).add(bdsyu.multiply(bdsyuu)), h4 = (bdsxu.multiply(bdsyuu)).subtract(bdsyu.multiply(bdsxuu));\n        return new ExpensiveComputationResults(bdsxu, bdsyu, bdsxuu, bdsyuu, bdsxuuu, bdsyuuu, h1, h2, h3, h4);\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.gradient_curvatureDerivativeNumerator = function (sxu, syu, sxuu, syuu, sxuuu, syuuu, h1, h2, h3, h4) {\n        var dgx = [];\n        var dgy = [];\n        var m = this.spline.controlPoints.length;\n        var n = this.curvatureExtremaTotalNumberOfConstraints;\n        var result = new DenseMatrix_1.DenseMatrix(n, 2 * m);\n        for (var i = 0; i < m; i += 1) {\n            var h5 = this.Dsu[i].multiply(sxu);\n            var h6 = this.Dsu[i].multiply(syuuu);\n            var h7 = syu.multiply(this.Dsuuu[i]).multiplyByScalar(-1);\n            var h8 = this.Dsu[i].multiply(sxuu);\n            var h9 = sxu.multiply(this.Dsuu[i]);\n            var h10 = this.Dsu[i].multiply(syuu);\n            var h11 = syu.multiply(this.Dsuu[i]).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2).multiplyByScalar(2)).add(h1.multiply(h6.add(h7))).add(((((h8.add(h9)).multiply(h4))).add((h10.add(h11)).multiply(h3))).multiplyByScalar(-3)));\n        }\n        for (var i = 0; i < m; i += 1) {\n            var h5 = this.Dsu[i].multiply(syu);\n            var h6 = this.Dsu[i].multiply(sxuuu).multiplyByScalar(-1);\n            var h7 = sxu.multiply(this.Dsuuu[i]);\n            var h8 = this.Dsu[i].multiply(syuu);\n            var h9 = syu.multiply(this.Dsuu[i]);\n            var h10 = this.Dsu[i].multiply(sxuu).multiplyByScalar(-1);\n            var h11 = sxu.multiply(this.Dsuu[i]);\n            dgy.push((h5.multiply(h2).multiplyByScalar(2)).add(h1.multiply(h6.add(h7))).add(((((h8.add(h9)).multiply(h4))).add((h10.add(h11)).multiply(h3))).multiplyByScalar(-3)));\n        }\n        for (var i = 0; i < m; i += 1) {\n            var cpx = dgx[i].flattenControlPointsArray();\n            var cpy = dgy[i].flattenControlPointsArray();\n            for (var j = 0; j < n; j += 1) {\n                result.set(j, i, cpx[j]);\n                result.set(j, m + i, cpy[j]);\n            }\n        }\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_gradient_f = function (e, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            var m1 = this.compute_curvatureExtremaConstraints_gradient(e, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            var m2 = this.compute_inflectionConstraints_gradient(e, inflectionConstraintsSign, inflectionInactiveConstraints);\n            var _a = m1.shape, row_m1 = _a[0], n = _a[1];\n            var row_m2 = m2.shape[0];\n            var m = row_m1 + row_m2;\n            var result = new DenseMatrix_1.DenseMatrix(m, n);\n            for (var i = 0; i < row_m1; i += 1) {\n                for (var j = 0; j < n; j += 1) {\n                    result.set(i, j, m1.get(i, j));\n                }\n            }\n            for (var i = 0; i < row_m2; i += 1) {\n                for (var j = 0; j < n; j += 1) {\n                    result.set(row_m1 + i, j, m2.get(i, j));\n                }\n            }\n            return result;\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints_gradient(e, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints_gradient(e, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_curvatureExtremaConstraints_gradient = function (e, constraintsSign, inactiveConstraints) {\n        var sxu = e.bdsxu;\n        var sxuu = e.bdsxuu;\n        var sxuuu = e.bdsxuuu;\n        var syu = e.bdsyu;\n        var syuu = e.bdsyuu;\n        var syuuu = e.bdsyuuu;\n        var h1 = e.h1;\n        var h2 = e.h2;\n        var h3 = e.h3;\n        var h4 = e.h4;\n        var dgx = [];\n        var dgy = [];\n        var controlPointsLength = this.spline.controlPoints.length;\n        var totalNumberOfConstraints = this.curvatureExtremaTotalNumberOfConstraints;\n        var degree = this.spline.degree;\n        for (var i = 0; i < controlPointsLength; i += 1) {\n            var start = Math.max(0, i - degree);\n            var lessThan = Math.min(controlPointsLength - degree, i + 1);\n            var h1_subset = h1.subset(start, lessThan);\n            var h2_subset = h2.subset(start, lessThan);\n            var h3_subset = h3.subset(start, lessThan);\n            var h4_subset = h4.subset(start, lessThan);\n            var h5 = this.Dsu[i].multiplyRange(sxu, start, lessThan);\n            var h6 = this.Dsu[i].multiplyRange(syuuu, start, lessThan);\n            var h7 = syu.multiplyRange(this.Dsuuu[i], start, lessThan).multiplyByScalar(-1);\n            var h8 = this.Dsu[i].multiplyRange(sxuu, start, lessThan);\n            var h9 = sxu.multiplyRange(this.Dsuu[i], start, lessThan);\n            var h10 = this.Dsu[i].multiplyRange(syuu, start, lessThan);\n            var h11 = syu.multiplyRange(this.Dsuu[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add(((((h8.add(h9)).multiply(h4_subset))).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (var i = 0; i < controlPointsLength; i += 1) {\n            var start = Math.max(0, i - degree);\n            var lessThan = Math.min(controlPointsLength - degree, i + 1);\n            var h1_subset = h1.subset(start, lessThan);\n            var h2_subset = h2.subset(start, lessThan);\n            var h3_subset = h3.subset(start, lessThan);\n            var h4_subset = h4.subset(start, lessThan);\n            var h5 = this.Dsu[i].multiplyRange(syu, start, lessThan);\n            var h6 = this.Dsu[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            var h7 = sxu.multiplyRange(this.Dsuuu[i], start, lessThan);\n            var h8 = this.Dsu[i].multiplyRange(syuu, start, lessThan);\n            var h9 = syu.multiplyRange(this.Dsuu[i], start, lessThan);\n            var h10 = this.Dsu[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            var h11 = sxu.multiplyRange(this.Dsuu[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add(((((h8.add(h9)).multiply(h4_subset))).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        var result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * controlPointsLength);\n        for (var i = 0; i < controlPointsLength; i += 1) {\n            var cpx = dgx[i].flattenControlPointsArray();\n            var cpy = dgy[i].flattenControlPointsArray();\n            var start = Math.max(0, i - degree) * (4 * degree - 5);\n            var lessThan = Math.min(controlPointsLength - degree, i + 1) * (4 * degree - 5);\n            var deltaj = 0;\n            for (var i_1 = 0; i_1 < inactiveConstraints.length; i_1 += 1) {\n                if (inactiveConstraints[i_1] >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (var j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_inflectionConstraints_gradient = function (e, constraintsSign, inactiveConstraints) {\n        var sxu = e.bdsxu;\n        var sxuu = e.bdsxuu;\n        var syu = e.bdsyu;\n        var syuu = e.bdsyuu;\n        var dgx = [];\n        var dgy = [];\n        var controlPointsLength = this.spline.controlPoints.length;\n        //const totalNumberOfConstraints = this.curvatureExtremaTotalNumberOfConstraints\n        var degree = this.spline.degree;\n        for (var i = 0; i < controlPointsLength; i += 1) {\n            var start = Math.max(0, i - degree);\n            var lessThan = Math.min(controlPointsLength - degree, i + 1);\n            var h10 = this.Dsu[i].multiplyRange(syuu, start, lessThan);\n            var h11 = syu.multiplyRange(this.Dsuu[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (var i = 0; i < controlPointsLength; i += 1) {\n            var start = Math.max(0, i - degree);\n            var lessThan = Math.min(controlPointsLength - degree, i + 1);\n            var h10 = this.Dsu[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            var h11 = sxu.multiplyRange(this.Dsuu[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        /*\n        const n = constraintsSign.length - inactiveConstraints.length\n\n        const m = this.spline.controlPoints.length\n\n        let result = new DenseMatrix(n, 2 * m)\n\n        for (let i = 0; i < m; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let deltaj = 0\n            for (let j = 0; j < constraintsSign.length; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1\n                } else {\n                    result.set(j-deltaj, i, cpx[j] * constraintsSign[j])\n                    result.set(j-deltaj, m + i, cpy[j] * constraintsSign[j])\n                }\n            }\n        }\n        */\n        var totalNumberOfConstraints = this.inflectionConstraintsSign.length;\n        var result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * controlPointsLength);\n        for (var i = 0; i < controlPointsLength; i += 1) {\n            var cpx = dgx[i].flattenControlPointsArray();\n            var cpy = dgy[i].flattenControlPointsArray();\n            var start = Math.max(0, i - degree) * (2 * degree - 2);\n            var lessThan = Math.min(controlPointsLength - degree, i + 1) * (2 * degree - 2);\n            var deltaj = 0;\n            for (var i_2 = 0; i_2 < inactiveConstraints.length; i_2 += 1) {\n                if (inactiveConstraints[i_2] >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (var j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.compute_hessian_f = function (sxu, syu, sxuu, syuu, sxuuu, syuuu, h1, h2, h3, h4, constraintsSign, inactiveConstraints) {\n        var n = this.spline.controlPoints.length;\n        var result = [];\n        var h5x = [];\n        var h5y = [];\n        var h6x = [];\n        var h6y = [];\n        var h7x = [];\n        var h7y = [];\n        var h8x = [];\n        var h8y = [];\n        var h9x = [];\n        var h9y = [];\n        var h10x = [];\n        var h10y = [];\n        var h11x = [];\n        var h11y = [];\n        var hessian_gxx = [];\n        var hessian_gyy = [];\n        var hessian_gxy = [];\n        for (var i = 0; i < n; i += 1) {\n            hessian_gxx.push([]);\n            hessian_gyy.push([]);\n            hessian_gxy.push([]);\n        }\n        for (var i = 0; i < n; i += 1) {\n            h5x.push(this.Dsu[i].multiply(sxu));\n            h6x.push(this.Dsu[i].multiply(syuuu));\n            h7x.push(syu.multiply(this.Dsuuu[i]).multiplyByScalar(-1));\n            h8x.push(this.Dsu[i].multiply(sxuu));\n            h9x.push(sxu.multiply(this.Dsuu[i]));\n            h10x.push(this.Dsu[i].multiply(syuu));\n            h11x.push(syu.multiply(this.Dsuu[i]).multiplyByScalar(-1));\n        }\n        for (var i = 0; i < n; i += 1) {\n            h5y.push(this.Dsu[i].multiply(syu));\n            h6y.push(this.Dsu[i].multiply(sxuuu).multiplyByScalar(-1));\n            h7y.push(sxu.multiply(this.Dsuuu[i]));\n            h8y.push(this.Dsu[i].multiply(syuu));\n            h9y.push(syu.multiply(this.Dsuu[i]));\n            h10y.push(this.Dsu[i].multiply(sxuu).multiplyByScalar(-1));\n            h11y.push(sxu.multiply(this.Dsuu[i]));\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j <= i; j += 1) {\n                var term1 = this.Dh5xx[i][j].multiply(h2).multiplyByScalar(2);\n                var term2xx = ((h5x[j].multiply(h6x[i].add(h7x[i]))).add(h5x[i].multiply((h6x[j].add(h7x[j]))))).multiplyByScalar(2);\n                var term2yy = ((h5y[j].multiply(h6y[i].add(h7y[i]))).add(h5y[i].multiply((h6y[j].add(h7y[j]))))).multiplyByScalar(2);\n                // term3 = 0\n                var term4 = this.Dh8_9xx[i][j].multiply(h4).multiplyByScalar(-3);\n                var term5xx = (((h8x[j].add(h9x[j])).multiply(h10x[i].add(h11x[i]))).add((h8x[i].add(h9x[i])).multiply((h10x[j].add(h11x[j]))))).multiplyByScalar(-3);\n                var term5yy = (((h8y[j].add(h9y[j])).multiply(h10y[i].add(h11y[i]))).add((h8y[i].add(h9y[i])).multiply((h10y[j].add(h11y[j]))))).multiplyByScalar(-3);\n                // term 6 = 0\n                hessian_gxx[i][j] = (term1.add(term2xx).add(term4).add(term5xx)).flattenControlPointsArray();\n                hessian_gyy[i][j] = (term1.add(term2yy).add(term4).add(term5yy)).flattenControlPointsArray();\n            }\n        }\n        for (var i = 1; i < n; i += 1) {\n            for (var j = 0; j < i; j += 1) {\n                // term1 = 0\n                var term2xy = ((h5x[j].multiply(h6y[i].add(h7y[i]))).add(h5y[i].multiply((h6x[j].add(h7x[j]))))).multiplyByScalar(2);\n                var term3 = this.Dh6_7xy[j][i].multiply(h1).multiplyByScalar(-1); //Dh_6_7xy is antisymmetric\n                // term4 = 0\n                var term5xy = (((h8x[j].add(h9x[j])).multiply((h10y[i].add(h11y[i])))).add((h8y[i].add(h9y[i])).multiply((h10x[j].add(h11x[j]))))).multiplyByScalar(-3);\n                var term6 = this.Dh10_11xy[j][i].multiply(h3).multiplyByScalar(3); //Dh_10_11xy is antisymmetric\n                hessian_gxy[i][j] = (term2xy.add(term3).add(term5xy).add(term6)).flattenControlPointsArray();\n            }\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = i + 1; j < n; j += 1) {\n                // term1 = 0\n                var term2xy = ((h5x[j].multiply((h6y[i].add(h7y[i])))).add(h5y[i].multiply((h6x[j].add(h7x[j]))))).multiplyByScalar(2);\n                var term3 = this.Dh6_7xy[i][j].multiply(h1); //Dh_6_7xy is antisymmetric\n                // term4 = 0\n                var term5xy = (((h8x[j].add(h9x[j])).multiply((h10y[i].add(h11y[i])))).add((h8y[i].add(h9y[i])).multiply((h10x[j].add(h11x[j]))))).multiplyByScalar(-3);\n                var term6 = this.Dh10_11xy[i][j].multiply(h3).multiplyByScalar(-3); //Dh_10_11xy is antisymmetric\n                hessian_gxy[i][j] = (term2xy.add(term3).add(term5xy).add(term6)).flattenControlPointsArray();\n            }\n        }\n        for (var i = 0; i < n; i += 1) {\n            // term1 = 0\n            var term2xy = ((h5x[i].multiply(h6y[i].add(h7y[i]))).add(h5y[i].multiply((h6x[i].add(h7x[i]))))).multiplyByScalar(2);\n            //const term3 = this.Dh6_7xy[i][i].multiply(h1)\n            // term3 = 0\n            // term4 = 0\n            var term5xy = (((h8y[i].add(h9y[i])).multiply((h10x[i].add(h11x[i])))).add((h8x[i].add(h9x[i])).multiply(h10y[i].add(h11y[i])))).multiplyByScalar(-3);\n            // term6 = 0\n            hessian_gxy[i][i] = (term2xy.add(term5xy)).flattenControlPointsArray();\n        }\n        var deltak = 0;\n        for (var k = 0; k < constraintsSign.length; k += 1) {\n            if (k === inactiveConstraints[deltak]) {\n                deltak += 1;\n            }\n            else {\n                var m = new SymmetricMatrix_1.SymmetricMatrix(2 * n);\n                for (var i = 0; i < n; i += 1) {\n                    for (var j = 0; j <= i; j += 1) {\n                        m.set(i, j, hessian_gxx[i][j][k] * constraintsSign[k]);\n                        m.set(n + i, n + j, hessian_gyy[i][j][k] * constraintsSign[k]);\n                    }\n                }\n                for (var i = 0; i < n; i += 1) {\n                    for (var j = 0; j < n; j += 1) {\n                        m.set(n + i, j, hessian_gxy[i][j][k] * constraintsSign[k]);\n                    }\n                }\n                result.push(m);\n            }\n        }\n        return result;\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.prepareForHessianComputation = function (Dsu, Dsuu, Dsuuu) {\n        var n = this.spline.controlPoints.length;\n        for (var i = 0; i < n; i += 1) {\n            this.Dh5xx.push([]);\n            this.Dh6_7xy.push([]);\n            this.Dh8_9xx.push([]);\n            this.Dh10_11xy.push([]);\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j <= i; j += 1) {\n                this.Dh5xx[i][j] = Dsu[i].multiply(Dsu[j]);\n            }\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j < n; j += 1) {\n                this.Dh6_7xy[i][j] = (Dsu[i].multiply(Dsuuu[j])).subtract(Dsu[j].multiply(Dsuuu[i]));\n            }\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j <= i; j += 1) {\n                this.Dh8_9xx[i][j] = (Dsu[i].multiply(Dsuu[j])).add(Dsu[j].multiply(Dsuu[i]));\n            }\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j < n; j += 1) {\n                this.Dh10_11xy[i][j] = (Dsu[i].multiply(Dsuu[j])).subtract(Dsu[j].multiply(Dsuu[i]));\n            }\n        }\n    };\n    /**\n     * The vector of constraint functions values: f(x + step)\n     */\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.fStep = function (step) {\n        var splineTemp = this.spline.clone();\n        splineTemp.optimizerStep(step);\n        var e = this.expensiveComputation(splineTemp);\n        var g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        var curvatureNumerator = this.curvatureNumerator(e.h4);\n        return this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this.inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this.curvatureExtremaInactiveConstraints);\n    };\n    /**\n     * The objective function value: f0(x + step)\n     */\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.f0Step = function (step) {\n        var splineTemp = this.spline.clone();\n        splineTemp.optimizerStep(step);\n        return this.compute_f0(this.compute_gradient_f0(splineTemp));\n    };\n    OptimizationProblem_BSpline_R1_to_R2_inflection.prototype.setTargetSpline = function (spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this.gradient_f0);\n    };\n    return OptimizationProblem_BSpline_R1_to_R2_inflection;\n}());\nexports.OptimizationProblem_BSpline_R1_to_R2_inflection = OptimizationProblem_BSpline_R1_to_R2_inflection;\n/*\nexport class OptimizationProblem_BSpline_R1_to_R2_free_of_constraints extends OptimizationProblem_BSpline_R1_to_R2 {\n\n    get numberOfConstraints() {\n        return 1\n    }\n\n    get f() {\n        return [-1]\n    }\n\n    get gradient_f() {\n        return new DenseMatrix(1, this.numberOfIndependentVariables)\n    }\n\n    get hessian_f() {\n        return undefined\n    }\n\n    fStep(step: number[]) {\n        return [-1]\n    }\n\n    step(deltaX: number[]) {\n        this.spline.optimizerStep(deltaX)\n        this._gradient_f0 = this.compute_gradient_f0(this.spline)\n        this._f0 = this.compute_f0(this.gradient_f0)\n    }\n    \n}\n*/\nvar OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection = /** @class */ (function (_super) {\n    __extends(OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection, _super);\n    function OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection(target, initial, activeControl) {\n        if (activeControl === void 0) { activeControl = ActiveControl.both; }\n        var _this = _super.call(this, target, initial, activeControl) || this;\n        _this.activeControl = activeControl;\n        _this.weigthingFactors = [];\n        for (var i = 0; i < _this.spline.controlPoints.length * 2; i += 1) {\n            _this.weigthingFactors.push(1);\n        }\n        return _this;\n    }\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection.prototype, \"f0\", {\n        get: function () {\n            var result = 0;\n            var n = this._gradient_f0.length;\n            for (var i = 0; i < n; i += 1) {\n                result += Math.pow(this._gradient_f0[i], 2) * this.weigthingFactors[i];\n            }\n            return 0.5 * result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection.prototype, \"gradient_f0\", {\n        get: function () {\n            var result = [];\n            var n = this._gradient_f0.length;\n            for (var i = 0; i < n; i += 1) {\n                result.push(this._gradient_f0[i] * this.weigthingFactors[i]);\n            }\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection.prototype, \"hessian_f0\", {\n        get: function () {\n            var n = this._gradient_f0.length;\n            var result = new DiagonalMatrix_1.DiagonalMatrix(n);\n            for (var i = 0; i < n; i += 1) {\n                result.set(i, i, this.weigthingFactors[i]);\n            }\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * The objective function value: f0(x + step)\n     */\n    OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection.prototype.f0Step = function (step) {\n        var splineTemp = this.spline.clone();\n        splineTemp.optimizerStep(step);\n        var gradient = this.compute_gradient_f0(splineTemp);\n        var n = gradient.length;\n        var result = 0;\n        for (var i = 0; i < n; i += 1) {\n            result += Math.pow(gradient[i], 2) * this.weigthingFactors[i];\n        }\n        return 0.5 * result;\n    };\n    return OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection;\n}(OptimizationProblem_BSpline_R1_to_R2_inflection));\nexports.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection = OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection;\nvar OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection = /** @class */ (function (_super) {\n    __extends(OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection, _super);\n    function OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection(target, initial, activeControl) {\n        if (activeControl === void 0) { activeControl = ActiveControl.both; }\n        var _this = _super.call(this, target, initial, activeControl) || this;\n        _this.activeControl = activeControl;\n        return _this;\n    }\n    OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection.prototype.computeInactiveConstraints = function (constraintsSign, curvatureDerivativeNumerator) {\n        return [];\n    };\n    return OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection;\n}(OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_inflection));\nexports.OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection = OptimizationProblem_BSpline_R1_to_R2_with_weigthingFactors_no_inactive_constraints_inflection;\nvar OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection = /** @class */ (function (_super) {\n    __extends(OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection, _super);\n    function OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection(target, initial) {\n        return _super.call(this, target, initial) || this;\n    }\n    OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection.prototype.computeInactiveConstraints = function (constraintsSign, curvatureDerivativeNumerator) {\n        return [];\n    };\n    return OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection;\n}(OptimizationProblem_BSpline_R1_to_R2_inflection));\nexports.OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection = OptimizationProblem_BSpline_R1_to_R2_no_inactive_constraints_inflection;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Optimizer = void 0;\nvar TrustRegionSubproblem_1 = require(\"./TrustRegionSubproblem\");\nvar MathVectorBasicOperations_1 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_2 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_3 = require(\"./MathVectorBasicOperations\");\nvar SymmetricMatrix_1 = require(\"./SymmetricMatrix\");\nvar CholeskyDecomposition_1 = require(\"./CholeskyDecomposition\");\nvar Optimizer = /** @class */ (function () {\n    function Optimizer(o) {\n        this.o = o;\n        this.success = false;\n        if (this.o.f.length !== this.o.gradient_f.shape[0]) {\n            console.log(\"Problem about f length and gradient_f shape 0 is in the Optimizer Constructor\");\n        }\n    }\n    Optimizer.prototype.optimize_using_trust_region = function (epsilon, maxTrustRadius, maxNumSteps) {\n        if (epsilon === void 0) { epsilon = 10e-8; }\n        if (maxTrustRadius === void 0) { maxTrustRadius = 10; }\n        if (maxNumSteps === void 0) { maxNumSteps = 800; }\n        this.success = false;\n        // Bibliographic reference: Numerical Optimization, second edition, Jorge Nocedal and Stephen J. Wright, p. 69\n        var numSteps = 0;\n        //let numGradientComputation = 0\n        var t = this.o.numberOfConstraints / this.o.f0;\n        var trustRadius = 9;\n        var rho;\n        var eta = 0.1; // [0, 1/4)\n        var mu = 10; // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 569\n        while (this.o.numberOfConstraints / t > epsilon) {\n            while (true) {\n                numSteps += 1;\n                //console.log(\"number of steps\")\n                //console.log(numSteps) \n                if (this.o.f.length !== this.o.gradient_f.shape[0]) {\n                    console.log(\"Problem about f length and gradient_f shape 0 is in the function optimize_using_trust_region\");\n                }\n                var b = this.barrier(this.o.f, this.o.gradient_f, this.o.hessian_f);\n                var gradient = MathVectorBasicOperations_2.saxpy2(t, this.o.gradient_f0, b.gradient);\n                var hessian = b.hessian.plusSymmetricMatrixMultipliedByValue(this.o.hessian_f0, t);\n                var trustRegionSubproblem = new TrustRegionSubproblem_1.TrustRegionSubproblem(gradient, hessian);\n                var tr = trustRegionSubproblem.solve(trustRadius);\n                var fStep = this.o.fStep(tr.step);\n                var numSteps2 = 0;\n                while (Math.max.apply(null, fStep) >= 0) {\n                    numSteps2 += 1;\n                    trustRadius *= 0.25;\n                    tr = trustRegionSubproblem.solve(trustRadius);\n                    //numGradientComputation += 1;\n                    fStep = this.o.fStep(tr.step);\n                    if (numSteps2 > 100) {\n                        throw new Error(\"maxSteps2 > 100\");\n                    }\n                }\n                var barrierValueStep = this.barrierValue(fStep);\n                var actualReduction = t * (this.o.f0 - this.o.f0Step(tr.step)) + (b.value - barrierValueStep);\n                var predictedReduction = -MathVectorBasicOperations_1.dotProduct(gradient, tr.step) - 0.5 * hessian.quadraticForm(tr.step);\n                rho = actualReduction / predictedReduction;\n                if (rho < 0.25) {\n                    trustRadius *= 0.25;\n                }\n                else if (rho > 0.75 && tr.hitsBoundary) {\n                    trustRadius = Math.min(2 * trustRadius, maxTrustRadius);\n                }\n                if (rho > eta) {\n                    //numGradientComputation += 1;\n                    //console.log(\"number of gradient computation\")\n                    //console.log(numGradientComputation) \n                    //numGradientComputation = 0\n                    this.o.step(tr.step);\n                }\n                if (numSteps > maxNumSteps) {\n                    //throw new Error(\"numSteps > maxNumSteps\")\n                    //break;\n                    return;\n                }\n                var newtonDecrementSquared = this.newtonDecrementSquared(tr.step, t, this.o.gradient_f0, b.gradient);\n                if (newtonDecrementSquared < 0) {\n                    throw new Error(\"newtonDecrementSquared is smaller than zero\");\n                }\n                //if (newtonDecrementSquared < epsilon && !tr.hitsBoundary) {\n                if (newtonDecrementSquared < epsilon) {\n                    //console.log('break newtonDecrementSquared < epsilon && !hitsBoundary');\n                    break;\n                }\n                if (trustRadius < 10e-18) {\n                    //console.log('trustRadius < 10e-10');\n                    console.log(b);\n                    throw new Error(\"trust Radius < 10e-18\");\n                    //break;\n                }\n            }\n            t *= mu;\n        }\n        //if (numSteps === maxNumSteps) {\n        //    return -1;\n        //}\n        //console.log(numSteps)\n        this.success = true;\n    };\n    Optimizer.prototype.optimize_using_line_search = function (epsilon, maxNumSteps) {\n        if (epsilon === void 0) { epsilon = 10e-6; }\n        if (maxNumSteps === void 0) { maxNumSteps = 300; }\n        // Bibliographic reference: Numerical Optimization, second edition, Jorge Nocedal and Stephen J. Wright, p. 69\n        var numSteps = 0;\n        var t = this.o.numberOfConstraints / this.o.f0;\n        var rho;\n        var eta = 0.1; // [0, 1/4)\n        var mu = 10; // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 569\n        while (this.o.numberOfConstraints / t > epsilon) {\n            while (true) {\n                numSteps += 1;\n                //console.log(numSteps) \n                var b = this.barrier(this.o.f, this.o.gradient_f, this.o.hessian_f);\n                var gradient = MathVectorBasicOperations_2.saxpy2(t, this.o.gradient_f0, b.gradient);\n                var hessian = b.hessian.plusSymmetricMatrixMultipliedByValue(this.o.hessian_f0, t);\n                var newtonStep = this.computeNewtonStep(gradient, hessian);\n                var stepRatio = this.backtrackingLineSearch(t, newtonStep, this.o.f0, b.value, this.o.gradient_f0, b.gradient);\n                if (stepRatio < 1) {\n                    //console.log(stepRatio)\n                }\n                var step = MathVectorBasicOperations_1.multiplyVectorByScalar(newtonStep, stepRatio);\n                /*\n                if (Math.max(...this.o.fStep(step)) > 0) {\n                    console.log(Math.max(...this.o.fStep(step)))\n                }\n                */\n                //console.log(Math.max(...this.o.fStep(step)))\n                /*\n                if (Math.max(...this.o.fStep(step)) < 0) {\n                    this.o.step(step)\n                }\n                */\n                this.o.step(step);\n                if (numSteps > maxNumSteps) {\n                    //throw new Error(\"numSteps > maxNumSteps\")\n                    //break;\n                    console.log(\"numSteps > maxNumSteps\");\n                    return;\n                }\n                var newtonDecrementSquared = this.newtonDecrementSquared(step, t, this.o.gradient_f0, b.gradient);\n                if (newtonDecrementSquared < 0) {\n                    throw new Error(\"newtonDecrementSquared is smaller than zero\");\n                }\n                //if (newtonDecrementSquared < epsilon && !tr.hitsBoundary) {\n                if (newtonDecrementSquared < epsilon) {\n                    //console.log('break newtonDecrementSquared < epsilon && !hitsBoundary');\n                    //console.log(numSteps)\n                    break;\n                }\n            }\n            t *= mu;\n            //console.log(t)\n        }\n        //if (numSteps === maxNumSteps) {\n        //    return -1;\n        //}\n        //console.log(numSteps)\n    };\n    Optimizer.prototype.newtonDecrementSquared = function (newtonStep, t, gradient_f0, barrierGradient) {\n        return -MathVectorBasicOperations_1.dotProduct(MathVectorBasicOperations_2.saxpy2(t, gradient_f0, barrierGradient), newtonStep);\n    };\n    Optimizer.prototype.barrierValue = function (f) {\n        //console.log(f)\n        var result = 0;\n        var n = f.length;\n        for (var i = 0; i < n; i += 1) {\n            result -= Math.log(-f[i]);\n        }\n        return result;\n    };\n    Optimizer.prototype.barrierGradient = function (f, gradient_f) {\n        var result = MathVectorBasicOperations_3.zeroVector(gradient_f.shape[1]);\n        var n = f.length;\n        var m = gradient_f.shape[1];\n        if (n !== gradient_f.shape[0]) {\n            throw new Error(\"barrierGradient f and gradient_f dimensions do not match\");\n        }\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j < m; j += 1) {\n                if (f[i] === 0) {\n                    throw new Error(\"barrierGradient makes a division by zero\");\n                }\n                result[j] += -gradient_f.get(i, j) / f[i];\n                //console.log(result[j])\n            }\n        }\n        //console.log(gradient_f)\n        //console.log(result)\n        return result;\n    };\n    Optimizer.prototype.barrierHessian = function (f, gradient_f, hessian_f) {\n        // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 564\n        var m = gradient_f.shape[0];\n        var n = gradient_f.shape[1];\n        var result = new SymmetricMatrix_1.SymmetricMatrix(n);\n        // barrier hessian first term\n        for (var i = 0; i < m; i += 1) {\n            for (var k = 0; k < n; k += 1) {\n                for (var l = 0; l <= k; l += 1) {\n                    result.addAt(k, l, gradient_f.get(i, k) * gradient_f.get(i, l) / (f[i] * f[i]));\n                }\n            }\n        }\n        // barrier hessian second term\n        if (hessian_f) {\n            for (var i = 0; i < n; i += 1) {\n                for (var j = 0; j <= i; j += 1) {\n                    for (var k = 0; k < f.length; k += 1) {\n                        result.addAt(i, j, -hessian_f[k].get(i, j) / f[k]);\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    Optimizer.prototype.barrier = function (f, gradient_f, hessian_f) {\n        /*\n        if (f.length !== gradient_f.shape[0]) {\n            console.log(\"Problem about f length and gradient_f shape 0 is in Optimizer in the function barrier\")\n        }\n        */\n        return { value: this.barrierValue(f),\n            gradient: this.barrierGradient(f, gradient_f),\n            hessian: this.barrierHessian(f, gradient_f, hessian_f)\n        };\n    };\n    Optimizer.prototype.backtrackingLineSearch = function (t, newtonStep, f0, barrierValue, gradient_f0, barrierGradient) {\n        var alpha = 0.2;\n        var beta = 0.5;\n        var result = 1;\n        var step = newtonStep.slice();\n        while (Math.max.apply(Math, this.o.fStep(step)) > 0) {\n            result *= beta;\n            //console.log(Math.max(...this.o.fStep(step)))\n            step = MathVectorBasicOperations_1.multiplyVectorByScalar(newtonStep, result);\n        }\n        while (t * this.o.f0Step(step) + this.barrierValue(this.o.fStep(step)) > t * f0 + barrierValue\n            + alpha * result * MathVectorBasicOperations_1.dotProduct(MathVectorBasicOperations_1.addTwoVectors(MathVectorBasicOperations_1.multiplyVectorByScalar(gradient_f0, t), barrierGradient), newtonStep)) {\n            result *= beta;\n            step = MathVectorBasicOperations_1.multiplyVectorByScalar(newtonStep, result);\n        }\n        return result;\n    };\n    Optimizer.prototype.computeNewtonStep = function (gradient, hessian) {\n        var choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessian);\n        if (choleskyDecomposition.success === false) {\n            console.log(\"choleskyDecomposition failed\");\n        }\n        return choleskyDecomposition.solve(MathVectorBasicOperations_1.multiplyVectorByScalar(gradient, -1));\n    };\n    return Optimizer;\n}());\nexports.Optimizer = Optimizer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decomposeFunction = exports.basisFunctions = exports.clampingFindSpan = exports.findSpan = void 0;\n/**\n * Returns the span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i] ≤ u < knots[i+1]\n */\nfunction findSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        console.log(u);\n        console.log(knots);\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 2;\n    }\n    // Do binary search\n    var low = degree;\n    var high = knots.length - 1 - degree;\n    var i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.findSpan = findSpan;\n/**\n * Returns the span index used for clamping a periodic B-Spline\n * Note: The only difference with findSpan is the for the special case u = knots[-degree - 1]\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i] ≤ u < knots[i+1]\n */\nfunction clampingFindSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 1;\n    }\n    // Do binary search\n    var low = degree;\n    var high = knots.length - 1 - degree;\n    var i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.clampingFindSpan = clampingFindSpan;\n/**\n * Returns the basis functions values\n * @param span span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns the array of values evaluated at u\n */\nfunction basisFunctions(span, u, knots, degree) {\n    // Bibliographic reference : The NURBS BOOK, p.70\n    var result = [1];\n    var left = [];\n    var right = [];\n    for (var j = 1; j <= degree; j += 1) {\n        left[j] = u - knots[span + 1 - j];\n        right[j] = knots[span + j] - u;\n        var saved = 0.0;\n        for (var r = 0; r < j; r += 1) {\n            var temp = result[r] / (right[r + 1] + left[j - r]);\n            result[r] = saved + right[r + 1] * temp;\n            saved = left[j - r] * temp;\n        }\n        result[j] = saved;\n    }\n    return result;\n}\nexports.basisFunctions = basisFunctions;\nfunction decomposeFunction(spline) {\n    //Piegl and Tiller, The NURBS book, p.173\n    var result = [];\n    var number_of_bezier_segments = spline.distinctKnots().length - 1;\n    for (var i = 0; i < number_of_bezier_segments; i += 1) {\n        result.push([]);\n    }\n    for (var i = 0; i <= spline.degree; i += 1) {\n        result[0][i] = spline.controlPoints[i];\n    }\n    var a = spline.degree;\n    var b = spline.degree + 1;\n    var bezier_segment = 0;\n    var alphas = [];\n    while (b < spline.knots.length - 1) {\n        var i = b;\n        while (b < spline.knots.length - 1 && spline.knots[b + 1] === spline.knots[b]) {\n            b += 1;\n        }\n        var mult = b - i + 1;\n        if (mult < spline.degree) {\n            var numer = spline.knots[b] - spline.knots[a]; // Numerator of alpha\n            // Compute and store alphas\n            for (var j = spline.degree; j > mult; j -= 1) {\n                alphas[j - mult - 1] = numer / (spline.knots[a + j] - spline.knots[a]);\n            }\n            var r = spline.degree - mult; // insert knot r times\n            for (var j = 1; j <= r; j += 1) {\n                var save = r - j;\n                var s = mult + j; // this many new controlPoints\n                for (var k = spline.degree; k >= s; k -= 1) {\n                    var alpha = alphas[k - s];\n                    result[bezier_segment][k] = (result[bezier_segment][k] * alpha) + (result[bezier_segment][k - 1] * (1 - alpha));\n                }\n                if (b < spline.knots.length) {\n                    result[bezier_segment + 1][save] = result[bezier_segment][spline.degree]; // next segment\n                }\n            }\n        }\n        bezier_segment += 1; // Bezier segment completed\n        if (b < spline.knots.length - 1) {\n            //initialize next bezier bezier_segment\n            for (i = Math.max(0, spline.degree - mult); i <= spline.degree; i += 1) {\n                result[bezier_segment][i] = spline.controlPoints[b - spline.degree + i];\n            }\n            a = b;\n            b += 1;\n        }\n    }\n    return result;\n}\nexports.decomposeFunction = decomposeFunction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SquareMatrix = void 0;\n/**\n * A square matrix\n */\nvar SquareMatrix = /** @class */ (function () {\n    /**\n     * Create a square matrix\n     * @param size Number of row and column\n     * @param data A row after row flat array\n     * @throws If data length is not equal to size*size\n     */\n    function SquareMatrix(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size * size) {\n                throw new Error(\"Square matrix constructor expect the data to have size*size length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            for (var i = 0; i < this.shape[0] * this.shape[1]; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    Object.defineProperty(SquareMatrix.prototype, \"shape\", {\n        /**\n         * Returns the shape of the matrix : [number of rows, number of columns]\n         */\n        get: function () {\n            return this._shape;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Return the corresponding index in the flat row by row data vector\n     * @param row The row index\n     * @param column The column index\n     */\n    SquareMatrix.prototype.dataIndex = function (row, column) {\n        var n = row * this._shape[1] + column;\n        return n;\n    };\n    /**\n     * Return the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    SquareMatrix.prototype.get = function (row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    };\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    SquareMatrix.prototype.set = function (row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    };\n    /**\n     * Change the value of the matrix at a given row and column position by this value divided by the divisor value\n     * @param row The row index\n     * @param column The column index\n     * @param divisor The divisor value\n     * @throws If an index is out of range\n     */\n    SquareMatrix.prototype.divideAt = function (row, column, divisor) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] /= divisor;\n    };\n    /**\n     * Change the value of the matrix at a given row and column position by this value substracted by the subtrahend value\n     * @param row The row index\n     * @param column The column index\n     * @param divisor The divisor value\n     * @throws If an index is out of range\n     */\n    SquareMatrix.prototype.substractAt = function (row, column, subtrahend) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] -= subtrahend;\n    };\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    SquareMatrix.prototype.checkRowRange = function (index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    };\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    SquareMatrix.prototype.checkColumnRange = function (index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    };\n    /**\n     * Multiply two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    SquareMatrix.prototype.multiplyByMatrix = function (that) {\n        if (this.shape[1] !== that.shape[0]) {\n            throw new Error(\"Size mismatch in matrix multiplication\");\n        }\n        var result = new SquareMatrix(this.shape[1]);\n        for (var i = 0; i < this.shape[0]; i += 1) {\n            for (var j = 0; j < this.shape[0]; j += 1) {\n                var temp = 0;\n                for (var k = 0; k < this.shape[0]; k += 1) {\n                    temp += this.get(i, k) * that.get(k, j);\n                }\n                result.set(i, j, temp);\n            }\n        }\n        return result;\n    };\n    return SquareMatrix;\n}());\nexports.SquareMatrix = SquareMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SymmetricMatrix = void 0;\nvar SquareMatrix_1 = require(\"./SquareMatrix\");\nvar DiagonalMatrix_1 = require(\"./DiagonalMatrix\");\nvar MathVectorBasicOperations_1 = require(\"./MathVectorBasicOperations\");\n/**\n * A symmetric matrix\n */\nvar SymmetricMatrix = /** @class */ (function () {\n    /**\n     * Create a Symmetric Matrix\n     * @param size The number of rows or the number columns\n     * @param data The matrix data in a flat vector\n     */\n    function SymmetricMatrix(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size * (size + 1) / 2) {\n                throw new Error(\"Square matrix constructor expect the data to have (size * (size + 1) / 2) length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            var n = (size * (size + 1)) / 2;\n            for (var i = 0; i < n; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    Object.defineProperty(SymmetricMatrix.prototype, \"shape\", {\n        /**\n        * Returns the shape of the matrix : [number of rows, number of columns]\n        */\n        get: function () {\n            return this._shape;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the corresponding index in the flat data vector.\n     * In this flat data vector the upper triangular matrix is store row-wise.\n     * @param row The row index\n     * @param column The column index\n     */\n    SymmetricMatrix.prototype.dataIndex = function (row, column) {\n        if (row <= column) {\n            return row * this.shape[1] - (row - 1) * row / 2 + column - row;\n        }\n        return column * this.shape[0] - (column - 1) * column / 2 + row - column;\n    };\n    /**\n     * Returns the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    SymmetricMatrix.prototype.get = function (row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    };\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    SymmetricMatrix.prototype.set = function (row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    };\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    SymmetricMatrix.prototype.checkRowRange = function (index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    };\n    /**\n * Check that the index is inside appropriate range\n * @param index The column or the row index\n * @throws If an index is out of range\n */\n    SymmetricMatrix.prototype.checkColumnRange = function (index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    };\n    /**\n     * Compute the product v^t M v\n     * @param v Vector\n     * @return Scalar\n     */\n    SymmetricMatrix.prototype.quadraticForm = function (v) {\n        var result = 0;\n        for (var i = 1; i < this.shape[1]; i += 1) {\n            for (var j = 0; j < i; j += 1) {\n                result += this.get(i, j) * v[i] * v[j];\n            }\n        }\n        result *= 2;\n        for (var i = 0; i < this.shape[1]; i += 1) {\n            result += this.get(i, i) * Math.pow(v[i], 2);\n        }\n        return result;\n    };\n    /**\n     * Return a safe copy of this matrix\n     * */\n    SymmetricMatrix.prototype.clone = function () {\n        return new SymmetricMatrix(this.shape[0], this.data);\n    };\n    /**\n     * Increases the given element of the matrix by the value\n     * @param row The row index\n     * @param column The column index\n     * @param value The number to be added\n     * @throws If an index is out of range\n     */\n    SymmetricMatrix.prototype.addAt = function (row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(row);\n        this.data[this.dataIndex(row, column)] += value;\n    };\n    /**\n     * Increases every diagonal element of the matrix by the value\n     * @param value The number to be added\n     */\n    SymmetricMatrix.prototype.addValueOnDiagonalInPlace = function (value) {\n        var m = this.shape[0];\n        for (var i = 0; i < m; i += 1) {\n            this.data[this.dataIndex(i, i)] += value;\n        }\n    };\n    /**\n     * Returns the new matrix: this.matrix + value * I\n     * @param value\n     * @returns SymmetricMatrix\n     */\n    SymmetricMatrix.prototype.addValueOnDiagonal = function (value) {\n        var result = this.clone();\n        result.addValueOnDiagonalInPlace(value);\n        return result;\n    };\n    /**\n     * Returns a SquareMatrix with the values of this matrix\n     */\n    SymmetricMatrix.prototype.squareMatrix = function () {\n        var n = this.shape[0];\n        var result = new SquareMatrix_1.SquareMatrix(n);\n        for (var i = 0; i < n; i += 1) {\n            for (var j = 0; j < n; j += 1) {\n                result.set(i, j, this.get(i, j));\n            }\n        }\n        return result;\n    };\n    SymmetricMatrix.prototype.plusSymmetricMatrixMultipliedByValue = function (matrix, value) {\n        if (this.shape[0] !== matrix.shape[0]) {\n            throw new Error(\"Adding two symmetric matrix with different shapes\");\n        }\n        var result = this.clone();\n        var n = result.shape[0];\n        if (matrix instanceof DiagonalMatrix_1.DiagonalMatrix) {\n            for (var i = 0; i < n; i += 1) {\n                result.addAt(i, i, matrix.get(i, i) * value);\n            }\n            return result;\n        }\n        else {\n            for (var i = 0; i < n; i += 1) {\n                for (var j = 0; j <= i; j += 1) {\n                    result.addAt(i, j, matrix.get(i, j) * value);\n                }\n            }\n            return result;\n        }\n    };\n    SymmetricMatrix.prototype.multiplyByVector = function (v) {\n        if (this.shape[1] !== v.length) {\n            throw new Error(\"SymmetricMatrix multiply a vector of incorrect length\");\n        }\n        var result = [];\n        var n = this.shape[1];\n        for (var i = 0; i < n; i += 1) {\n            var temp = 0;\n            for (var j = 0; j < n; j += 1) {\n                temp += this.get(i, j) * v[j];\n            }\n            result.push(temp);\n        }\n        return result;\n    };\n    SymmetricMatrix.prototype.containsNaN = function () {\n        return MathVectorBasicOperations_1.containsNaN(this.data);\n    };\n    return SymmetricMatrix;\n}());\nexports.SymmetricMatrix = SymmetricMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBoundariesIntersections = exports.gershgorin_bounds = exports.frobeniusNorm = exports.TrustRegionSubproblem = void 0;\nvar SquareMatrix_1 = require(\"./SquareMatrix\");\nvar MathVectorBasicOperations_1 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_2 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_3 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_4 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_5 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_6 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_7 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_8 = require(\"./MathVectorBasicOperations\");\nvar MathVectorBasicOperations_9 = require(\"./MathVectorBasicOperations\");\nvar CholeskyDecomposition_1 = require(\"./CholeskyDecomposition\");\n// Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 187\n// note: lambda is never negative\nvar lambdaRange;\n(function (lambdaRange) {\n    lambdaRange[lambdaRange[\"N\"] = 0] = \"N\";\n    lambdaRange[lambdaRange[\"L\"] = 1] = \"L\";\n    lambdaRange[lambdaRange[\"G\"] = 2] = \"G\";\n    lambdaRange[lambdaRange[\"F\"] = 3] = \"F\";\n})(lambdaRange || (lambdaRange = {}));\n/**\n * A trust region subproblem solver\n */\nvar TrustRegionSubproblem = /** @class */ (function () {\n    /**\n     * Create the trust region subproblem solver\n     * @param gradient The gradient of the objective function to minimize\n     * @param hessian The hessian of the objective function to minimize\n     * @param k_easy Optional value in the range (0, 1)\n     * @param k_hard Optional value in the range (0, 1)\n     */\n    function TrustRegionSubproblem(gradient, hessian, k_easy, k_hard) {\n        if (k_easy === void 0) { k_easy = 0.1; }\n        if (k_hard === void 0) { k_hard = 0.2; }\n        this.gradient = gradient;\n        this.hessian = hessian;\n        this.k_easy = k_easy;\n        this.k_hard = k_hard;\n        this.CLOSE_TO_ZERO = 10e-8;\n        this.numberOfIterations = 0;\n        this.lambda = { current: 0, lowerBound: 0, upperBound: 0 };\n        this.hitsBoundary = true;\n        this.step = [];\n        this.stepSquaredNorm = 0;\n        this.stepNorm = 0;\n        this.range = lambdaRange.F;\n        this.lambdaPlus = 0;\n        this.hardCase = false;\n        this.gNorm = MathVectorBasicOperations_1.norm(this.gradient);\n        if (MathVectorBasicOperations_1.containsNaN(gradient)) {\n            throw new Error(\"The gradient parameter passed to the TrustRegionSubproblem constructor contains NaN\");\n        }\n        if (hessian.containsNaN()) {\n            throw new Error(\"The hessian parameter passed to the TrustRegionSubproblem to constructor contains NaN\");\n        }\n        this.cauchyPoint = MathVectorBasicOperations_8.zeroVector(this.gradient.length);\n    }\n    /**\n     * Find the nearly exact trust region subproblem minimizer\n     * @param trustRegionRadius The trust region radius\n     * @returns The vector .step and the boolean .hitsBoundary\n     */\n    TrustRegionSubproblem.prototype.solve = function (trustRegionRadius) {\n        // Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 193\n        // see also the list of errata: ftp://ftp.numerical.rl.ac.uk/pub/trbook/trbook-errata.pdf for Algorithm 7.3.4 Step 1a\n        this.cauchyPoint = this.computeCauchyPoint(trustRegionRadius);\n        this.lambda = this.initialLambdas(trustRegionRadius);\n        this.numberOfIterations = 0;\n        var maxNumberOfIterations = 300;\n        while (true) {\n            this.numberOfIterations += 1;\n            // step 1.\n            var hessianPlusLambda = this.hessian.addValueOnDiagonal(this.lambda.current);\n            var choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n            //We have found the exact lambda, however the hessian is indefinite\n            //The idea is then to find an approximate solution increasing the lambda value by EPSILON\n            if (this.lambda.upperBound === this.lambda.lowerBound && !choleskyDecomposition.success) {\n                var EPSILON = 10e-6;\n                this.lambda.upperBound += EPSILON;\n                this.lambda.current += EPSILON;\n                hessianPlusLambda = this.hessian.addValueOnDiagonal(this.lambda.current);\n                choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n                this.range = lambdaRange.G;\n            }\n            // step 1a.\n            this.update_step_and_range(trustRegionRadius, choleskyDecomposition);\n            if (this.interiorConvergence()) {\n                break;\n            }\n            // step 2.\n            this.update_lower_and_upper_bounds();\n            // step 3.\n            this.update_lambda_lambdaPlus_lowerBound_and_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition);\n            // step 4.\n            if (this.check_for_termination_and_update_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition)) {\n                break;\n            }\n            // step 5.\n            this.update_lambda();\n            if (this.numberOfIterations > maxNumberOfIterations) {\n                throw new Error(\"Trust region subproblem maximum number of step exceeded\");\n            }\n        }\n        //console.log(this.numberOfIterations)\n        return {\n            step: this.step,\n            hitsBoundary: this.hitsBoundary,\n            hardCase: this.hardCase\n        };\n    };\n    /**\n     * An interior solution with a zero Lagrangian multiplier implies interior convergence\n     */\n    TrustRegionSubproblem.prototype.interiorConvergence = function () {\n        // A range G corresponds to a step smaller than the trust region radius\n        if (this.lambda.current === 0 && this.range === lambdaRange.G) {\n            this.hitsBoundary = false;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Updates the lambdaRange set. Updates the step if the factorization succeeded.\n     * @param trustRegionRadius Trust region radius\n     * @param choleskyDecomposition Cholesky decomposition\n     */\n    TrustRegionSubproblem.prototype.update_step_and_range = function (trustRegionRadius, choleskyDecomposition) {\n        if (choleskyDecomposition.success) {\n            this.step = choleskyDecomposition.solve(MathVectorBasicOperations_4.multiplyVectorByScalar(this.gradient, -1));\n            this.stepSquaredNorm = MathVectorBasicOperations_3.squaredNorm(this.step);\n            this.stepNorm = Math.sqrt(this.stepSquaredNorm);\n            if (this.stepNorm < trustRegionRadius) {\n                this.range = lambdaRange.G;\n            }\n            else {\n                this.range = lambdaRange.L; // once a Newton iterate falls into L it stays there\n            }\n        }\n        else {\n            this.range = lambdaRange.N;\n        }\n    };\n    /**\n     * Update lambda.upperBound or lambda.lowerBound\n     */\n    TrustRegionSubproblem.prototype.update_lower_and_upper_bounds = function () {\n        if (this.range === lambdaRange.G) {\n            this.lambda.upperBound = this.lambda.current;\n        }\n        else {\n            this.lambda.lowerBound = this.lambda.current;\n        }\n    };\n    /**\n     * Update lambdaPlus, lambda.lowerBound, lambda.current and step\n     * @param trustRegionRadius Trust region radius\n     * @param hessianPlusLambda Hessian + lambda.current * I\n     * @param choleskyDecomposition The Cholesky Decomposition of Hessian + lambda.current * I\n     */\n    TrustRegionSubproblem.prototype.update_lambda_lambdaPlus_lowerBound_and_step = function (trustRegionRadius, hessianPlusLambda, choleskyDecomposition) {\n        // Step 3. If lambda in F\n        if (this.range === lambdaRange.L || this.range === lambdaRange.G) {\n            // Step 3a. Solve Lw = step and set lambdaPlus (algorithm 7.3.1)\n            var w = solveLowerTriangular(choleskyDecomposition.g, this.step);\n            var wSquaredNorm = MathVectorBasicOperations_3.squaredNorm(w);\n            this.lambdaPlus = this.lambda.current + (this.stepNorm / trustRegionRadius - 1) * (this.stepSquaredNorm / wSquaredNorm);\n            // Step 3b. If lambda in G\n            if (this.range === lambdaRange.G) {\n                // i. Use the LINPACK method to find a unit vector u to make <u, H(lambda), u> small.\n                var s_min = estimateSmallestSingularValue(choleskyDecomposition.g);\n                // ii. Replace lambda.lowerBound by max [lambda_lb, lambda - <u, H(lambda), u>].\n                this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambda.current - Math.pow(s_min.value, 2));\n                // iii. Find the root alpha of the equation || step + alpha u || = trustRegionRadius which makes\n                // the model q(step + alpha u) smallest and replace step by step + alpha u\n                var intersection = getBoundariesIntersections(this.step, s_min.vector, trustRegionRadius);\n                var t = void 0;\n                if (Math.abs(intersection.tmin) < Math.abs(intersection.tmax)) {\n                    t = intersection.tmin;\n                }\n                else {\n                    t = intersection.tmax;\n                }\n                MathVectorBasicOperations_7.saxpy(t, s_min.vector, this.step);\n                this.stepSquaredNorm = MathVectorBasicOperations_3.squaredNorm(this.step);\n                this.stepNorm = Math.sqrt(this.stepSquaredNorm);\n            }\n        }\n        else {\n            // Step 3c. Use the partial factorization to find delta and v such that (H(lambda) + delta e_k e_k^T) v = 0\n            var sls = singularLeadingSubmatrix(hessianPlusLambda, choleskyDecomposition.g, choleskyDecomposition.firstNonPositiveDefiniteLeadingSubmatrixSize);\n            // Step 3d. Replace lambda.lb by max [ lambda_lb, lambda_current + delta / || v ||^2 ]\n            var vSquaredNorm = MathVectorBasicOperations_3.squaredNorm(sls.vector);\n            this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambda.current + sls.delta / vSquaredNorm);\n            //lambda.current = Math.max(Math.sqrt(lambda.lb * lambda.ub), lambda.lb + this.UPDATE_COEFF * (lambda.ub - lambda.lb));\n        }\n    };\n    /**\n     * Check for termination\n     * @param trustRegionRadius Trust region radius\n     * @param hessianPlusLambda Hessian + lambda.current * I\n     * @param choleskyDecomposition The CholeskyDecomposition of Hessian + lambda.current * I\n     */\n    TrustRegionSubproblem.prototype.check_for_termination_and_update_step = function (trustRegionRadius, hessianPlusLambda, choleskyDecomposition) {\n        var terminate = false;\n        // Algorithm 7.3.5, Step 1. If lambda is in F and | ||s(lambda)|| - trustRegionRadius | <= k_easy * trustRegionRadius\n        if ((this.range === lambdaRange.L || this.range === lambdaRange.G) && Math.abs(this.stepNorm - trustRegionRadius) <= this.k_easy * trustRegionRadius) {\n            // Added test to make sure that the result is better than the Cauchy point\n            var evalResult = MathVectorBasicOperations_6.dotProduct(this.gradient, this.step) + 0.5 * this.hessian.quadraticForm(this.step);\n            var evalCauchy = MathVectorBasicOperations_6.dotProduct(this.gradient, this.cauchyPoint) + 0.5 * this.hessian.quadraticForm(this.cauchyPoint);\n            if (evalResult > evalCauchy) {\n                return false;\n            }\n            else {\n                // stop with s = s(lambda)\n                this.hitsBoundary = true;\n                terminate = true;\n            }\n        }\n        if (this.range === lambdaRange.G) {\n            // Algorithm 7.3.5, Step 2. If lambda = 0 in G\n            if (this.lambda.current === 0) {\n                this.hitsBoundary = false; // since the Lagrange Multiplier is zero\n                terminate = true;\n                return terminate;\n            }\n            // Algorithm 7.3.5, Step 3. If lambda is in G and the LINPACK method gives u and alpha such that\n            // alpha^2 <u, H(lambda), u> <= k_hard ( <s(lambda), H(lambda) * s(lambda) + lambda * trustRegionRadius^2 >)\n            var s_min = estimateSmallestSingularValue(choleskyDecomposition.g);\n            //let alpha = s_min.value\n            //let u = s_min.vector\n            var intersection = getBoundariesIntersections(this.step, s_min.vector, trustRegionRadius);\n            var t_abs_max = void 0;\n            // To do : explain better why > instead of <\n            // relative_error is smaller for <\n            // it seems that we need the worst case to make sure the result is a better solution\n            // than the Cauchy point\n            if (Math.abs(intersection.tmin) > Math.abs(intersection.tmax)) {\n                t_abs_max = intersection.tmin;\n            }\n            else {\n                t_abs_max = intersection.tmax;\n            }\n            var quadraticTerm = hessianPlusLambda.quadraticForm(this.step);\n            var relative_error = Math.pow(t_abs_max * s_min.value, 2) / (quadraticTerm + this.lambda.current * Math.pow(trustRegionRadius, 2));\n            //if (relative_error <= this.k_hard || t_abs_min < this.CLOSE_TO_ZERO) {\n            if (relative_error <= this.k_hard) {\n                //saxpy(t_abs_min, s_min.vector, this.step) done at step 3b iii.\n                this.hitsBoundary = true;\n                this.hardCase = true;\n                terminate = true;\n            }\n        }\n        return terminate;\n    };\n    /**\n     * Update lambda.current\n     */\n    TrustRegionSubproblem.prototype.update_lambda = function () {\n        //step 5.\n        if (this.range === lambdaRange.L && this.gNorm !== 0) {\n            this.lambda.current = this.lambdaPlus;\n        }\n        else if (this.range === lambdaRange.G) {\n            var hessianPlusLambda = this.hessian.clone();\n            hessianPlusLambda.addValueOnDiagonal(this.lambdaPlus);\n            var choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n            // If the factorization succeeds, then lambdaPlus is in L. Otherwise, lambdaPlus is in N\n            if (choleskyDecomposition.success) {\n                this.lambda.current = this.lambdaPlus;\n            }\n            else {\n                this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambdaPlus);\n                // Check lambda.lb for interior convergence ???\n                this.lambda.current = updateLambda_using_equation_7_3_14(this.lambda.lowerBound, this.lambda.upperBound);\n            }\n        }\n        else {\n            this.lambda.current = updateLambda_using_equation_7_3_14(this.lambda.lowerBound, this.lambda.upperBound);\n        }\n    };\n    /**\n     * Returns the minimizer along the steepest descent (-gradient) direction subject to trust-region bound.\n     * Note: If the gradient is a zero vector then the function returns a zero vector\n     * @param trustRegionRadius The trust region radius\n     * @return The minimizer vector deta x\n     */\n    TrustRegionSubproblem.prototype.computeCauchyPoint = function (trustRegionRadius) {\n        // Bibliographic referece: Numerical Optimizatoin, second edition, Nocedal and Wright, p. 71-72\n        var gHg = this.hessian.quadraticForm(this.gradient);\n        var gNorm = MathVectorBasicOperations_1.norm(this.gradient);\n        // return a zero step if the gradient is zero\n        if (gNorm === 0) {\n            return MathVectorBasicOperations_8.zeroVector(this.gradient.length);\n        }\n        var result = MathVectorBasicOperations_4.multiplyVectorByScalar(this.gradient, -trustRegionRadius / gNorm);\n        if (gHg <= 0) {\n            return result;\n        }\n        var tau = Math.pow(gNorm, 3) / trustRegionRadius / gHg;\n        if (tau < 1) {\n            return MathVectorBasicOperations_4.multiplyVectorByScalar(result, tau);\n        }\n        return result;\n    };\n    /**\n     * Return an initial value, an upper bound and a lower bound for lambda.\n     * @param trustRegionRadius The trust region radius\n     * @return .current (lambda intial value) .lb (lower bound) and .ub (upper bound)\n     */\n    TrustRegionSubproblem.prototype.initialLambdas = function (trustRegionRadius) {\n        // Bibliographic reference : Trust-Region Methods, Conn, Gould and Toint p. 192\n        var gershgorin = gershgorin_bounds(this.hessian);\n        var hessianFrobeniusNorm = frobeniusNorm(this.hessian);\n        var hessianInfiniteNorm = 0;\n        var minHessianDiagonal = this.hessian.get(0, 0);\n        for (var i = 0; i < this.hessian.shape[0]; i += 1) {\n            var tempInfiniteNorm = 0;\n            for (var j = 0; j < this.hessian.shape[0]; j += 1) {\n                tempInfiniteNorm += Math.abs(this.hessian.get(i, j));\n            }\n            hessianInfiniteNorm = Math.max(hessianInfiniteNorm, tempInfiniteNorm);\n            minHessianDiagonal = Math.min(minHessianDiagonal, this.hessian.get(i, i));\n        }\n        var lowerBound = Math.max(0, Math.max(-minHessianDiagonal, MathVectorBasicOperations_1.norm(this.gradient) / trustRegionRadius - Math.min(gershgorin.upperBound, Math.min(hessianFrobeniusNorm, hessianInfiniteNorm))));\n        var upperBound = Math.max(0, MathVectorBasicOperations_1.norm(this.gradient) / trustRegionRadius + Math.min(-gershgorin.lowerBound, Math.min(hessianFrobeniusNorm, hessianInfiniteNorm)));\n        var lambda_initial;\n        if (lowerBound === 0) {\n            lambda_initial = 0;\n        }\n        else {\n            lambda_initial = updateLambda_using_equation_7_3_14(lowerBound, upperBound);\n        }\n        return {\n            current: lambda_initial,\n            lowerBound: lowerBound,\n            upperBound: upperBound\n        };\n    };\n    return TrustRegionSubproblem;\n}());\nexports.TrustRegionSubproblem = TrustRegionSubproblem;\n/**\n *\n * @param A\n * @param L\n * @param k\n * @return dela, vector\n * @throws If k < 0\n */\nfunction singularLeadingSubmatrix(A, L, k) {\n    if (k < 0) {\n        throw new Error('k should not be a negative value');\n    }\n    var delta = 0;\n    var l = new SquareMatrix_1.SquareMatrix(k);\n    var v = [];\n    var u = MathVectorBasicOperations_8.zeroVector(k);\n    for (var j = 0; j < k - 1; j += 1) {\n        delta += Math.pow(L.get(k - 1, j), 2);\n    }\n    delta -= A.get(k - 1, k - 1);\n    for (var i = 0; i < k - 1; i += 1) {\n        for (var j = 0; j <= i; j += 1) {\n            l.set(i, j, L.get(i, j));\n        }\n        u[i] = L.get(k - 1, i);\n    }\n    v = MathVectorBasicOperations_8.zeroVector(A.shape[0]);\n    v[k - 1] = 1;\n    if (k !== 1) {\n        var vtemp = solveLowerTriangular(l, u);\n        for (var i = 0; i < k - 1; i += 1) {\n            v[i] = vtemp[i];\n        }\n    }\n    return {\n        delta: delta,\n        vector: v\n    };\n}\n/**\n * Estimate the smallest singular value\n * @param lowerTriangular\n */\nfunction estimateSmallestSingularValue(lowerTriangular) {\n    // Bibliographic reference :  Golub, G. H., Van Loan, C. F. (2013), \"Matrix computations\". Forth Edition. JHU press. pp. 140-142.\n    // Web reference: https://github.com/scipy/scipy/blob/master/scipy/optimize/_trustregion_exact.py\n    var n = lowerTriangular.shape[0];\n    var p = MathVectorBasicOperations_8.zeroVector(n);\n    var y = MathVectorBasicOperations_8.zeroVector(n);\n    var p_plus = [];\n    var p_minus = [];\n    for (var k = 0; k < n; k += 1) {\n        var y_plus = (1 - p[k]) / lowerTriangular.get(k, k);\n        var y_minus = (-1 - p[k]) / lowerTriangular.get(k, k);\n        for (var i = k + 1; i < n; i += 1) {\n            p_plus.push(p[i] + lowerTriangular.get(i, k) * y_plus);\n            p_minus.push(p[i] + lowerTriangular.get(i, k) * y_minus);\n        }\n        if (Math.abs(y_plus) + MathVectorBasicOperations_2.norm1(p_plus) >= Math.abs(y_minus) + MathVectorBasicOperations_2.norm1(p_minus)) {\n            y[k] = y_plus;\n            for (var i = k + 1; i < n; i += 1) {\n                p[i] = p_plus[i - k - 1];\n            }\n        }\n        else {\n            y[k] = y_minus;\n            for (var i = k + 1; i < n; i += 1) {\n                p[i] = p_minus[i - k - 1];\n            }\n        }\n    }\n    var v = solveUpperTriangular(lowerTriangular, y);\n    var vNorm = MathVectorBasicOperations_1.norm(v);\n    var yNorm = MathVectorBasicOperations_1.norm(y);\n    if (vNorm === 0) {\n        throw new Error(\"divideVectorByScalar division by zero\");\n    }\n    return {\n        value: yNorm / vNorm,\n        vector: MathVectorBasicOperations_5.divideVectorByScalar(v, vNorm)\n    };\n}\n/**\n * Solve the linear problem upper triangular matrix UT x = y\n * @param lowerTriangular The transpose of the upper triangular matrix\n * @param y The vector y\n */\nfunction solveUpperTriangular(lowerTriangular, y) {\n    var x = y.slice();\n    var n = lowerTriangular.shape[0];\n    // LT x = y\n    for (var i = n - 1; i >= 0; i -= 1) {\n        var sum = x[i];\n        for (var k = i + 1; k < n; k += 1) {\n            sum -= lowerTriangular.get(k, i) * x[k];\n        }\n        x[i] = sum / lowerTriangular.get(i, i);\n    }\n    return x;\n}\n/**\n * Solve the linear problem lower triangular matrix LT x = b\n * @param lowerTriangular The lower triangular matrix\n * @param b The vector b\n */\nfunction solveLowerTriangular(lowerTriangular, b) {\n    if (lowerTriangular.shape[0] !== b.length) {\n        throw new Error('solveLowerTriangular: matrix and vector are not the same sizes');\n    }\n    var x = b.slice();\n    var n = lowerTriangular.shape[0];\n    // L x = b\n    for (var i = 0; i < n; i += 1) {\n        var sum = b[i];\n        for (var k = i - 1; k >= 0; k -= 1) {\n            sum -= lowerTriangular.get(i, k) * x[k];\n        }\n        x[i] = sum / lowerTriangular.get(i, i);\n    }\n    return x;\n}\n/**\n * The frobenius norm\n * @param matrix The matrix\n * @return The square root of the sum of every elements squared\n */\nfunction frobeniusNorm(matrix) {\n    var result = 0;\n    var m = matrix.shape[0];\n    var n = matrix.shape[1];\n    for (var i = 0; i < m; i += 1) {\n        for (var j = 0; j < n; j += 1) {\n            result += Math.pow(matrix.get(i, j), 2);\n        }\n    }\n    result = Math.sqrt(result);\n    return result;\n}\nexports.frobeniusNorm = frobeniusNorm;\n/**\n* Given a symmetric matrix, compute the Gershgorin upper and lower bounds for its eigenvalues\n* @param matrix Symmetric Matrix\n* @return .lb (lower bound) and .ub (upper bound)\n*/\nfunction gershgorin_bounds(matrix) {\n    // Bibliographic Reference : Trust-Region Methods, Conn, Gould and Toint p. 19\n    // Gershgorin Bounds : All eigenvalues of a matrix A lie in the complex plane within the intersection\n    // of n discs centered at a_(i, i) and of radii : sum of a_(i, j) for 1 ≤ i ≤ n and  j != i\n    // When the matrix is symmetric, the eigenvalues are real and the discs become intervals on the real\n    // line\n    var m = matrix.shape[0];\n    var n = matrix.shape[1];\n    var matrixRowSums = [];\n    for (var i = 0; i < m; i += 1) {\n        var rowSum = 0;\n        for (var j = 0; j < n; j += 1) {\n            rowSum += Math.abs(matrix.get(i, j));\n        }\n        matrixRowSums.push(rowSum);\n    }\n    var matrixDiagonal = [];\n    var matrixDiagonalAbsolute = [];\n    for (var i = 0; i < m; i += 1) {\n        matrixDiagonal.push(matrix.get(i, i));\n        matrixDiagonalAbsolute.push(Math.abs(matrix.get(i, i)));\n    }\n    var lb = [];\n    var ub = [];\n    for (var i = 0; i < m; i += 1) {\n        lb.push(matrixDiagonal[i] + matrixDiagonalAbsolute[i] - matrixRowSums[i]);\n        ub.push(matrixDiagonal[i] - matrixDiagonalAbsolute[i] + matrixRowSums[i]);\n    }\n    var lowerBound = Math.min.apply(null, lb);\n    var upperBound = Math.max.apply(null, ub);\n    return {\n        lowerBound: lowerBound,\n        upperBound: upperBound\n    };\n}\nexports.gershgorin_bounds = gershgorin_bounds;\n/**\n * Solve the scalar quadratic equation ||z + t d|| == trust_radius\n * This is like a line-sphere intersection\n * @param z Vector\n * @param d Vector\n * @param trustRegionRadius\n * @returns The two values of t, sorted from low to high\n */\nfunction getBoundariesIntersections(z, d, trustRegionRadius) {\n    if (MathVectorBasicOperations_1.isZeroVector(d)) {\n        throw new Error(\"In getBoundariesInstersections the d vector cannot be the zero vector\");\n    }\n    var a = MathVectorBasicOperations_3.squaredNorm(d);\n    var b = 2 * MathVectorBasicOperations_6.dotProduct(z, d);\n    var c = MathVectorBasicOperations_3.squaredNorm(z) - trustRegionRadius * trustRegionRadius;\n    var sqrtDiscriminant = Math.sqrt(b * b - 4 * a * c);\n    var sign_b = MathVectorBasicOperations_9.sign(b);\n    if (sign_b === 0) {\n        sign_b = 1;\n    }\n    var aux = b + sqrtDiscriminant * sign_b;\n    var ta = -aux / (2 * a);\n    var tb = -2 * c / aux;\n    return {\n        tmin: Math.min(ta, tb),\n        tmax: Math.max(ta, tb)\n    };\n}\nexports.getBoundariesIntersections = getBoundariesIntersections;\nfunction updateLambda_using_equation_7_3_14(lowerBound, upperBound, theta) {\n    if (theta === void 0) { theta = 0.01; }\n    // Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 190\n    return Math.max(Math.sqrt(upperBound * lowerBound), lowerBound + theta * (upperBound - lowerBound));\n}\n","\"use strict\";\n/**\n * A two dimensional vector\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector_2d = void 0;\nvar Vector_2d = /** @class */ (function () {\n    function Vector_2d(x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.x = x;\n        this.y = y;\n    }\n    Vector_2d.prototype.negative = function () {\n        return new Vector_2d(-this.x, -this.y);\n    };\n    Vector_2d.prototype.add = function (v) {\n        return new Vector_2d(this.x + v.x, this.y + v.y);\n    };\n    Vector_2d.prototype.multiply = function (value) {\n        return new Vector_2d(this.x * value, this.y * value);\n    };\n    Vector_2d.prototype.substract = function (v) {\n        return new Vector_2d(this.x - v.x, this.y - v.y);\n    };\n    Vector_2d.prototype.rotate90degrees = function () {\n        return new Vector_2d(-this.y, this.x);\n    };\n    Vector_2d.prototype.normalize = function () {\n        var x, y, norm;\n        norm = Math.sqrt(this.x * this.x + this.y * this.y);\n        x = this.x / norm;\n        y = this.y / norm;\n        return new Vector_2d(x, y);\n    };\n    Vector_2d.prototype.dot = function (v) {\n        'use strict';\n        return this.x * v.x + this.y * v.y;\n    };\n    Vector_2d.prototype.distance = function (v) {\n        'use strict';\n        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\n    };\n    return Vector_2d;\n}());\nexports.Vector_2d = Vector_2d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveModel = void 0;\nvar BSpline_R1_to_R2_1 = require(\"../mathematics/BSpline_R1_to_R2\");\nvar Vector_2d_1 = require(\"../mathematics/Vector_2d\");\nvar CurveModel = /** @class */ (function () {\n    function CurveModel() {\n        //private target: PeriodicBSpline_R1_to_R2\n        this.observers = [];\n        //const cp = [ [-0.5, 0.5], [-0.25, -0.4], [0.25, 0.0], [0.5, -0.5] ]\n        var deltay = -0.3;\n        var cp = [[-0.5, 0.2 + deltay], [-0.25, 0 + deltay], [0.25, 0.1 + deltay], [0.5, 0.6 + deltay]];\n        var knots = [0, 0, 0, 0, 1, 1, 1, 1];\n        this.spline = BSpline_R1_to_R2_1.create_BSpline_R1_to_R2(cp, knots);\n        //this.spline.insertKnot(0.1)\n        //this.spline.insertKnot(0.2)\n        //this.spline.insertKnot(1/3)\n        //this.spline.insertKnot(0.4)\n        //this.spline.insertKnot(0.5)\n        //this.spline.insertKnot(2/3)\n        //this.spline.insertKnot(0.7)\n        //this.spline.insertKnot(0.8)\n        //this.spline.insertKnot(0.9)\n        /*\n               const cp = [ [-0.5, 0.5], [-0.35, 0.4], [-0.2, 0], [0.2, 0], [0.35, 0.4], [0.5, 0.5] ]\n               const knots = [0, 0, 0, 0, 0, 0,  1, 1, 1, 1, 1, 1]\n               this.spline = create_BSpline_R1_to_R2(cp, knots)\n        */\n        /*\n               const cp = [ [-0.5, 0.5], [-0.35, 0.4], [0, 0], [0.35, 0.4], [0.5, 0.5] ]\n               const knots = [0, 0, 0, 0, 0,  1, 1, 1, 1, 1]\n               this.spline = create_BSpline_R1_to_R2(cp, knots)\n        */\n        //this.spline.insertKnot(0.1)\n        //this.spline.insertKnot(0.2)\n        //this.spline.insertKnot(0.3)\n        //this.spline.insertKnot(0.4)\n        //this.spline.insertKnot(0.5)\n        //this.spline.insertKnot(0.6)\n        //this.spline.insertKnot(0.7)\n        //this.spline.insertKnot(0.8)\n        //this.spline.insertKnot(0.9)\n        /*\n        const cp = [ [-0.5, 0.5], [-0.35, 0.4], [-0.2, 0], [0.2, 0], [0.35, 0.4] ]\n        const knots = [0, 0, 0, 0, 0,  1, 1, 1, 1, 1]\n        this.spline = create_BSpline_R1_to_R2(cp, knots)\n         */\n        /*\n        let knots = [0, 0, 0, 0]\n        const n = 20\n        for (let i = 1; i < n; i += 1) {\n            knots.push(i/n)\n        }\n        knots.push(1)\n        knots.push(1)\n        knots.push(1)\n        knots.push(1)\n        const cp = [ [0.975, 0.248], [0.902, 0.294], [0.876, 0.397], [0.773, 0.466], [0.775, 0.486], [0.822, 0.517], [0.819, 0.535], [0.795, 0.543], [0.788, 0.559], [0.846, 0.572], [0.793, 0.589], [0.792, 0.603], [0.807, 0.613], [0.831, 0.626], [0.801, 0.660], [0.800, 0.699], [0.819, 0.724], [0.863, 0.736], [0.917, 0.720], [0.958, 0.753], [0.943, 0.814], [0.988, 0.873], [0.995, 0.943] ]\n\n        for (let i = 0; i < cp.length; i += 1) {\n            cp[i][0] -= 0.9\n            cp[i][1] -= 0.6\n        }\n\n        for (let i = 0; i < cp.length; i += 1) {\n            cp[i][0] = cp[i][0] * 2.5\n            cp[i][1] = -cp[i][1] * 2.5\n        }\n\n        this.spline = create_BSpline_R1_to_R2(cp, knots)\n        */\n    }\n    CurveModel.prototype.registerObserver = function (observer) {\n        this.observers.push(observer);\n    };\n    CurveModel.prototype.removeObserver = function (observer) {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    };\n    CurveModel.prototype.notifyObservers = function () {\n        for (var i = 0; i < this.observers.length; i += 1) {\n            this.observers[i].update(this.spline);\n        }\n    };\n    CurveModel.prototype.moveControlPoint = function (controlPointIndex, deltaX, deltaY) {\n        this.spline.moveControlPoint(controlPointIndex, deltaX, deltaY);\n        if (deltaX * deltaX + deltaY * deltaY > 0) {\n            this.notifyObservers();\n        }\n    };\n    CurveModel.prototype.setControlPoint = function (controlPointIndex, x, y) {\n        this.spline.setControlPoint(controlPointIndex, new Vector_2d_1.Vector_2d(x, y));\n        //this.notifyObservers()\n    };\n    CurveModel.prototype.setControlPoints = function (controlPoints) {\n        this.spline.setControlPoints(controlPoints);\n        //this.notifyObservers()\n    };\n    CurveModel.prototype.setSpline = function (spline) {\n        this.spline = spline;\n        this.notifyObservers();\n    };\n    return CurveModel;\n}());\nexports.CurveModel = CurveModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClickButtonView = void 0;\nvar ClickButtonView = /** @class */ (function () {\n    function ClickButtonView(x, y, clickButtonShaders) {\n        this.x = x;\n        this.y = y;\n        this.clickButtonShaders = clickButtonShaders;\n        this.red = 0.5;\n        this.green = 0.5;\n        this.blue = 0.5;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        var check = this.initVertexBuffers(this.clickButtonShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    ClickButtonView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.05;\n        var ratio = 1.5;\n        this.vertices = new Float32Array(4 * 8);\n        this.indices = new Uint8Array(2 * 3);\n        this.vertices[0] = this.x - size * ratio;\n        this.vertices[1] = this.y - size;\n        this.vertices[2] = this.z;\n        this.vertices[3] = -ratio;\n        this.vertices[4] = -1;\n        this.vertices[5] = this.red;\n        this.vertices[6] = this.green;\n        this.vertices[7] = this.blue;\n        this.vertices[8] = this.x + size * ratio;\n        this.vertices[9] = this.y - size;\n        this.vertices[10] = this.z;\n        this.vertices[11] = ratio;\n        this.vertices[12] = -1;\n        this.vertices[13] = this.red;\n        this.vertices[14] = this.green;\n        this.vertices[15] = this.blue;\n        this.vertices[16] = this.x + size * ratio;\n        this.vertices[17] = this.y + size;\n        this.vertices[18] = this.z;\n        this.vertices[19] = ratio;\n        this.vertices[20] = 1;\n        this.vertices[21] = this.red;\n        this.vertices[22] = this.green;\n        this.vertices[23] = this.blue;\n        this.vertices[24] = this.x - size * ratio;\n        this.vertices[25] = this.y + size;\n        this.vertices[26] = this.z;\n        this.vertices[27] = -ratio;\n        this.vertices[28] = 1;\n        this.vertices[29] = this.red;\n        this.vertices[30] = this.green;\n        this.vertices[31] = this.blue;\n        this.indices[0] = 0;\n        this.indices[1] = 1;\n        this.indices[2] = 2;\n        this.indices[3] = 0;\n        this.indices[4] = 2;\n        this.indices[5] = 3;\n    };\n    ClickButtonView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    ClickButtonView.prototype.renderFrame = function () {\n        var gl = this.clickButtonShaders.gl, a_Position = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.clickButtonShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        this.clickButtonShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    ClickButtonView.prototype.selected = function (x, y) {\n        var deltaSquared = 0.01;\n        var result = false;\n        if (Math.pow(x - this.x, 2) + Math.pow(y - this.y, 2) < deltaSquared) {\n            result = true;\n        }\n        return result;\n    };\n    ClickButtonView.prototype.updateBuffers = function () {\n        var gl = this.clickButtonShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return ClickButtonView;\n}());\nexports.ClickButtonView = ClickButtonView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPointsShaders = void 0;\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar ControlPointsShaders = /** @class */ (function () {\n    function ControlPointsShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    v_Color = a_Color; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            '//uniform bool selected; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '     vec4 fColor = vec4(0.1, 0.1, 0.1, 0.0); \\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     vec4 color1 = vec4(v_Color, 0.35); \\n' +\n            '     vec4 color2 = vec4(v_Color, 0.9); \\n' +\n            '     float delta = 0.1; \\n' +\n            '     float alpha1 = smoothstep(0.35-delta, 0.35, dist); \\n' +\n            '     float alpha2 = smoothstep(0.65-delta, 0.65, dist); \\n' +\n            '     vec4 fColor1 = mix(color1, fColor, alpha1); \\n' +\n            '     vec4 fColor2 = mix(color2, fColor, alpha2); \\n' +\n            '     gl_FragColor = (fColor1+fColor2)/2.0; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    ControlPointsShaders.prototype.renderFrame = function (numberOfElements, selectedControlPoint) {\n        //const False = 0\n        //const True = 1\n        if (this.program) {\n            //this.gl.uniform1i(this.gl.getUniformLocation(this.program, \"selected\"), False);\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n            if (selectedControlPoint != -1 && selectedControlPoint !== null) {\n                //this.gl.uniform1i(this.gl.getUniformLocation(this.program, \"selected\"), True);\n                this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_BYTE, selectedControlPoint * 6);\n            }\n        }\n    };\n    return ControlPointsShaders;\n}());\nexports.ControlPointsShaders = ControlPointsShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPointsView = void 0;\nvar ControlPointsView = /** @class */ (function () {\n    function ControlPointsView(spline, controlPointsShaders, red, blue, green) {\n        this.spline = spline;\n        this.controlPointsShaders = controlPointsShaders;\n        this.red = red;\n        this.blue = blue;\n        this.green = green;\n        this.z = 0;\n        this.selectedControlPoint = null;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.controlPointsShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    ControlPointsView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.03;\n        //const size = 0.05\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var x = this.controlPoints[i].x;\n            var y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    ControlPointsView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    ControlPointsView.prototype.renderFrame = function () {\n        var gl = this.controlPointsShaders.gl, a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.controlPointsShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        this.controlPointsShaders.renderFrame(this.indices.length, this.selectedControlPoint);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    ControlPointsView.prototype.controlPointSelection = function (x, y, deltaSquared) {\n        if (deltaSquared === void 0) { deltaSquared = 0.01; }\n        //const deltaSquared = 0.01\n        //const deltaSquared = 0.001\n        var result = null;\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            if (Math.pow(x - this.controlPoints[i].x, 2) + Math.pow(y - this.controlPoints[i].y, 2) < deltaSquared) {\n                return i;\n            }\n        }\n        return result;\n    };\n    ControlPointsView.prototype.update = function (spline) {\n        this.controlPoints = spline.visibleControlPoints();\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    };\n    ControlPointsView.prototype.updatePoints = function (points) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    };\n    ControlPointsView.prototype.updateBuffers = function () {\n        var gl = this.controlPointsShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    ControlPointsView.prototype.getSelectedControlPoint = function () {\n        return this.selectedControlPoint;\n    };\n    ControlPointsView.prototype.setSelected = function (controlPointIndex) {\n        this.selectedControlPoint = controlPointIndex;\n    };\n    return ControlPointsView;\n}());\nexports.ControlPointsView = ControlPointsView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPolygonShaders = void 0;\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar ControlPolygonShaders = /** @class */ (function () {\n    function ControlPolygonShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'void main() {\\n' +\n            '     gl_FragColor = vec4(216.0/255.0, 216.0/255.0, 216.0/255.0, 0.05); \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    ControlPolygonShaders.prototype.renderFrame = function (numberOfElements) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n    };\n    return ControlPolygonShaders;\n}());\nexports.ControlPolygonShaders = ControlPolygonShaders;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPolygonView = void 0;\nvar ControlPolygonView = /** @class */ (function () {\n    function ControlPolygonView(spline, controlPolygonShaders, closed) {\n        if (closed === void 0) { closed = false; }\n        this.spline = spline;\n        this.controlPolygonShaders = controlPolygonShaders;\n        this.closed = closed;\n        this.z = 0;\n        this.selectedControlPoint = null;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.controlPolygonShaders = controlPolygonShaders;\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.controlPolygonShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    ControlPolygonView.prototype.updateVerticesAndIndices = function () {\n        var thickness = 0.003;\n        //const thickness = 0.0075\n        //const thickness = 0.006\n        this.vertices = new Float32Array(this.controlPoints.length * 12);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length - 1; i += 1) {\n            var normal = this.controlPoints[i + 1].substract(this.controlPoints[i]).normalize().rotate90degrees();\n            this.vertices[12 * i] = this.controlPoints[i].x - thickness * normal.x;\n            this.vertices[12 * i + 1] = this.controlPoints[i].y - thickness * normal.y;\n            this.vertices[12 * i + 2] = this.z;\n            this.vertices[12 * i + 3] = this.controlPoints[i + 1].x - thickness * normal.x;\n            this.vertices[12 * i + 4] = this.controlPoints[i + 1].y - thickness * normal.y;\n            this.vertices[12 * i + 5] = this.z;\n            this.vertices[12 * i + 6] = this.controlPoints[i + 1].x + thickness * normal.x;\n            this.vertices[12 * i + 7] = this.controlPoints[i + 1].y + thickness * normal.y;\n            this.vertices[12 * i + 8] = this.z;\n            this.vertices[12 * i + 9] = this.controlPoints[i].x + thickness * normal.x;\n            this.vertices[12 * i + 10] = this.controlPoints[i].y + thickness * normal.y;\n            this.vertices[12 * i + 11] = this.z;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    ControlPolygonView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    ControlPolygonView.prototype.renderFrame = function () {\n        var gl = this.controlPolygonShaders.gl;\n        var a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        gl.useProgram(this.controlPolygonShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(a_Position);\n        this.controlPolygonShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    ControlPolygonView.prototype.update = function (message) {\n        this.controlPoints = message.visibleControlPoints();\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    };\n    ControlPolygonView.prototype.updateBuffers = function () {\n        var gl = this.controlPolygonShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return ControlPolygonView;\n}());\nexports.ControlPolygonView = ControlPolygonView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurvatureExtremaShaders = void 0;\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar CurvatureExtremaShaders = /** @class */ (function () {\n    function CurvatureExtremaShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            'uniform vec4 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     if (dist > 0.5) discard; \\n' +\n            '     gl_FragColor = a_Color; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    CurvatureExtremaShaders.prototype.renderFrame = function (numberOfElements) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n        }\n    };\n    return CurvatureExtremaShaders;\n}());\nexports.CurvatureExtremaShaders = CurvatureExtremaShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurvatureExtremaView = void 0;\n//import { PeriodicBSpline_R1_to_R2_DifferentialProperties } from \"../mathematics/PeriodicBSpline_R1_to_R2_DifferentialProperties\";\n//import { PeriodicBSpline_R1_to_R2 } from \"../mathematics/PeriodicBSpline_R1_to_R2\";\nvar BSpline_R1_to_R2_1 = require(\"../mathematics/BSpline_R1_to_R2\");\nvar BSpline_R1_to_R2_DifferentialProperties_1 = require(\"../mathematics/BSpline_R1_to_R2_DifferentialProperties\");\nvar CurvatureExtremaView = /** @class */ (function () {\n    function CurvatureExtremaView(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    CurvatureExtremaView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.03;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var x = this.controlPoints[i].x;\n            var y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    CurvatureExtremaView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    CurvatureExtremaView.prototype.renderFrame = function () {\n        var gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    CurvatureExtremaView.prototype.update = function (spline) {\n        if (spline instanceof BSpline_R1_to_R2_1.BSpline_R1_to_R2) {\n            var splineDP = new BSpline_R1_to_R2_DifferentialProperties_1.BSpline_R1_to_R2_DifferentialProperties(spline);\n            this.controlPoints = splineDP.curvatureExtrema();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n        /*\n        if (spline instanceof PeriodicBSpline_R1_to_R2) {\n            const splineDP = new PeriodicBSpline_R1_to_R2_DifferentialProperties(spline)\n            this.controlPoints = splineDP.curvatureExtrema()\n            this.updateVerticesAndIndices()\n            this.updateBuffers()\n        }\n        */\n    };\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    CurvatureExtremaView.prototype.updateBuffers = function () {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return CurvatureExtremaView;\n}());\nexports.CurvatureExtremaView = CurvatureExtremaView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveShaders = void 0;\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar CurveShaders = /** @class */ (function () {\n    function CurveShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec4 fColor; \\n' +\n            'void main() {\\n' +\n            '    gl_FragColor = fColor; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    CurveShaders.prototype.renderFrame = function (numberOfVertices) {\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, numberOfVertices);\n    };\n    return CurveShaders;\n}());\nexports.CurveShaders = CurveShaders;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveView = void 0;\nvar CurveView = /** @class */ (function () {\n    function CurveView(spline, curveShaders, red, green, blue, alpha) {\n        this.spline = spline;\n        this.curveShaders = curveShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.POINT_SEQUENCE_SIZE = 1000;\n        //private readonly z = 0\n        this.pointSequenceOnSpline = [];\n        //private selectedControlPoint: number | null = null\n        this.vertexBuffer = null;\n        //private indexBuffer: WebGLBuffer | null = null\n        this.vertices = new Float32Array(this.POINT_SEQUENCE_SIZE * 6);\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.curveShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    CurveView.prototype.updatePointSequenceOnSpline = function () {\n        var start = this.spline.knots[this.spline.degree];\n        var end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        this.pointSequenceOnSpline = [];\n        for (var i = 0; i < this.POINT_SEQUENCE_SIZE; i += 1) {\n            var point = this.spline.evaluate(i / (this.POINT_SEQUENCE_SIZE - 1) * (end - start) + start);\n            this.pointSequenceOnSpline.push(point);\n        }\n    };\n    CurveView.prototype.updateVertices = function () {\n        var thickness = 0.005;\n        //const thickness = 0.004\n        //const thickness = 0.008\n        var maxLength = thickness * 3;\n        var tangent = ((this.pointSequenceOnSpline[1]).substract(this.pointSequenceOnSpline[0])).normalize(), normal = tangent.rotate90degrees(), miter, length, result = [];\n        result.push(this.pointSequenceOnSpline[0].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[0].substract(normal.multiply(thickness)));\n        for (var i = 1; i < this.pointSequenceOnSpline.length - 1; i += 1) {\n            normal = (this.pointSequenceOnSpline[i].substract(this.pointSequenceOnSpline[i - 1])).normalize().rotate90degrees();\n            tangent = (this.pointSequenceOnSpline[i + 1].substract(this.pointSequenceOnSpline[i - 1])).normalize();\n            miter = tangent.rotate90degrees();\n            length = thickness / (miter.dot(normal));\n            if (length > maxLength) {\n                length = maxLength;\n            }\n            result.push(this.pointSequenceOnSpline[i].add(miter.multiply(length)));\n            result.push(this.pointSequenceOnSpline[i].substract(miter.multiply(length)));\n        }\n        tangent = this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].substract(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 2]).normalize();\n        normal = tangent.rotate90degrees();\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].substract(normal.multiply(thickness)));\n        for (var i = 0; i < result.length; i += 1) {\n            this.vertices[3 * i] = result[i].x;\n            this.vertices[3 * i + 1] = result[i].y;\n            this.vertices[3 * i + 2] = 0.0;\n        }\n    };\n    CurveView.prototype.update = function (spline) {\n        this.spline = spline;\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        this.updateBuffers();\n    };\n    CurveView.prototype.updateBuffers = function () {\n        var gl = this.curveShaders.gl;\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    };\n    CurveView.prototype.renderFrame = function () {\n        var gl = this.curveShaders.gl;\n        var a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        var fColorLocation = gl.getUniformLocation(this.curveShaders.program, \"fColor\");\n        gl.useProgram(this.curveShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.uniform4f(fColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curveShaders.renderFrame(this.vertices.length / 3);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    CurveView.prototype.initVertexBuffers = function (gl) {\n        var a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        return 1;\n    };\n    return CurveView;\n}());\nexports.CurveView = CurveView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InflectionsView = void 0;\n//import { PeriodicBSpline_R1_to_R2_DifferentialProperties } from \"../mathematics/PeriodicBSpline_R1_to_R2_DifferentialProperties\";\n//import { PeriodicBSpline_R1_to_R2 } from \"../mathematics/PeriodicBSpline_R1_to_R2\";\nvar BSpline_R1_to_R2_1 = require(\"../mathematics/BSpline_R1_to_R2\");\nvar BSpline_R1_to_R2_DifferentialProperties_1 = require(\"../mathematics/BSpline_R1_to_R2_DifferentialProperties\");\nvar InflectionsView = /** @class */ (function () {\n    function InflectionsView(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    InflectionsView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.025;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var x = this.controlPoints[i].x;\n            var y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    InflectionsView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    InflectionsView.prototype.renderFrame = function () {\n        var gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    InflectionsView.prototype.update = function (spline) {\n        if (spline instanceof BSpline_R1_to_R2_1.BSpline_R1_to_R2) {\n            var splineDP = new BSpline_R1_to_R2_DifferentialProperties_1.BSpline_R1_to_R2_DifferentialProperties(spline);\n            this.controlPoints = splineDP.inflections();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n        /*\n        if (spline instanceof PeriodicBSpline_R1_to_R2) {\n            const splineDP = new PeriodicBSpline_R1_to_R2_DifferentialProperties(spline)\n            this.controlPoints = splineDP.inflections()\n            this.updateVerticesAndIndices()\n            this.updateBuffers()\n        }\n        */\n    };\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    InflectionsView.prototype.updateBuffers = function () {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return InflectionsView;\n}());\nexports.InflectionsView = InflectionsView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InsertKnotButtonShaders = void 0;\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar InsertKnotButtonShaders = /** @class */ (function () {\n    function InsertKnotButtonShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    v_Color = a_Color; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '     float dist1 = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     float dist2 = distance(v_Texture, vec2(0.9, 0.0)); \\n' +\n            '     float dist3 = distance(v_Texture, vec2(-0.9, 0.0)); \\n' +\n            '     if (dist1 < 0.25 || dist2 < 0.25 || dist3 < 0.25) { \\n' +\n            '     gl_FragColor = vec4(0.25, 0.25, 0.25, 1.0); } \\n ' +\n            '     else if (v_Texture[0] > -0.9 && v_Texture[0] < 0.9 && v_Texture[1] < 0.1 && v_Texture[1] > -0.1) { \\n' +\n            '     gl_FragColor = vec4(0.25, 0.25, 0.25, 1.0); } \\n ' +\n            '     else if ( distance(v_Texture, vec2(1.2, 0.7)) > 0.3 && v_Texture[0] > 1.2 && v_Texture[1] > 0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else if ( distance(v_Texture, vec2(1.2, -0.7)) > 0.3 && v_Texture[0] > 1.2 && v_Texture[1] < -0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else if ( distance(v_Texture, vec2(-1.2, 0.7)) > 0.3 && v_Texture[0] < -1.2 && v_Texture[1] > 0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else if ( distance(v_Texture, vec2(-1.2, -0.7)) > 0.3 && v_Texture[0] < -1.2 && v_Texture[1] < -0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else { \\n' +\n            '     /*gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0); } */ \\n' +\n            '     gl_FragColor = vec4(v_Color, 1.0); } \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    InsertKnotButtonShaders.prototype.renderFrame = function (numberOfElements) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n        }\n    };\n    return InsertKnotButtonShaders;\n}());\nexports.InsertKnotButtonShaders = InsertKnotButtonShaders;\n;\n","\"use strict\";\n// Reference: cuon-utils.js\n// cuon-utils.js (c) 2012 kanda and matsuda\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProgram = void 0;\n/**\n * Create the linked program object\n * @param gl GL context\n * @param vshader a vertex shader program (string)\n * @param fshader a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n */\nfunction createProgram(gl, vshader, fshader) {\n    // Create shader object\n    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\n    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n    if (!vertexShader || !fragmentShader) {\n        console.log(\"createProgram was unable to produce a vertex or fragment shader\");\n        return null;\n    }\n    // Create a program object\n    var program = gl.createProgram();\n    if (!program) {\n        console.log(\"createProgram was unable to produce a program\");\n        return null;\n    }\n    // Attach the shader objects\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    // Link the program object\n    gl.linkProgram(program);\n    // Check the result of linking\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        var error = gl.getProgramInfoLog(program);\n        console.log('Failed to link program: ' + error);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n        return null;\n    }\n    return program;\n}\nexports.createProgram = createProgram;\n/**\n * Create a shader object\n * @param gl GL context\n * @param type the type of the shader object to be created\n * @param source shader program (string)\n * @return created shader object, or null if the creation has failed.\n */\nfunction loadShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    if (shader == null) {\n        console.log('unable to create shader');\n        return null;\n    }\n    // Set the shader program\n    gl.shaderSource(shader, source);\n    // Compile the shader\n    gl.compileShader(shader);\n    // Check the result of compilation\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n        var error = gl.getShaderInfoLog(shader);\n        console.log('Failed to compile shader: ' + error);\n        gl.deleteShader(shader);\n        return null;\n    }\n    return shader;\n}\n","\"use strict\";\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebGLUtils = void 0;\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\nfunction WebGLUtils() {\n    /**\n     * Creates the HTLM for a failure message\n     * @param {string} canvasContainerId id of container of th\n     *        canvas.\n     * @return {string} The html.\n     */\n    var makeFailHTML = function (msg) {\n        return '' +\n            '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n        return '' +\n            '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n            '<td align=\"center\">' +\n            '<div style=\"display: table-cell; vertical-align: middle;\">' +\n            '<div style=\"\">' + msg + '</div>' +\n            '</div>' +\n            '</td></tr></table>';\n    };\n    /**\n     * Mesasge for getting a webgl browser\n     * @type {string}\n     */\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n    /**\n     * Mesasge for need better hardware\n     * @type {string}\n     */\n    var OTHER_PROBLEM = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n    /**\n     * Creates a webgl context. If creation fails it will\n     * change the contents of the container of the <canvas>\n     * tag to an error message with the correct links for WebGL.\n     * @param {Element} canvas. The canvas element to create a\n     *     context from.\n     * @param {WebGLContextCreationAttirbutes} opt_attribs Any\n     *     creation attributes you want to pass in.\n     * @param {function:(msg)} opt_onError An function to call\n     *     if there is an error during creation.\n     * @return {WebGLRenderingContext} The created context.\n     */\n    var setupWebGL = function (canvas, opt_attribs, opt_onError) {\n        function handleCreationError(msg) {\n            var container = document.getElementsByTagName(\"body\")[0];\n            //var container = canvas.parentNode;\n            if (container) {\n                var str = window.WebGLRenderingContext ?\n                    OTHER_PROBLEM :\n                    GET_A_WEBGL_BROWSER;\n                if (msg) {\n                    str += \"<br/><br/>Status: \" + msg;\n                }\n                container.innerHTML = makeFailHTML(str);\n            }\n        }\n        ;\n        opt_onError = opt_onError || handleCreationError;\n        if (canvas.addEventListener) {\n            canvas.addEventListener(\"webglcontextcreationerror\", function (event) {\n                opt_onError(event.statusMessage);\n            }, false);\n        }\n        var context = create3DContext(canvas, opt_attribs);\n        if (!context) {\n            if (!window.WebGLRenderingContext) {\n                opt_onError(\"\");\n            }\n            else {\n                opt_onError(\"\");\n            }\n        }\n        return context;\n    };\n    /**\n     * Creates a webgl context.\n     * @param {!Canvas} canvas The canvas tag to get context\n     *     from. If one is not passed in one will be created.\n     * @return {!WebGLContext} The created context.\n     */\n    var create3DContext = function (canvas, opt_attribs) {\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n        var context = null;\n        for (var ii = 0; ii < names.length; ++ii) {\n            try {\n                context = canvas.getContext(names[ii], opt_attribs);\n            }\n            catch (e) { }\n            if (context) {\n                break;\n            }\n        }\n        return context;\n    };\n    return {\n        create3DContext: create3DContext,\n        setupWebGL: setupWebGL\n    };\n}\nexports.WebGLUtils = WebGLUtils;\n/**\n * Provides requestAnimationFrame in a cross browser\n * way.\n */\nif (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\n                window.setTimeout(callback, 1000 / 60);\n            };\n    })();\n}\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.\n *\n * Cancels an animation frame request.\n * Checks for cross-browser support, falls back to clearTimeout.\n * @param {number}  Animation frame request. */\nif (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\n        window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\n        window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\n        window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\n        window.clearTimeout);\n}\n"],"sourceRoot":""}