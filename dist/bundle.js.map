{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/controllers/CurveSceneController.ts","webpack:///./src/main.ts","webpack:///./src/mathematics/BSpline_R1_to_R1.ts","webpack:///./src/mathematics/BSpline_R1_to_R2.ts","webpack:///./src/mathematics/BSpline_R1_to_R2_DifferentialProperties.ts","webpack:///./src/mathematics/BernsteinDecomposition_R1_to_R1.ts","webpack:///./src/mathematics/BinomialCoefficient.ts","webpack:///./src/mathematics/Piegl_Tiller_NURBS_Book.ts","webpack:///./src/mathematics/Vector_2d.ts","webpack:///./src/models/CurveModel.ts","webpack:///./src/views/ClickButtonView.ts","webpack:///./src/views/ControlPointsShaders.ts","webpack:///./src/views/ControlPointsView.ts","webpack:///./src/views/ControlPolygonShaders.ts","webpack:///./src/views/ControlPolygonView.ts","webpack:///./src/views/CurvatureExtremaShaders.ts","webpack:///./src/views/CurvatureExtremaView.ts","webpack:///./src/views/CurveShaders.ts","webpack:///./src/views/CurveView.ts","webpack:///./src/views/InflectionsView.ts","webpack:///./src/views/InsertKnotButtonShaders.ts","webpack:///./src/webgl/cuon-utils.ts","webpack:///./src/webgl/webgl-utils.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,wDAAsB;AACjD,0BAA0B,mBAAO,CAAC,oEAA4B;AAC9D,6BAA6B,mBAAO,CAAC,0EAA+B;AACpE,8BAA8B,mBAAO,CAAC,4EAAgC;AACtE,2BAA2B,mBAAO,CAAC,sEAA6B;AAChE,qBAAqB,mBAAO,CAAC,0DAAuB;AACpD,kBAAkB,mBAAO,CAAC,oDAAoB;AAC9C,gCAAgC,mBAAO,CAAC,gFAAkC;AAC1E,wBAAwB,mBAAO,CAAC,gEAA0B;AAC1D,gCAAgC,mBAAO,CAAC,gFAAkC;AAC1E,6BAA6B,mBAAO,CAAC,0EAA+B;AACpE,wBAAwB,mBAAO,CAAC,gEAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AClGa;AACb,8CAA8C,cAAc;AAC5D,UAAU,2BAA2B;AACrC,6BAA6B,mBAAO,CAAC,qFAAoC;AACzE,oBAAoB,mBAAO,CAAC,uDAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;ACxGa;AACb,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,6BAA6B;AACxD;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,6BAA6B;AACxD;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC1Na;AACb,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,gCAAgC,mBAAO,CAAC,+EAA2B;AACnE,kBAAkB,mBAAO,CAAC,mDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAmD;AAC1F,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,6BAA6B;AACxD;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Oa;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,iEAAoB;AACrD,wCAAwC,mBAAO,CAAC,+FAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD,2BAA2B,4CAA4C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACrGa;AACb,8CAA8C,cAAc;AAC5D,4BAA4B,mBAAO,CAAC,uEAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AClHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,uCAAuC,UAAU;AACjD;AACA;AACA,yCAAyC;AACzC,2BAA2B,QAAQ;AACnC;AACA,iCAAiC;AACjC,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnJa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC5Ca;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,kBAAkB,mBAAO,CAAC,gEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACtGa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AClJa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,sCAAsC;AACtC,oCAAoC;AACpC,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,uCAAuC;AACvC,mCAAmC;AACnC,qDAAqD;AACrD,cAAc;AACd;AACA,qDAAqD;AACrD,qCAAqC;AACrC,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,yDAAyD;AACzD,mEAAmE;AACnE,oDAAoD;AACpD,mDAAmD;AACnD,oCAAoC;AACpC,oEAAoE;AACpE,oEAAoE;AACpE,6DAA6D;AAC7D,6DAA6D;AAC7D,uDAAuD;AACvD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACtDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC5Ka;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0BAA0B;AAC1B,qDAAqD;AACrD,cAAc;AACd;AACA,4CAA4C;AAC5C,mFAAmF;AACnF,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;AC3Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACtHa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,sCAAsC;AACtC,oCAAoC;AACpC,0BAA0B;AAC1B,uCAAuC;AACvC,qDAAqD;AACrD,cAAc;AACd;AACA,qDAAqD;AACrD,kCAAkC;AAClC,oCAAoC;AACpC,0BAA0B;AAC1B,mEAAmE;AACnE,0CAA0C;AAC1C,yCAAyC;AACzC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACpCa;AACb,8CAA8C,cAAc;AAC5D,UAAU,kDAAkD;AAC5D,UAAU,2BAA2B;AACrC,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,gDAAgD,mBAAO,CAAC,4HAAwD;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACvKa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,0BAA0B;AAC1B,qDAAqD;AACrD,cAAc;AACd;AACA,uDAAuD;AACvD,iCAAiC;AACjC,0BAA0B;AAC1B,uCAAuC;AACvC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;AC7Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACvHa;AACb,8CAA8C,cAAc;AAC5D,UAAU,kDAAkD;AAC5D,UAAU,2BAA2B;AACrC,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,gDAAgD,mBAAO,CAAC,4HAAwD;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACvKa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,sDAAqB;AAChD;AACA;AACA;AACA;AACA,yDAAyD;AACzD,sCAAsC;AACtC,oCAAoC;AACpC,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,uCAAuC;AACvC,mCAAmC;AACnC,qDAAqD;AACrD,cAAc;AACd;AACA,qDAAqD;AACrD,oCAAoC;AACpC,kCAAkC;AAClC,0BAA0B;AAC1B,oEAAoE;AACpE,oEAAoE;AACpE,qEAAqE;AACrE,qEAAqE;AACrE,6DAA6D,EAAE;AAC/D,oHAAoH;AACpH,6DAA6D,EAAE;AAC/D,qHAAqH;AACrH,0DAA0D,EAAE;AAC5D,uHAAuH;AACvH,0DAA0D,EAAE;AAC5D,uHAAuH;AACvH,0DAA0D,EAAE;AAC5D,yHAAyH;AACzH,0DAA0D,EAAE;AAC5D,wBAAwB;AACxB,4DAA4D,EAAE;AAC9D,oDAAoD,EAAE;AACtD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;ACvDa;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,sCAAsC,aAAa,cAAc,gBAAgB,kBAAkB;AACnG;AACA,kDAAkD,aAAa,cAAc;AAC7E;AACA,6CAA6C,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,+BAA+B;AAC9C;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CurveModel_1 = require(\"../models/CurveModel\");\nvar ControlPointsView_1 = require(\"../views/ControlPointsView\");\nvar ControlPointsShaders_1 = require(\"../views/ControlPointsShaders\");\nvar ControlPolygonShaders_1 = require(\"../views/ControlPolygonShaders\");\nvar ControlPolygonView_1 = require(\"../views/ControlPolygonView\");\nvar CurveShaders_1 = require(\"../views/CurveShaders\");\nvar CurveView_1 = require(\"../views/CurveView\");\nvar InsertKnotButtonShaders_1 = require(\"../views/InsertKnotButtonShaders\");\nvar ClickButtonView_1 = require(\"../views/ClickButtonView\");\nvar CurvatureExtremaShaders_1 = require(\"../views/CurvatureExtremaShaders\");\nvar CurvatureExtremaView_1 = require(\"../views/CurvatureExtremaView\");\nvar InflectionsView_1 = require(\"../views/InflectionsView\");\nvar CurveSceneController = /** @class */ (function () {\n    function CurveSceneController(canvas, gl) {\n        this.canvas = canvas;\n        this.gl = gl;\n        this.selectedControlPoint = null;\n        this.dragging = false;\n        this.curveModel = new CurveModel_1.CurveModel();\n        this.controlPointsShaders = new ControlPointsShaders_1.ControlPointsShaders(this.gl);\n        this.controlPointsView = new ControlPointsView_1.ControlPointsView(this.curveModel.spline, this.controlPointsShaders, 1, 1, 1);\n        this.controlPolygonShaders = new ControlPolygonShaders_1.ControlPolygonShaders(this.gl);\n        this.controlPolygonView = new ControlPolygonView_1.ControlPolygonView(this.curveModel.spline, this.controlPolygonShaders, false);\n        this.curveShaders = new CurveShaders_1.CurveShaders(this.gl);\n        this.curveView = new CurveView_1.CurveView(this.curveModel.spline, this.curveShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.insertKnotButtonShaders = new InsertKnotButtonShaders_1.InsertKnotButtonShaders(this.gl);\n        this.insertKnotButtonView = new ClickButtonView_1.ClickButtonView(-0.8, 0.8, this.insertKnotButtonShaders);\n        this.curvatureExtremaShaders = new CurvatureExtremaShaders_1.CurvatureExtremaShaders(this.gl);\n        this.curvatureExtremaView = new CurvatureExtremaView_1.CurvatureExtremaView(this.curveModel.spline, this.curvatureExtremaShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.inflectionsView = new InflectionsView_1.InflectionsView(this.curveModel.spline, this.curvatureExtremaShaders, 216 / 255, 120 / 255, 120 / 255, 1);\n        this.curveModel.registerObserver(this.controlPointsView);\n        this.curveModel.registerObserver(this.controlPolygonView);\n        this.curveModel.registerObserver(this.curveView);\n        this.curveModel.registerObserver(this.curvatureExtremaView);\n        this.curveModel.registerObserver(this.inflectionsView);\n    }\n    CurveSceneController.prototype.renderFrame = function () {\n        var px = 100, size = Math.min(window.innerWidth, window.innerHeight) - px;\n        this.canvas.width = size;\n        this.canvas.height = size;\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clearColor(0.3, 0.3, 0.3, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.curveView.renderFrame();\n        this.curvatureExtremaView.renderFrame();\n        this.inflectionsView.renderFrame();\n        this.controlPolygonView.renderFrame();\n        this.controlPointsView.renderFrame();\n        this.insertKnotButtonView.renderFrame();\n    };\n    CurveSceneController.prototype.toggleOptimizer = function () {\n    };\n    CurveSceneController.prototype.toggleControlOfCurvatureExtrema = function () {\n    };\n    CurveSceneController.prototype.toggleControlOfInflections = function () {\n    };\n    CurveSceneController.prototype.toggleSliding = function () {\n    };\n    CurveSceneController.prototype.leftMouseDown_event = function (ndcX, ndcY, deltaSquared) {\n        if (deltaSquared === void 0) { deltaSquared = 0.01; }\n        if (this.insertKnotButtonView.selected(ndcX, ndcY) && this.selectedControlPoint !== -1) {\n            var cp = this.selectedControlPoint;\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this.curveModel.spline.controlPoints.length - 1) {\n                cp -= 1;\n            }\n            var grevilleAbscissae = this.curveModel.spline.grevilleAbscissae();\n            if (cp != null) {\n                this.curveModel.spline.insertKnot(grevilleAbscissae[cp]);\n                this.curveModel.notifyObservers();\n            }\n        }\n        this.selectedControlPoint = this.controlPointsView.controlPointSelection(ndcX, ndcY, deltaSquared);\n        this.controlPointsView.setSelected(this.selectedControlPoint);\n        if (this.selectedControlPoint !== -1) {\n            this.dragging = true;\n        }\n    };\n    CurveSceneController.prototype.leftMouseDragged_event = function (ndcX, ndcY) {\n        var x = ndcX, y = ndcY, selectedControlPoint = this.controlPointsView.getSelectedControlPoint();\n        if (selectedControlPoint !== -1 && selectedControlPoint != null && this.dragging === true) {\n            this.curveModel.setControlPoint(selectedControlPoint, x, y);\n            this.curveModel.notifyObservers();\n        }\n    };\n    CurveSceneController.prototype.leftMouseUp_event = function () {\n        this.dragging = false;\n    };\n    CurveSceneController.prototype.optimize = function (selectedControlPoint, ndcX, ndcY) {\n    };\n    return CurveSceneController;\n}());\nexports.CurveSceneController = CurveSceneController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//import { OvalCurveSceneController } from \"./controllers/OvalCurveSceneController\"\nvar CurveSceneController_1 = require(\"./controllers/CurveSceneController\");\nvar webgl_utils_1 = require(\"./webgl/webgl-utils\");\nfunction main() {\n    var canvas = document.getElementById(\"webgl\");\n    var toggleButtonCurvatureExtrema = document.getElementById(\"toggleButtonCurvatureExtrema\");\n    var toggleButtonInflection = document.getElementById(\"toggleButtonInflections\");\n    var toggleButtonSliding = document.getElementById(\"toggleButtonSliding\");\n    var gl = webgl_utils_1.WebGLUtils().setupWebGL(canvas);\n    if (!gl) {\n        console.log('Failed to get the rendering context for WebGL');\n        return;\n    }\n    var sceneController = new CurveSceneController_1.CurveSceneController(canvas, gl);\n    // let sceneController = new OvalCurveSceneController(canvas, gl)\n    function mouse_get_NormalizedDeviceCoordinates(event) {\n        var x, y, rect = canvas.getBoundingClientRect(), ev;\n        ev = event;\n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2);\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2);\n        return [x, y];\n    }\n    function touch_get_NormalizedDeviceCoordinates(event) {\n        var x, y, rect = canvas.getBoundingClientRect(), ev;\n        ev = event.touches[0];\n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2);\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2);\n        return [x, y];\n    }\n    //function click(ev, canvas) {\n    function mouse_click(ev) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDown_event(c[0], c[1], 0.0005);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    //function drag(ev, canvas) {\n    function mouse_drag(ev) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDragged_event(c[0], c[1]);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    function mouse_stop_drag(ev) {\n        sceneController.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    //function click(ev, canvas) {\n    function touch_click(ev) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDown_event(c[0], c[1]);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    //function drag(ev, canvas) {\n    function touch_drag(ev) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev);\n        sceneController.leftMouseDragged_event(c[0], c[1]);\n        sceneController.renderFrame();\n        ev.preventDefault();\n    }\n    function touch_stop_drag(ev) {\n        sceneController.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    function toggleControlOfCurvatureExtrema() {\n        sceneController.toggleControlOfCurvatureExtrema();\n    }\n    function toggleControlOfInflections() {\n        sceneController.toggleControlOfInflections();\n    }\n    function toggleSliding() {\n        sceneController.toggleSliding();\n    }\n    canvas.addEventListener('mousedown', mouse_click, false);\n    canvas.addEventListener('mousemove', mouse_drag, false);\n    canvas.addEventListener('mouseup', mouse_stop_drag, false);\n    canvas.addEventListener('touchstart', touch_click, false);\n    canvas.addEventListener('touchmove', touch_drag, false);\n    canvas.addEventListener('touchend', touch_stop_drag, false);\n    toggleButtonCurvatureExtrema.addEventListener('click', toggleControlOfCurvatureExtrema);\n    toggleButtonInflection.addEventListener('click', toggleControlOfInflections);\n    toggleButtonSliding.addEventListener('click', toggleSliding);\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\"touchstart\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchend\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchmove\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    sceneController.renderFrame();\n}\nexports.main = main;\nmain();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Piegl_Tiller_NURBS_Book_2 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Piegl_Tiller_NURBS_Book_3 = require(\"./Piegl_Tiller_NURBS_Book\");\n/**\n * A B-Spline function from a one dimensional real space to a one dimensional real space\n */\nvar BSpline_R1_to_R1 = /** @class */ (function () {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    function BSpline_R1_to_R1(controlPoints, knots) {\n        if (controlPoints === void 0) { controlPoints = [0]; }\n        if (knots === void 0) { knots = [0, 1]; }\n        this._controlPoints = [];\n        this._knots = [];\n        this._degree = 0;\n        this._controlPoints = controlPoints;\n        this._knots = knots;\n        this._degree = this._knots.length - this._controlPoints.length - 1;\n        if (this._degree < 0) {\n            throw new Error(\"Negative degree BSpline_R1_to_R1 are not supported\");\n        }\n    }\n    Object.defineProperty(BSpline_R1_to_R1.prototype, \"controlPoints\", {\n        get: function () {\n            return this._controlPoints;\n        },\n        set: function (controlPoints) {\n            this._controlPoints = controlPoints;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BSpline_R1_to_R1.prototype, \"knots\", {\n        get: function () {\n            return this._knots;\n        },\n        set: function (knots) {\n            this._knots = knots;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BSpline_R1_to_R1.prototype, \"degree\", {\n        get: function () {\n            return this._degree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BSpline_R1_to_R1.prototype.setControlPoint = function (index, value) {\n        this._controlPoints[index] = value;\n    };\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    BSpline_R1_to_R1.prototype.evaluate = function (u) {\n        var span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        var basis = Piegl_Tiller_NURBS_Book_2.basisFunctions(span, u, this._knots, this._degree);\n        var result = 0;\n        for (var i = 0; i < this.degree + 1; i += 1) {\n            result += basis[i] * this._controlPoints[span - this._degree + i];\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.derivative = function () {\n        var newControlPoints = [];\n        var newKnots = [];\n        for (var i = 0; i < this.controlPoints.length - 1; i += 1) {\n            newControlPoints[i] = (this.controlPoints[i + 1] - (this.controlPoints[i])) * (this.degree / (this.knots[i + this.degree + 1] - this.knots[i + 1]));\n        }\n        newKnots = this.knots.slice(1, this.knots.length - 1);\n        return new BSpline_R1_to_R1(newControlPoints, newKnots);\n    };\n    BSpline_R1_to_R1.prototype.bernsteinDecomposition = function () {\n        // Piegl_Tiller_NURBS_BOOK.ts\n        return Piegl_Tiller_NURBS_Book_3.decomposeFunction(this);\n    };\n    BSpline_R1_to_R1.prototype.distinctKnots = function () {\n        var result = [this.knots[0]];\n        var temp = result[0];\n        for (var i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.zeros = function (tolerance) {\n        if (tolerance === void 0) { tolerance = 10e-8; }\n        //see : chapter 11 : Computing Zeros of Splines by Tom Lyche and Knut Morken for u_star method\n        var spline = new BSpline_R1_to_R1(this.controlPoints.slice(), this.knots.slice());\n        var greville = spline.grevilleAbscissae();\n        var maxError = tolerance * 2;\n        var vertexIndex = [];\n        while (maxError > tolerance) {\n            var cpLeft = spline.controlPoints[0];\n            vertexIndex = [];\n            var maximum = 0;\n            for (var index = 1; index < spline.controlPoints.length; index += 1) {\n                var cpRight = spline.controlPoints[index];\n                if (cpLeft <= 0 && cpRight > 0) {\n                    vertexIndex.push(index);\n                }\n                if (cpLeft >= 0 && cpRight < 0) {\n                    vertexIndex.push(index);\n                }\n                cpLeft = cpRight;\n            }\n            for (var i = 0; i < vertexIndex.length; i += 1) {\n                var uLeft = greville[vertexIndex[i] - 1];\n                var uRight = greville[vertexIndex[i]];\n                if (uRight - uLeft > maximum) {\n                    maximum = uRight - uLeft;\n                }\n                if (uRight - uLeft > tolerance) {\n                    spline.insertKnot((uLeft + uRight) / 2);\n                    greville = spline.grevilleAbscissae();\n                }\n            }\n            maxError = maximum;\n        }\n        var result = [];\n        for (var i = 0; i < vertexIndex.length; i += 1) {\n            result.push(greville[vertexIndex[i]]);\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.grevilleAbscissae = function () {\n        var result = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var sum = 0;\n            for (var j = i + 1; j < i + this.degree + 1; j += 1) {\n                sum += this.knots[j];\n            }\n            result.push(sum / this.degree);\n        }\n        return result;\n    };\n    BSpline_R1_to_R1.prototype.insertKnot = function (u, times) {\n        if (times === void 0) { times = 1; }\n        if (times <= 0) {\n            return;\n        }\n        var index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this.knots, this.degree);\n        var multiplicity = 0;\n        var newControlPoints = [];\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (var t = 0; t < times; t += 1) {\n            for (var i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (var i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                var alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = this.controlPoints[i - 1] * (1 - alpha) + this.controlPoints[i] * alpha;\n            }\n            for (var i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this.knots.splice(index + 1, 0, u);\n            this.controlPoints = newControlPoints.slice();\n        }\n    };\n    BSpline_R1_to_R1.prototype.knotMultiplicity = function (indexFromFindSpan) {\n        var result = 0;\n        var i = 0;\n        while (this.knots[indexFromFindSpan + i] === this.knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    };\n    /**\n     * Return a deep copy of this b-spline\n     */\n    BSpline_R1_to_R1.prototype.clone = function () {\n        return new BSpline_R1_to_R1(this.controlPoints.slice(), this.knots.slice());\n    };\n    BSpline_R1_to_R1.prototype.clamp = function (u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        var index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this.knots, this.degree);\n        var newControlPoints = [];\n        var multiplicity = 0;\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        var times = this.degree - multiplicity + 1;\n        for (var t = 0; t < times; t += 1) {\n            for (var i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (var i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                var alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = this.controlPoints[i - 1] * (1 - alpha) + this.controlPoints[i] * alpha;\n            }\n            for (var i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this.knots.splice(index + 1, 0, u);\n            this.controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    };\n    return BSpline_R1_to_R1;\n}());\nexports.BSpline_R1_to_R1 = BSpline_R1_to_R1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Piegl_Tiller_NURBS_Book_2 = require(\"./Piegl_Tiller_NURBS_Book\");\nvar Vector_2d_1 = require(\"./Vector_2d\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nvar BSpline_R1_to_R2 = /** @class */ (function () {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    function BSpline_R1_to_R2(controlPoints, knots) {\n        if (controlPoints === void 0) { controlPoints = [new Vector_2d_1.Vector_2d(0, 0)]; }\n        if (knots === void 0) { knots = [0, 1]; }\n        this._controlPoints = [];\n        this._knots = [];\n        this._degree = 0;\n        this._controlPoints = controlPoints;\n        this._knots = knots;\n        this._degree = this._knots.length - this._controlPoints.length - 1;\n        if (this._degree < 0) {\n            throw new Error(\"Negative degree BSpline_R1_to_R2 are not supported\");\n        }\n    }\n    Object.defineProperty(BSpline_R1_to_R2.prototype, \"controlPoints\", {\n        get: function () {\n            return this._controlPoints;\n        },\n        set: function (controlPoints) {\n            this._controlPoints = controlPoints;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BSpline_R1_to_R2.prototype.visibleControlPoints = function () {\n        return this.controlPoints;\n    };\n    Object.defineProperty(BSpline_R1_to_R2.prototype, \"knots\", {\n        get: function () {\n            return this._knots;\n        },\n        set: function (knots) {\n            this._knots = knots;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BSpline_R1_to_R2.prototype, \"degree\", {\n        get: function () {\n            return this._degree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BSpline_R1_to_R2.prototype.setControlPoint = function (index, value) {\n        this._controlPoints[index] = value;\n    };\n    BSpline_R1_to_R2.prototype.setControlPoints = function (controlPoints) {\n        this.controlPoints = controlPoints;\n    };\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    BSpline_R1_to_R2.prototype.evaluate = function (u) {\n        var span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        var basis = Piegl_Tiller_NURBS_Book_2.basisFunctions(span, u, this._knots, this._degree);\n        var result = new Vector_2d_1.Vector_2d(0, 0);\n        for (var i = 0; i < this.degree + 1; i += 1) {\n            result.x += basis[i] * this._controlPoints[span - this._degree + i].x;\n            result.y += basis[i] * this._controlPoints[span - this._degree + i].y;\n        }\n        return result;\n    };\n    /**\n     * Return a deep copy of this b-spline\n     */\n    BSpline_R1_to_R2.prototype.clone = function () {\n        var cloneControlPoints = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            cloneControlPoints.push(new Vector_2d_1.Vector_2d(this.controlPoints[i].x, this.controlPoints[i].y));\n        }\n        return new BSpline_R1_to_R2(cloneControlPoints, this.knots.slice());\n    };\n    BSpline_R1_to_R2.prototype.optimizerStep = function (step) {\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            this.controlPoints[i].x += step[i];\n            this.controlPoints[i].y += step[i + this.controlPoints.length];\n        }\n    };\n    BSpline_R1_to_R2.prototype.getControlPointsX = function () {\n        var result = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            result.push(this.controlPoints[i].x);\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.getControlPointsY = function () {\n        var result = [];\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            result.push(this.controlPoints[i].y);\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.distinctKnots = function () {\n        var result = [this.knots[0]];\n        var temp = result[0];\n        for (var i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.moveControlPoint = function (i, deltaX, deltaY) {\n        if (i < 0 || i >= this.controlPoints.length - this.degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        this.controlPoints[i].x += deltaX;\n        this.controlPoints[i].y += deltaY;\n    };\n    BSpline_R1_to_R2.prototype.insertKnot = function (u, times) {\n        if (times === void 0) { times = 1; }\n        // Piegl and Tiller, The NURBS book, p: 151\n        if (times <= 0) {\n            return;\n        }\n        var index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this.knots, this.degree), multiplicity = 0, i = 0, t = 0, newControlPoints, alpha = 0;\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (t = 0; t < times; t += 1) {\n            newControlPoints = [];\n            for (i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = (this.controlPoints[i - 1].multiply(1 - alpha)).add(this.controlPoints[i].multiply(alpha));\n            }\n            for (i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    };\n    BSpline_R1_to_R2.prototype.knotMultiplicity = function (indexFromFindSpan) {\n        var result = 0, i = 0;\n        while (this.knots[indexFromFindSpan + i] === this.knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.grevilleAbscissae = function () {\n        var result = [], i, j, sum;\n        for (i = 0; i < this.controlPoints.length; i += 1) {\n            sum = 0;\n            for (j = i + 1; j < i + this.degree + 1; j += 1) {\n                sum += this.knots[j];\n            }\n            result.push(sum / this.degree);\n        }\n        return result;\n    };\n    BSpline_R1_to_R2.prototype.clamp = function (u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        var index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this.knots, this.degree);\n        var newControlPoints = [];\n        var multiplicity = 0;\n        if (u === this.knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        var times = this.degree - multiplicity + 1;\n        for (var t = 0; t < times; t += 1) {\n            for (var i = 0; i < index - this.degree + 1; i += 1) {\n                newControlPoints[i] = this.controlPoints[i];\n            }\n            for (var i = index - this.degree + 1; i <= index - multiplicity; i += 1) {\n                var alpha = (u - this.knots[i]) / (this.knots[i + this.degree] - this.knots[i]);\n                newControlPoints[i] = (this.controlPoints[i - 1].multiply(1 - alpha)).add(this.controlPoints[i].multiply(alpha));\n            }\n            for (var i = index - multiplicity; i < this.controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this.controlPoints[i];\n            }\n            this.knots.splice(index + 1, 0, u);\n            this.controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    };\n    /**\n     *\n     * @param from Parametric position where the section start\n     * @param to Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    BSpline_R1_to_R2.prototype.section = function (from, to) {\n        var spline = this.clone();\n        spline.clamp(from);\n        spline.clamp(to);\n        //const newFromSpan = findSpan(from, spline._knots, spline._degree)\n        //const newToSpan = findSpan(to, spline._knots, spline._degree)\n        var newFromSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(from, spline._knots, spline._degree);\n        var newToSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(to, spline._knots, spline._degree);\n        var newKnots = [];\n        var newControlPoints = [];\n        for (var i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (var i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector_2d_1.Vector_2d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSpline_R1_to_R2(newControlPoints, newKnots);\n    };\n    return BSpline_R1_to_R2;\n}());\nexports.BSpline_R1_to_R2 = BSpline_R1_to_R2;\nfunction create_BSpline_R1_to_R2(controlPoints, knots) {\n    var newControlPoints = [];\n    for (var i = 0, n = controlPoints.length; i < n; i += 1) {\n        newControlPoints.push(new Vector_2d_1.Vector_2d(controlPoints[i][0], controlPoints[i][1]));\n    }\n    return new BSpline_R1_to_R2(newControlPoints, knots);\n}\nexports.create_BSpline_R1_to_R2 = create_BSpline_R1_to_R2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BSpline_R1_to_R1_1 = require(\"./BSpline_R1_to_R1\");\nvar BernsteinDecomposition_R1_to_R1_1 = require(\"./BernsteinDecomposition_R1_to_R1\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nvar BSpline_R1_to_R2_DifferentialProperties = /** @class */ (function () {\n    function BSpline_R1_to_R2_DifferentialProperties(spline) {\n        this.spline = spline;\n    }\n    BSpline_R1_to_R2_DifferentialProperties.prototype.expensiveComputation = function (spline) {\n        var sx = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(spline.getControlPointsX(), spline.knots);\n        var sy = new BSpline_R1_to_R1_1.BSpline_R1_to_R1(spline.getControlPointsY(), spline.knots);\n        var sxu = sx.derivative();\n        var syu = sy.derivative();\n        var sxuu = sxu.derivative();\n        var syuu = syu.derivative();\n        var sxuuu = sxuu.derivative();\n        var syuuu = syuu.derivative();\n        var bdsxu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxu.bernsteinDecomposition());\n        var bdsyu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syu.bernsteinDecomposition());\n        var bdsxuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxuu.bernsteinDecomposition());\n        var bdsyuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syuu.bernsteinDecomposition());\n        var bdsxuuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(sxuuu.bernsteinDecomposition());\n        var bdsyuuu = new BernsteinDecomposition_R1_to_R1_1.BernsteinDecomposition_R1_to_R1(syuuu.bernsteinDecomposition());\n        var h1 = (bdsxu.multiply(bdsxu)).add((bdsyu.multiply(bdsyu)));\n        var h2 = (bdsxu.multiply(bdsyuuu)).subtract((bdsyu.multiply(bdsxuuu)));\n        var h3 = (bdsxu.multiply(bdsxuu)).add((bdsyu.multiply(bdsyuu)));\n        var h4 = (bdsxu.multiply(bdsyuu)).subtract((bdsyu.multiply(bdsxuu)));\n        return {\n            h1: h1,\n            h2: h2,\n            h3: h3,\n            h4: h4\n        };\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.curvatureNumerator = function () {\n        var e = this.expensiveComputation(this.spline);\n        var distinctKnots = this.spline.distinctKnots();\n        var controlPoints = e.h4.flattenControlPointsArray();\n        var curvatureNumeratorDegree = 2 * this.spline.degree - 3;\n        var knots = [];\n        for (var i = 0; i < distinctKnots.length; i += 1) {\n            for (var j = 0; j < curvatureNumeratorDegree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSpline_R1_to_R1_1.BSpline_R1_to_R1(controlPoints, knots);\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.h1 = function () {\n        var e = this.expensiveComputation(this.spline);\n        var distinctKnots = this.spline.distinctKnots();\n        var controlPoints = e.h1.flattenControlPointsArray();\n        var h1Degree = 2 * this.spline.degree - 2;\n        var knots = [];\n        for (var i = 0; i < distinctKnots.length; i += 1) {\n            for (var j = 0; j < h1Degree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSpline_R1_to_R1_1.BSpline_R1_to_R1(controlPoints, knots);\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.inflections = function (curvatureNumerator) {\n        if (!curvatureNumerator) {\n            curvatureNumerator = this.curvatureNumerator();\n        }\n        var zeros = curvatureNumerator.zeros();\n        var result = [];\n        for (var i = 0; i < zeros.length; i += 1) {\n            result.push(this.spline.evaluate(zeros[i]));\n        }\n        return result;\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.curvatureDerivativeNumerator = function () {\n        var e = this.expensiveComputation(this.spline);\n        var bd_curvatureDerivativeNumerator = (e.h1.multiply(e.h2)).subtract(e.h3.multiply(e.h4).multiplyByScalar(3));\n        var distinctKnots = this.spline.distinctKnots();\n        var controlPoints = bd_curvatureDerivativeNumerator.flattenControlPointsArray();\n        var curvatureDerivativeNumeratorDegree = 4 * this.spline.degree - 6;\n        var knots = [];\n        for (var i = 0; i < distinctKnots.length; i += 1) {\n            for (var j = 0; j < curvatureDerivativeNumeratorDegree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSpline_R1_to_R1_1.BSpline_R1_to_R1(controlPoints, knots);\n    };\n    BSpline_R1_to_R2_DifferentialProperties.prototype.curvatureExtrema = function (curvatureDerivativeNumerator) {\n        if (!curvatureDerivativeNumerator) {\n            curvatureDerivativeNumerator = this.curvatureDerivativeNumerator();\n        }\n        var zeros = curvatureDerivativeNumerator.zeros();\n        var result = [];\n        for (var i = 0; i < zeros.length; i += 1) {\n            result.push(this.spline.evaluate(zeros[i]));\n        }\n        return result;\n    };\n    return BSpline_R1_to_R2_DifferentialProperties;\n}());\nexports.BSpline_R1_to_R2_DifferentialProperties = BSpline_R1_to_R2_DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BinomialCoefficient_1 = require(\"./BinomialCoefficient\");\n/**\n* A Bernstein decomposition of a B-Spline function from a one dimensional real space to a one dimensional real space\n*/\nvar BernsteinDecomposition_R1_to_R1 = /** @class */ (function () {\n    /**\n     *\n     * @param controlPointsArray An array of array of control points\n     */\n    function BernsteinDecomposition_R1_to_R1(controlPointsArray) {\n        this.controlPointsArray = controlPointsArray;\n    }\n    BernsteinDecomposition_R1_to_R1.prototype.add = function (bd) {\n        var result = [];\n        for (var i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (var j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] + bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.subtract = function (bd) {\n        var result = [];\n        for (var i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (var j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] - bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.multiply = function (bd) {\n        return new BernsteinDecomposition_R1_to_R1(this.bernsteinMultiplicationArray(this.controlPointsArray, bd.controlPointsArray));\n    };\n    /**\n     *\n     * @param bd: BernsteinDecomposition_R1_to_R1\n     * @param index: Index of the basis function\n     */\n    BernsteinDecomposition_R1_to_R1.prototype.multiplyRange = function (bd, start, lessThan) {\n        var result = [];\n        for (var i = start; i < lessThan; i += 1) {\n            result[i - start] = this.bernsteinMultiplication(this.controlPointsArray[i], bd.controlPointsArray[i]);\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.bernsteinMultiplicationArray = function (f, g) {\n        var result = [];\n        for (var i = 0; i < f.length; i += 1) {\n            result[i] = this.bernsteinMultiplication(f[i], g[i]);\n        }\n        return result;\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.bernsteinMultiplication = function (f, g) {\n        var f_degree = f.length - 1;\n        var g_degree = g.length - 1;\n        var result = [];\n        /*\n        for (let k = 0; k < f_degree + g_degree + 1; k += 1) {\n            let cp = 0;\n            for (let i = Math.max(0, k - g_degree); i < Math.min(f_degree, k) + 1; i += 1) {\n                let bfu = binomialCoefficient(f_degree, i);\n                let bgu = binomialCoefficient(g_degree, k - i);\n                let bfugu = binomialCoefficient(f_degree + g_degree, k);\n                cp += bfu * bgu / bfugu * f[i] * g[k - i];\n            }\n            result[k] = cp;\n        }\n        */\n        /*\n        BernsteinDecomposition_R1_to_R1.flopsCounter += 1\n        if (BernsteinDecomposition_R1_to_R1.flopsCounter % 1000 === 0) {\n          //console.log(\"Bernstein Multiplication\")\n          //console.log(BernsteinDecomposition_R1_to_R1.flopsCounter)\n        }\n        */\n        for (var k = 0; k < f_degree + g_degree + 1; k += 1) {\n            var cp = 0;\n            for (var i = Math.max(0, k - g_degree); i < Math.min(f_degree, k) + 1; i += 1) {\n                var bfu = BernsteinDecomposition_R1_to_R1.binomial(f_degree, i);\n                var bgu = BernsteinDecomposition_R1_to_R1.binomial(g_degree, k - i);\n                var bfugu = BernsteinDecomposition_R1_to_R1.binomial(f_degree + g_degree, k);\n                cp += bfu * bgu / bfugu * f[i] * g[k - i];\n            }\n            result[k] = cp;\n        }\n        return result;\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.multiplyByScalar = function (value) {\n        var result = [];\n        for (var i = 0; i < this.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (var j = 0; j < this.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] * value;\n            }\n        }\n        return new BernsteinDecomposition_R1_to_R1(result);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.flattenControlPointsArray = function () {\n        //return this.controlPointsArray.flat();\n        return this.controlPointsArray.reduce(function (acc, val) {\n            return acc.concat(val);\n        }, []);\n    };\n    BernsteinDecomposition_R1_to_R1.prototype.subset = function (start, lessThan) {\n        return new BernsteinDecomposition_R1_to_R1(this.controlPointsArray.slice(start, lessThan));\n    };\n    BernsteinDecomposition_R1_to_R1.binomial = BinomialCoefficient_1.memoizedBinomialCoefficient();\n    BernsteinDecomposition_R1_to_R1.flopsCounter = 0;\n    return BernsteinDecomposition_R1_to_R1;\n}());\nexports.BernsteinDecomposition_R1_to_R1 = BernsteinDecomposition_R1_to_R1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction binomialCoefficient(n, k) {\n    var result = 1;\n    if (n < k || k < 0) {\n        return 0;\n    }\n    // take advantage of symmetry\n    if (k > n - k) {\n        k = n - k;\n    }\n    for (var x = n - k + 1; x <= n; x += 1) {\n        result *= x;\n    }\n    for (var x = 1; x <= k; x += 1) {\n        result /= x;\n    }\n    return result;\n}\nexports.binomialCoefficient = binomialCoefficient;\n;\nfunction memoizedBinomialCoefficient() {\n    var cache = [];\n    return function (n, k) {\n        if (cache[n] !== undefined && cache[n][k] !== undefined) {\n            return cache[n][k];\n        }\n        else {\n            if (cache[n] === undefined) {\n                cache[n] = [];\n            }\n            var result = binomialCoefficient(n, k);\n            cache[n][k] = result;\n            return result;\n        }\n    };\n}\nexports.memoizedBinomialCoefficient = memoizedBinomialCoefficient;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i] ≤ u < knots[i+1]\n */\nfunction findSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        console.log(u);\n        console.log(knots);\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 2;\n    }\n    // Do binary search\n    var low = degree;\n    var high = knots.length - 1 - degree;\n    var i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.findSpan = findSpan;\n/**\n * Returns the span index used for clamping a periodic B-Spline\n * Note: The only difference with findSpan is the for the special case u = knots[-degree - 1]\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i] ≤ u < knots[i+1]\n */\nfunction clampingFindSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 1;\n    }\n    // Do binary search\n    var low = degree;\n    var high = knots.length - 1 - degree;\n    var i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.clampingFindSpan = clampingFindSpan;\n/**\n * Returns the basis functions values\n * @param span span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns the array of values evaluated at u\n */\nfunction basisFunctions(span, u, knots, degree) {\n    // Bibliographic reference : The NURBS BOOK, p.70\n    var result = [1];\n    var left = [];\n    var right = [];\n    for (var j = 1; j <= degree; j += 1) {\n        left[j] = u - knots[span + 1 - j];\n        right[j] = knots[span + j] - u;\n        var saved = 0.0;\n        for (var r = 0; r < j; r += 1) {\n            var temp = result[r] / (right[r + 1] + left[j - r]);\n            result[r] = saved + right[r + 1] * temp;\n            saved = left[j - r] * temp;\n        }\n        result[j] = saved;\n    }\n    return result;\n}\nexports.basisFunctions = basisFunctions;\nfunction decomposeFunction(spline) {\n    //Piegl and Tiller, The NURBS book, p.173\n    var result = [];\n    var number_of_bezier_segments = spline.distinctKnots().length - 1;\n    for (var i = 0; i < number_of_bezier_segments; i += 1) {\n        result.push([]);\n    }\n    for (var i = 0; i <= spline.degree; i += 1) {\n        result[0][i] = spline.controlPoints[i];\n    }\n    var a = spline.degree;\n    var b = spline.degree + 1;\n    var bezier_segment = 0;\n    var alphas = [];\n    while (b < spline.knots.length - 1) {\n        var i = b;\n        while (b < spline.knots.length - 1 && spline.knots[b + 1] === spline.knots[b]) {\n            b += 1;\n        }\n        var mult = b - i + 1;\n        if (mult < spline.degree) {\n            var numer = spline.knots[b] - spline.knots[a]; // Numerator of alpha\n            // Compute and store alphas\n            for (var j = spline.degree; j > mult; j -= 1) {\n                alphas[j - mult - 1] = numer / (spline.knots[a + j] - spline.knots[a]);\n            }\n            var r = spline.degree - mult; // insert knot r times\n            for (var j = 1; j <= r; j += 1) {\n                var save = r - j;\n                var s = mult + j; // this many new controlPoints\n                for (var k = spline.degree; k >= s; k -= 1) {\n                    var alpha = alphas[k - s];\n                    result[bezier_segment][k] = (result[bezier_segment][k] * alpha) + (result[bezier_segment][k - 1] * (1 - alpha));\n                }\n                if (b < spline.knots.length) {\n                    result[bezier_segment + 1][save] = result[bezier_segment][spline.degree]; // next segment\n                }\n            }\n        }\n        bezier_segment += 1; // Bezier segment completed\n        if (b < spline.knots.length - 1) {\n            //initialize next bezier bezier_segment\n            for (i = Math.max(0, spline.degree - mult); i <= spline.degree; i += 1) {\n                result[bezier_segment][i] = spline.controlPoints[b - spline.degree + i];\n            }\n            a = b;\n            b += 1;\n        }\n    }\n    return result;\n}\nexports.decomposeFunction = decomposeFunction;\n","\"use strict\";\n/**\n * A two dimensional vector\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Vector_2d = /** @class */ (function () {\n    function Vector_2d(x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.x = x;\n        this.y = y;\n    }\n    Vector_2d.prototype.negative = function () {\n        return new Vector_2d(-this.x, -this.y);\n    };\n    Vector_2d.prototype.add = function (v) {\n        return new Vector_2d(this.x + v.x, this.y + v.y);\n    };\n    Vector_2d.prototype.multiply = function (value) {\n        return new Vector_2d(this.x * value, this.y * value);\n    };\n    Vector_2d.prototype.substract = function (v) {\n        return new Vector_2d(this.x - v.x, this.y - v.y);\n    };\n    Vector_2d.prototype.rotate90degrees = function () {\n        return new Vector_2d(-this.y, this.x);\n    };\n    Vector_2d.prototype.normalize = function () {\n        var x, y, norm;\n        norm = Math.sqrt(this.x * this.x + this.y * this.y);\n        x = this.x / norm;\n        y = this.y / norm;\n        return new Vector_2d(x, y);\n    };\n    Vector_2d.prototype.dot = function (v) {\n        'use strict';\n        return this.x * v.x + this.y * v.y;\n    };\n    Vector_2d.prototype.distance = function (v) {\n        'use strict';\n        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\n    };\n    return Vector_2d;\n}());\nexports.Vector_2d = Vector_2d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BSpline_R1_to_R2_1 = require(\"../mathematics/BSpline_R1_to_R2\");\nvar Vector_2d_1 = require(\"../mathematics/Vector_2d\");\nvar CurveModel = /** @class */ (function () {\n    function CurveModel() {\n        //private target: PeriodicBSpline_R1_to_R2\n        this.observers = [];\n        //const cp = [ [-0.5, 0.5], [-0.25, -0.4], [0.25, 0.0], [0.5, -0.5] ]\n        var deltay = -0.3;\n        var cp = [[-0.5, 0.2 + deltay], [-0.25, 0 + deltay], [0.25, 0.1 + deltay], [0.5, 0.6 + deltay]];\n        var knots = [0, 0, 0, 0, 1, 1, 1, 1];\n        this.spline = BSpline_R1_to_R2_1.create_BSpline_R1_to_R2(cp, knots);\n        //this.spline.insertKnot(0.1)\n        //this.spline.insertKnot(0.2)\n        //this.spline.insertKnot(1/3)\n        //this.spline.insertKnot(0.4)\n        //this.spline.insertKnot(0.5)\n        //this.spline.insertKnot(2/3)\n        //this.spline.insertKnot(0.7)\n        //this.spline.insertKnot(0.8)\n        //this.spline.insertKnot(0.9)\n        /*\n               const cp = [ [-0.5, 0.5], [-0.35, 0.4], [-0.2, 0], [0.2, 0], [0.35, 0.4], [0.5, 0.5] ]\n               const knots = [0, 0, 0, 0, 0, 0,  1, 1, 1, 1, 1, 1]\n               this.spline = create_BSpline_R1_to_R2(cp, knots)\n        */\n        /*\n               const cp = [ [-0.5, 0.5], [-0.35, 0.4], [0, 0], [0.35, 0.4], [0.5, 0.5] ]\n               const knots = [0, 0, 0, 0, 0,  1, 1, 1, 1, 1]\n               this.spline = create_BSpline_R1_to_R2(cp, knots)\n        */\n        //this.spline.insertKnot(0.1)\n        //this.spline.insertKnot(0.2)\n        //this.spline.insertKnot(0.3)\n        //this.spline.insertKnot(0.4)\n        //this.spline.insertKnot(0.5)\n        //this.spline.insertKnot(0.6)\n        //this.spline.insertKnot(0.7)\n        //this.spline.insertKnot(0.8)\n        //this.spline.insertKnot(0.9)\n        /*\n        const cp = [ [-0.5, 0.5], [-0.35, 0.4], [-0.2, 0], [0.2, 0], [0.35, 0.4] ]\n        const knots = [0, 0, 0, 0, 0,  1, 1, 1, 1, 1]\n        this.spline = create_BSpline_R1_to_R2(cp, knots)\n         */\n        /*\n        let knots = [0, 0, 0, 0]\n        const n = 20\n        for (let i = 1; i < n; i += 1) {\n            knots.push(i/n)\n        }\n        knots.push(1)\n        knots.push(1)\n        knots.push(1)\n        knots.push(1)\n        const cp = [ [0.975, 0.248], [0.902, 0.294], [0.876, 0.397], [0.773, 0.466], [0.775, 0.486], [0.822, 0.517], [0.819, 0.535], [0.795, 0.543], [0.788, 0.559], [0.846, 0.572], [0.793, 0.589], [0.792, 0.603], [0.807, 0.613], [0.831, 0.626], [0.801, 0.660], [0.800, 0.699], [0.819, 0.724], [0.863, 0.736], [0.917, 0.720], [0.958, 0.753], [0.943, 0.814], [0.988, 0.873], [0.995, 0.943] ]\n\n        for (let i = 0; i < cp.length; i += 1) {\n            cp[i][0] -= 0.9\n            cp[i][1] -= 0.6\n        }\n\n        for (let i = 0; i < cp.length; i += 1) {\n            cp[i][0] = cp[i][0] * 2.5\n            cp[i][1] = -cp[i][1] * 2.5\n        }\n\n        this.spline = create_BSpline_R1_to_R2(cp, knots)\n        */\n    }\n    CurveModel.prototype.registerObserver = function (observer) {\n        this.observers.push(observer);\n    };\n    CurveModel.prototype.removeObserver = function (observer) {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    };\n    CurveModel.prototype.notifyObservers = function () {\n        for (var i = 0; i < this.observers.length; i += 1) {\n            this.observers[i].update(this.spline);\n        }\n    };\n    CurveModel.prototype.moveControlPoint = function (controlPointIndex, deltaX, deltaY) {\n        this.spline.moveControlPoint(controlPointIndex, deltaX, deltaY);\n        if (deltaX * deltaX + deltaY * deltaY > 0) {\n            this.notifyObservers();\n        }\n    };\n    CurveModel.prototype.setControlPoint = function (controlPointIndex, x, y) {\n        this.spline.setControlPoint(controlPointIndex, new Vector_2d_1.Vector_2d(x, y));\n        //this.notifyObservers()\n    };\n    CurveModel.prototype.setControlPoints = function (controlPoints) {\n        this.spline.setControlPoints(controlPoints);\n        //this.notifyObservers()\n    };\n    CurveModel.prototype.setSpline = function (spline) {\n        this.spline = spline;\n        this.notifyObservers();\n    };\n    return CurveModel;\n}());\nexports.CurveModel = CurveModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClickButtonView = /** @class */ (function () {\n    function ClickButtonView(x, y, clickButtonShaders) {\n        this.x = x;\n        this.y = y;\n        this.clickButtonShaders = clickButtonShaders;\n        this.red = 0.5;\n        this.green = 0.5;\n        this.blue = 0.5;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        var check = this.initVertexBuffers(this.clickButtonShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    ClickButtonView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.05;\n        var ratio = 1.5;\n        this.vertices = new Float32Array(4 * 8);\n        this.indices = new Uint8Array(2 * 3);\n        this.vertices[0] = this.x - size * ratio;\n        this.vertices[1] = this.y - size;\n        this.vertices[2] = this.z;\n        this.vertices[3] = -ratio;\n        this.vertices[4] = -1;\n        this.vertices[5] = this.red;\n        this.vertices[6] = this.green;\n        this.vertices[7] = this.blue;\n        this.vertices[8] = this.x + size * ratio;\n        this.vertices[9] = this.y - size;\n        this.vertices[10] = this.z;\n        this.vertices[11] = ratio;\n        this.vertices[12] = -1;\n        this.vertices[13] = this.red;\n        this.vertices[14] = this.green;\n        this.vertices[15] = this.blue;\n        this.vertices[16] = this.x + size * ratio;\n        this.vertices[17] = this.y + size;\n        this.vertices[18] = this.z;\n        this.vertices[19] = ratio;\n        this.vertices[20] = 1;\n        this.vertices[21] = this.red;\n        this.vertices[22] = this.green;\n        this.vertices[23] = this.blue;\n        this.vertices[24] = this.x - size * ratio;\n        this.vertices[25] = this.y + size;\n        this.vertices[26] = this.z;\n        this.vertices[27] = -ratio;\n        this.vertices[28] = 1;\n        this.vertices[29] = this.red;\n        this.vertices[30] = this.green;\n        this.vertices[31] = this.blue;\n        this.indices[0] = 0;\n        this.indices[1] = 1;\n        this.indices[2] = 2;\n        this.indices[3] = 0;\n        this.indices[4] = 2;\n        this.indices[5] = 3;\n    };\n    ClickButtonView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    ClickButtonView.prototype.renderFrame = function () {\n        var gl = this.clickButtonShaders.gl, a_Position = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.clickButtonShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.clickButtonShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        this.clickButtonShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    ClickButtonView.prototype.selected = function (x, y) {\n        var deltaSquared = 0.01;\n        var result = false;\n        if (Math.pow(x - this.x, 2) + Math.pow(y - this.y, 2) < deltaSquared) {\n            result = true;\n        }\n        return result;\n    };\n    ClickButtonView.prototype.updateBuffers = function () {\n        var gl = this.clickButtonShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return ClickButtonView;\n}());\nexports.ClickButtonView = ClickButtonView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar ControlPointsShaders = /** @class */ (function () {\n    function ControlPointsShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    v_Color = a_Color; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            '//uniform bool selected; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '     vec4 fColor = vec4(0.1, 0.1, 0.1, 0.0); \\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     vec4 color1 = vec4(v_Color, 0.35); \\n' +\n            '     vec4 color2 = vec4(v_Color, 0.9); \\n' +\n            '     float delta = 0.1; \\n' +\n            '     float alpha1 = smoothstep(0.35-delta, 0.35, dist); \\n' +\n            '     float alpha2 = smoothstep(0.65-delta, 0.65, dist); \\n' +\n            '     vec4 fColor1 = mix(color1, fColor, alpha1); \\n' +\n            '     vec4 fColor2 = mix(color2, fColor, alpha2); \\n' +\n            '     gl_FragColor = (fColor1+fColor2)/2.0; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    ControlPointsShaders.prototype.renderFrame = function (numberOfElements, selectedControlPoint) {\n        //const False = 0\n        //const True = 1\n        if (this.program) {\n            //this.gl.uniform1i(this.gl.getUniformLocation(this.program, \"selected\"), False);\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n            if (selectedControlPoint != -1 && selectedControlPoint !== null) {\n                //this.gl.uniform1i(this.gl.getUniformLocation(this.program, \"selected\"), True);\n                this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_BYTE, selectedControlPoint * 6);\n            }\n        }\n    };\n    return ControlPointsShaders;\n}());\nexports.ControlPointsShaders = ControlPointsShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ControlPointsView = /** @class */ (function () {\n    function ControlPointsView(spline, controlPointsShaders, red, blue, green) {\n        this.spline = spline;\n        this.controlPointsShaders = controlPointsShaders;\n        this.red = red;\n        this.blue = blue;\n        this.green = green;\n        this.z = 0;\n        this.selectedControlPoint = null;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.controlPointsShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    ControlPointsView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.03;\n        //const size = 0.05\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var x = this.controlPoints[i].x;\n            var y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    ControlPointsView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    ControlPointsView.prototype.renderFrame = function () {\n        var gl = this.controlPointsShaders.gl, a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.controlPointsShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        this.controlPointsShaders.renderFrame(this.indices.length, this.selectedControlPoint);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    ControlPointsView.prototype.controlPointSelection = function (x, y, deltaSquared) {\n        if (deltaSquared === void 0) { deltaSquared = 0.01; }\n        //const deltaSquared = 0.01\n        //const deltaSquared = 0.001\n        var result = -1;\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            if (Math.pow(x - this.controlPoints[i].x, 2) + Math.pow(y - this.controlPoints[i].y, 2) < deltaSquared) {\n                return i;\n            }\n        }\n        return result;\n    };\n    ControlPointsView.prototype.update = function (spline) {\n        this.controlPoints = spline.visibleControlPoints();\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    };\n    ControlPointsView.prototype.updatePoints = function (points) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    };\n    ControlPointsView.prototype.updateBuffers = function () {\n        var gl = this.controlPointsShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    ControlPointsView.prototype.getSelectedControlPoint = function () {\n        return this.selectedControlPoint;\n    };\n    ControlPointsView.prototype.setSelected = function (controlPointIndex) {\n        this.selectedControlPoint = controlPointIndex;\n    };\n    return ControlPointsView;\n}());\nexports.ControlPointsView = ControlPointsView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar ControlPolygonShaders = /** @class */ (function () {\n    function ControlPolygonShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'void main() {\\n' +\n            '     gl_FragColor = vec4(216.0/255.0, 216.0/255.0, 216.0/255.0, 0.05); \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    ControlPolygonShaders.prototype.renderFrame = function (numberOfElements) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n    };\n    return ControlPolygonShaders;\n}());\nexports.ControlPolygonShaders = ControlPolygonShaders;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ControlPolygonView = /** @class */ (function () {\n    function ControlPolygonView(spline, controlPolygonShaders, closed) {\n        if (closed === void 0) { closed = false; }\n        this.spline = spline;\n        this.controlPolygonShaders = controlPolygonShaders;\n        this.closed = closed;\n        this.z = 0;\n        this.selectedControlPoint = null;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.controlPolygonShaders = controlPolygonShaders;\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.controlPolygonShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    ControlPolygonView.prototype.updateVerticesAndIndices = function () {\n        var thickness = 0.003;\n        //const thickness = 0.0075\n        //const thickness = 0.006\n        this.vertices = new Float32Array(this.controlPoints.length * 12);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length - 1; i += 1) {\n            var normal = this.controlPoints[i + 1].substract(this.controlPoints[i]).normalize().rotate90degrees();\n            this.vertices[12 * i] = this.controlPoints[i].x - thickness * normal.x;\n            this.vertices[12 * i + 1] = this.controlPoints[i].y - thickness * normal.y;\n            this.vertices[12 * i + 2] = this.z;\n            this.vertices[12 * i + 3] = this.controlPoints[i + 1].x - thickness * normal.x;\n            this.vertices[12 * i + 4] = this.controlPoints[i + 1].y - thickness * normal.y;\n            this.vertices[12 * i + 5] = this.z;\n            this.vertices[12 * i + 6] = this.controlPoints[i + 1].x + thickness * normal.x;\n            this.vertices[12 * i + 7] = this.controlPoints[i + 1].y + thickness * normal.y;\n            this.vertices[12 * i + 8] = this.z;\n            this.vertices[12 * i + 9] = this.controlPoints[i].x + thickness * normal.x;\n            this.vertices[12 * i + 10] = this.controlPoints[i].y + thickness * normal.y;\n            this.vertices[12 * i + 11] = this.z;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    ControlPolygonView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    ControlPolygonView.prototype.renderFrame = function () {\n        var gl = this.controlPolygonShaders.gl;\n        var a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        gl.useProgram(this.controlPolygonShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(a_Position);\n        this.controlPolygonShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    ControlPolygonView.prototype.update = function (message) {\n        this.controlPoints = message.visibleControlPoints();\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    };\n    ControlPolygonView.prototype.updateBuffers = function () {\n        var gl = this.controlPolygonShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return ControlPolygonView;\n}());\nexports.ControlPolygonView = ControlPolygonView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar CurvatureExtremaShaders = /** @class */ (function () {\n    function CurvatureExtremaShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            'uniform vec4 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     if (dist > 0.5) discard; \\n' +\n            '     gl_FragColor = a_Color; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    CurvatureExtremaShaders.prototype.renderFrame = function (numberOfElements) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n        }\n    };\n    return CurvatureExtremaShaders;\n}());\nexports.CurvatureExtremaShaders = CurvatureExtremaShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//import { PeriodicBSpline_R1_to_R2_DifferentialProperties } from \"../mathematics/PeriodicBSpline_R1_to_R2_DifferentialProperties\";\n//import { PeriodicBSpline_R1_to_R2 } from \"../mathematics/PeriodicBSpline_R1_to_R2\";\nvar BSpline_R1_to_R2_1 = require(\"../mathematics/BSpline_R1_to_R2\");\nvar BSpline_R1_to_R2_DifferentialProperties_1 = require(\"../mathematics/BSpline_R1_to_R2_DifferentialProperties\");\nvar CurvatureExtremaView = /** @class */ (function () {\n    function CurvatureExtremaView(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    CurvatureExtremaView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.03;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var x = this.controlPoints[i].x;\n            var y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    CurvatureExtremaView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    CurvatureExtremaView.prototype.renderFrame = function () {\n        var gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    CurvatureExtremaView.prototype.update = function (spline) {\n        if (spline instanceof BSpline_R1_to_R2_1.BSpline_R1_to_R2) {\n            var splineDP = new BSpline_R1_to_R2_DifferentialProperties_1.BSpline_R1_to_R2_DifferentialProperties(spline);\n            this.controlPoints = splineDP.curvatureExtrema();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n        /*\n        if (spline instanceof PeriodicBSpline_R1_to_R2) {\n            const splineDP = new PeriodicBSpline_R1_to_R2_DifferentialProperties(spline)\n            this.controlPoints = splineDP.curvatureExtrema()\n            this.updateVerticesAndIndices()\n            this.updateBuffers()\n        }\n        */\n    };\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    CurvatureExtremaView.prototype.updateBuffers = function () {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return CurvatureExtremaView;\n}());\nexports.CurvatureExtremaView = CurvatureExtremaView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar CurveShaders = /** @class */ (function () {\n    function CurveShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec4 fColor; \\n' +\n            'void main() {\\n' +\n            '    gl_FragColor = fColor; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    CurveShaders.prototype.renderFrame = function (numberOfVertices) {\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, numberOfVertices);\n    };\n    return CurveShaders;\n}());\nexports.CurveShaders = CurveShaders;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CurveView = /** @class */ (function () {\n    function CurveView(spline, curveShaders, red, green, blue, alpha) {\n        this.spline = spline;\n        this.curveShaders = curveShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.POINT_SEQUENCE_SIZE = 1000;\n        //private readonly z = 0\n        this.pointSequenceOnSpline = [];\n        //private selectedControlPoint: number | null = null\n        this.vertexBuffer = null;\n        //private indexBuffer: WebGLBuffer | null = null\n        this.vertices = new Float32Array(this.POINT_SEQUENCE_SIZE * 6);\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.curveShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    CurveView.prototype.updatePointSequenceOnSpline = function () {\n        var start = this.spline.knots[this.spline.degree];\n        var end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        this.pointSequenceOnSpline = [];\n        for (var i = 0; i < this.POINT_SEQUENCE_SIZE; i += 1) {\n            var point = this.spline.evaluate(i / (this.POINT_SEQUENCE_SIZE - 1) * (end - start) + start);\n            this.pointSequenceOnSpline.push(point);\n        }\n    };\n    CurveView.prototype.updateVertices = function () {\n        var thickness = 0.005;\n        //const thickness = 0.004\n        //const thickness = 0.008\n        var maxLength = thickness * 3;\n        var tangent = ((this.pointSequenceOnSpline[1]).substract(this.pointSequenceOnSpline[0])).normalize(), normal = tangent.rotate90degrees(), miter, length, result = [];\n        result.push(this.pointSequenceOnSpline[0].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[0].substract(normal.multiply(thickness)));\n        for (var i = 1; i < this.pointSequenceOnSpline.length - 1; i += 1) {\n            normal = (this.pointSequenceOnSpline[i].substract(this.pointSequenceOnSpline[i - 1])).normalize().rotate90degrees();\n            tangent = (this.pointSequenceOnSpline[i + 1].substract(this.pointSequenceOnSpline[i - 1])).normalize();\n            miter = tangent.rotate90degrees();\n            length = thickness / (miter.dot(normal));\n            if (length > maxLength) {\n                length = maxLength;\n            }\n            result.push(this.pointSequenceOnSpline[i].add(miter.multiply(length)));\n            result.push(this.pointSequenceOnSpline[i].substract(miter.multiply(length)));\n        }\n        tangent = this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].substract(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 2]).normalize();\n        normal = tangent.rotate90degrees();\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].substract(normal.multiply(thickness)));\n        for (var i = 0; i < result.length; i += 1) {\n            this.vertices[3 * i] = result[i].x;\n            this.vertices[3 * i + 1] = result[i].y;\n            this.vertices[3 * i + 2] = 0.0;\n        }\n    };\n    CurveView.prototype.update = function (spline) {\n        this.spline = spline;\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        this.updateBuffers();\n    };\n    CurveView.prototype.updateBuffers = function () {\n        var gl = this.curveShaders.gl;\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    };\n    CurveView.prototype.renderFrame = function () {\n        var gl = this.curveShaders.gl;\n        var a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        var fColorLocation = gl.getUniformLocation(this.curveShaders.program, \"fColor\");\n        gl.useProgram(this.curveShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.uniform4f(fColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curveShaders.renderFrame(this.vertices.length / 3);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    CurveView.prototype.initVertexBuffers = function (gl) {\n        var a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        return 1;\n    };\n    return CurveView;\n}());\nexports.CurveView = CurveView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//import { PeriodicBSpline_R1_to_R2_DifferentialProperties } from \"../mathematics/PeriodicBSpline_R1_to_R2_DifferentialProperties\";\n//import { PeriodicBSpline_R1_to_R2 } from \"../mathematics/PeriodicBSpline_R1_to_R2\";\nvar BSpline_R1_to_R2_1 = require(\"../mathematics/BSpline_R1_to_R2\");\nvar BSpline_R1_to_R2_DifferentialProperties_1 = require(\"../mathematics/BSpline_R1_to_R2_DifferentialProperties\");\nvar InflectionsView = /** @class */ (function () {\n    function InflectionsView(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.visibleControlPoints();\n        // Write the positions of vertices to a vertex shader\n        var check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    InflectionsView.prototype.updateVerticesAndIndices = function () {\n        var size = 0.025;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (var i = 0; i < this.controlPoints.length; i += 1) {\n            var x = this.controlPoints[i].x;\n            var y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    };\n    InflectionsView.prototype.initVertexBuffers = function (gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        var a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    };\n    InflectionsView.prototype.renderFrame = function () {\n        var gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    };\n    InflectionsView.prototype.update = function (spline) {\n        if (spline instanceof BSpline_R1_to_R2_1.BSpline_R1_to_R2) {\n            var splineDP = new BSpline_R1_to_R2_DifferentialProperties_1.BSpline_R1_to_R2_DifferentialProperties(spline);\n            this.controlPoints = splineDP.inflections();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n        /*\n        if (spline instanceof PeriodicBSpline_R1_to_R2) {\n            const splineDP = new PeriodicBSpline_R1_to_R2_DifferentialProperties(spline)\n            this.controlPoints = splineDP.inflections()\n            this.updateVerticesAndIndices()\n            this.updateBuffers()\n        }\n        */\n    };\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    InflectionsView.prototype.updateBuffers = function () {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    };\n    return InflectionsView;\n}());\nexports.InflectionsView = InflectionsView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cuon_utils_1 = require(\"../webgl/cuon-utils\");\nvar InsertKnotButtonShaders = /** @class */ (function () {\n    function InsertKnotButtonShaders(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    v_Color = a_Color; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '     float dist1 = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     float dist2 = distance(v_Texture, vec2(0.9, 0.0)); \\n' +\n            '     float dist3 = distance(v_Texture, vec2(-0.9, 0.0)); \\n' +\n            '     if (dist1 < 0.25 || dist2 < 0.25 || dist3 < 0.25) { \\n' +\n            '     gl_FragColor = vec4(0.25, 0.25, 0.25, 1.0); } \\n ' +\n            '     else if (v_Texture[0] > -0.9 && v_Texture[0] < 0.9 && v_Texture[1] < 0.1 && v_Texture[1] > -0.1) { \\n' +\n            '     gl_FragColor = vec4(0.25, 0.25, 0.25, 1.0); } \\n ' +\n            '     else if ( distance(v_Texture, vec2(1.2, 0.7)) > 0.3 && v_Texture[0] > 1.2 && v_Texture[1] > 0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else if ( distance(v_Texture, vec2(1.2, -0.7)) > 0.3 && v_Texture[0] > 1.2 && v_Texture[1] < -0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else if ( distance(v_Texture, vec2(-1.2, 0.7)) > 0.3 && v_Texture[0] < -1.2 && v_Texture[1] > 0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else if ( distance(v_Texture, vec2(-1.2, -0.7)) > 0.3 && v_Texture[0] < -1.2 && v_Texture[1] < -0.7 ) { \\n' +\n            '     gl_FragColor = vec4(0.3, 0.3, 0.3, 0.0); } \\n' +\n            '     else { \\n' +\n            '     /*gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0); } */ \\n' +\n            '     gl_FragColor = vec4(v_Color, 1.0); } \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    InsertKnotButtonShaders.prototype.renderFrame = function (numberOfElements) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n        }\n    };\n    return InsertKnotButtonShaders;\n}());\nexports.InsertKnotButtonShaders = InsertKnotButtonShaders;\n;\n","\"use strict\";\n// Reference: cuon-utils.js\n// cuon-utils.js (c) 2012 kanda and matsuda\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Create the linked program object\n * @param gl GL context\n * @param vshader a vertex shader program (string)\n * @param fshader a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n */\nfunction createProgram(gl, vshader, fshader) {\n    // Create shader object\n    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\n    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n    if (!vertexShader || !fragmentShader) {\n        console.log(\"createProgram was unable to produce a vertex or fragment shader\");\n        return null;\n    }\n    // Create a program object\n    var program = gl.createProgram();\n    if (!program) {\n        console.log(\"createProgram was unable to produce a program\");\n        return null;\n    }\n    // Attach the shader objects\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    // Link the program object\n    gl.linkProgram(program);\n    // Check the result of linking\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        var error = gl.getProgramInfoLog(program);\n        console.log('Failed to link program: ' + error);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n        return null;\n    }\n    return program;\n}\nexports.createProgram = createProgram;\n/**\n * Create a shader object\n * @param gl GL context\n * @param type the type of the shader object to be created\n * @param source shader program (string)\n * @return created shader object, or null if the creation has failed.\n */\nfunction loadShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    if (shader == null) {\n        console.log('unable to create shader');\n        return null;\n    }\n    // Set the shader program\n    gl.shaderSource(shader, source);\n    // Compile the shader\n    gl.compileShader(shader);\n    // Check the result of compilation\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n        var error = gl.getShaderInfoLog(shader);\n        console.log('Failed to compile shader: ' + error);\n        gl.deleteShader(shader);\n        return null;\n    }\n    return shader;\n}\n","\"use strict\";\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\nfunction WebGLUtils() {\n    /**\n     * Creates the HTLM for a failure message\n     * @param {string} canvasContainerId id of container of th\n     *        canvas.\n     * @return {string} The html.\n     */\n    var makeFailHTML = function (msg) {\n        return '' +\n            '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n        return '' +\n            '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n            '<td align=\"center\">' +\n            '<div style=\"display: table-cell; vertical-align: middle;\">' +\n            '<div style=\"\">' + msg + '</div>' +\n            '</div>' +\n            '</td></tr></table>';\n    };\n    /**\n     * Mesasge for getting a webgl browser\n     * @type {string}\n     */\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n    /**\n     * Mesasge for need better hardware\n     * @type {string}\n     */\n    var OTHER_PROBLEM = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n    /**\n     * Creates a webgl context. If creation fails it will\n     * change the contents of the container of the <canvas>\n     * tag to an error message with the correct links for WebGL.\n     * @param {Element} canvas. The canvas element to create a\n     *     context from.\n     * @param {WebGLContextCreationAttirbutes} opt_attribs Any\n     *     creation attributes you want to pass in.\n     * @param {function:(msg)} opt_onError An function to call\n     *     if there is an error during creation.\n     * @return {WebGLRenderingContext} The created context.\n     */\n    var setupWebGL = function (canvas, opt_attribs, opt_onError) {\n        function handleCreationError(msg) {\n            var container = document.getElementsByTagName(\"body\")[0];\n            //var container = canvas.parentNode;\n            if (container) {\n                var str = window.WebGLRenderingContext ?\n                    OTHER_PROBLEM :\n                    GET_A_WEBGL_BROWSER;\n                if (msg) {\n                    str += \"<br/><br/>Status: \" + msg;\n                }\n                container.innerHTML = makeFailHTML(str);\n            }\n        }\n        ;\n        opt_onError = opt_onError || handleCreationError;\n        if (canvas.addEventListener) {\n            canvas.addEventListener(\"webglcontextcreationerror\", function (event) {\n                opt_onError(event.statusMessage);\n            }, false);\n        }\n        var context = create3DContext(canvas, opt_attribs);\n        if (!context) {\n            if (!window.WebGLRenderingContext) {\n                opt_onError(\"\");\n            }\n            else {\n                opt_onError(\"\");\n            }\n        }\n        return context;\n    };\n    /**\n     * Creates a webgl context.\n     * @param {!Canvas} canvas The canvas tag to get context\n     *     from. If one is not passed in one will be created.\n     * @return {!WebGLContext} The created context.\n     */\n    var create3DContext = function (canvas, opt_attribs) {\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n        var context = null;\n        for (var ii = 0; ii < names.length; ++ii) {\n            try {\n                context = canvas.getContext(names[ii], opt_attribs);\n            }\n            catch (e) { }\n            if (context) {\n                break;\n            }\n        }\n        return context;\n    };\n    return {\n        create3DContext: create3DContext,\n        setupWebGL: setupWebGL\n    };\n}\nexports.WebGLUtils = WebGLUtils;\n/**\n * Provides requestAnimationFrame in a cross browser\n * way.\n */\nif (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\n                window.setTimeout(callback, 1000 / 60);\n            };\n    })();\n}\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.\n *\n * Cancels an animation frame request.\n * Checks for cross-browser support, falls back to clearTimeout.\n * @param {number}  Animation frame request. */\nif (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\n        window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\n        window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\n        window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\n        window.clearTimeout);\n}\n"],"sourceRoot":""}