{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,2BAA2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;;;;;;;;;;ACrCtB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,sBAAsB,GAAG,wBAAwB,GAAG,gBAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,0CAA0C;AAC1C,4BAA4B,QAAQ;AACpC;AACA,kCAAkC;AAClC,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;ACxJZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,kCAAkC,mBAAO,CAAC,6EAA4B;AACtE,4BAA4B,mBAAO,CAAC,uEAAqB;AACzD,uCAAuC,mBAAO,CAAC,6FAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACzHR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,kCAAkC,mBAAO,CAAC,6EAA4B;AACtE,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjPa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,2BAA2B,GAAG,oCAAoC;AAC5F,8BAA8B,mBAAO,CAAC,qEAAwB;AAC9D,wBAAwB,mBAAO,CAAC,+DAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC/JV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,qBAAqB;AACpD,kCAAkC,mBAAO,CAAC,6EAA4B;AACtE,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD,4BAA4B,mBAAO,CAAC,uEAAqB;AACzD,8CAA8C,mBAAO,CAAC,2GAAuC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAA+C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAA6C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AC7Pf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2CAA2C;AAC3C,kDAAkD,mBAAO,CAAC,mHAA2C;AACrG,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;;;;;;;;;;ACb9B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,yBAAyB;AACzD,kCAAkC,mBAAO,CAAC,6EAA4B;AACtE,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACnMhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+CAA+C;AAC/C,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;;;;;;;;;;ACjGlC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,GAAG,6BAA6B;AACpE,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD,uCAAuC,mBAAO,CAAC,6FAAgC;AAC/E,sDAAsD,mBAAO,CAAC,2HAA+C;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;;;AC1HvB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD,gCAAgC,mBAAO,CAAC,+EAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;;;ACzFvB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mDAAmD;AACnD,uCAAuC,mBAAO,CAAC,qGAAwC;AACvF,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;;;;;;;;;;ACtGtC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,qBAAqB;AACpD,kCAAkC,mBAAO,CAAC,6EAA4B;AACtE,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD,4BAA4B,mBAAO,CAAC,uEAAqB;AACzD,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD,uCAAuC,mBAAO,CAAC,qGAAwC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AC7Kf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2CAA2C;AAC3C,wBAAwB,mBAAO,CAAC,uEAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;;;;;;;;;;AC1F9B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,yBAAyB;AACzD,kCAAkC,mBAAO,CAAC,6EAA4B;AACtE,mBAAmB,mBAAO,CAAC,+DAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACvNhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;;;;;;;;;;ACXjB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;;;;;;;;;;ACXzB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACpGhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;AC3GN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC3ET;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,yBAAyB;AACzB;AACA,mBAAmB;AACnB;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,cAAc;AACd;;;;;;;;;;;ACnHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,YAAY,GAAG,mBAAmB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,aAAa,GAAG,YAAY,GAAG,mBAAmB,GAAG,8BAA8B,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,cAAc,GAAG,aAAa,GAAG,4BAA4B,GAAG,8BAA8B;AAClZ,uBAAuB,mBAAO,CAAC,2DAAgB;AAC/C,sBAAsB,mBAAO,CAAC,yDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC3PT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC7LP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,uBAAuB,mBAAO,CAAC,2DAAgB;AAC/C,yBAAyB,mBAAO,CAAC,+DAAkB;AACnD,oCAAoC,mBAAO,CAAC,qFAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC7MV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC;AACpC,uBAAuB,mBAAO,CAAC,0EAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;;;ACfvB;AACb,WAAW,kBAAkB;AAC7B,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,cAAc,GAAG,aAAa,GAAG,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;;;;;;;;;;;ACtED;AACb,WAAW,kBAAkB;AAC7B,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,yBAAyB,GAAG,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AC7EhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,8BAA8B,mBAAO,CAAC,sGAA6C;AACnF,uCAAuC,mBAAO,CAAC,8GAAiD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;ACvIX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,8BAA8B,mBAAO,CAAC,sGAA6C;AACnF,gCAAgC,mBAAO,CAAC,gGAA0C;AAClF,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;;;;;;;;;;ACxKnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,wBAAwB,mBAAO,CAAC,gFAAkC;AAClE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,0BAA0B,mBAAO,CAAC,8FAAyC;AAC3E,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD,2BAA2B,mBAAO,CAAC,4DAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC7DP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,qBAAqB;AAC5C,wBAAwB,mBAAO,CAAC,gFAAkC;AAClE,0BAA0B,mBAAO,CAAC,8FAAyC;AAC3E,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACnHP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,gCAAgC,mBAAO,CAAC,gGAA0C;AAClF,kCAAkC,mBAAO,CAAC,8GAAiD;AAC3F,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD,mCAAmC,mBAAO,CAAC,4EAA4B;AACvE,uCAAuC,mBAAO,CAAC,8GAAiD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AClEf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,qBAAqB,GAAG,kCAAkC;AAC1F,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AClQhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,2BAA2B;AAC3D,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,uBAAuB,mBAAO,CAAC,4DAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AC/QhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,0BAA0B,GAAG,qBAAqB,GAAG,mCAAmC;AACnH,uCAAuC,mBAAO,CAAC,8GAAiD;AAChG,wBAAwB,mBAAO,CAAC,gFAAkC;AAClE,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,0BAA0B,mBAAO,CAAC,gFAAkC;AACpE,8BAA8B,mBAAO,CAAC,gFAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAgD;AACxE;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;ACnVX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,wBAAwB,mBAAO,CAAC,gFAAkC;AAClE,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,8BAA8B,mBAAO,CAAC,gFAAuB;AAC7D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+CAA+C,mCAAmC;AAClF;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACvNV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,wBAAwB,mBAAO,CAAC,gFAAkC;AAClE,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,uCAAuC,mBAAO,CAAC,8GAAiD;AAChG,8BAA8B,mBAAO,CAAC,gFAAuB;AAC7D,uBAAuB,mBAAO,CAAC,4DAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+CAA+C,mCAAmC;AAClF;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACjSV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,wBAAwB,mBAAO,CAAC,gFAAkC;AAClE,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,8BAA8B,mBAAO,CAAC,gFAAuB;AAC7D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,uCAAuC,mBAAO,CAAC,8GAAiD;AAChG,sCAAsC,mBAAO,CAAC,gGAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+CAA+C,mCAAmC;AAClF;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;AC7RlB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,gCAAgC,mBAAO,CAAC,0EAAyB;AACjE,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,0BAA0B,mBAAO,CAAC,gFAAkC;AACpE,gCAAgC,mBAAO,CAAC,4FAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,QAAQ;AACxC,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;AC7NJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,6BAA6B;AACtH,uBAAuB,mBAAO,CAAC,0EAA+B;AAC9D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,gCAAgC,mBAAO,CAAC,4FAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;;;;;;;;;;ACliBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,sBAAsB;AAC9C;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;AClBR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;;;;;;;;;;ACrIjB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,uBAAuB,mBAAO,CAAC,0EAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;AC7KX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACvKd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,iCAAiC,mBAAO,CAAC,uEAA0B;AACnE,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,iCAAiC;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;;;;;;;;;;ACxCpB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,4BAA4B,GAAG,2BAA2B;AACxF,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,2BAA2B,mBAAO,CAAC,2DAAoB;AACvD,kBAAkB,mBAAO,CAAC,gEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA,0GAA0G,iCAAiC;AAC3I;AACA;AACA,0GAA0G,iCAAiC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC,kDAAkD;AAClD;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,0CAA0C;AAC1C;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,oBAAoB,gBAAgB;AACpC,wCAAwC;AACxC,uCAAuC;AACvC,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;AC3Jd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,uCAAuC;AACvC,qCAAqC;AACrC,qCAAqC;AACrC,mCAAmC;AACnC,0BAA0B;AAC1B,wCAAwC;AACxC,oCAAoC;AACpC,sDAAsD;AACtD,cAAc;AACd;AACA,sDAAsD;AACtD,sCAAsC;AACtC,qCAAqC;AACrC,mCAAmC;AACnC,0BAA0B;AAC1B,0DAA0D;AAC1D,oEAAoE;AACpE,qDAAqD;AACrD,oDAAoD;AACpD,qCAAqC;AACrC,qEAAqE;AACrE,qEAAqE;AACrE,8DAA8D;AAC9D,8DAA8D;AAC9D,wDAAwD;AACxD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AClDf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,0BAA0B;AAC1B,sDAAsD;AACtD,cAAc;AACd;AACA,wDAAwD;AACxD,kCAAkC;AAClC,0BAA0B;AAC1B,wCAAwC;AACxC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;AC5BlB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AC1Hf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,iCAAiC,mBAAO,CAAC,uEAA0B;AACnE,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;;;;;;;;;;AC9CrB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,sBAAsB,GAAG,8BAA8B,GAAG,4BAA4B;AACtH,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,yBAAyB,mBAAO,CAAC,wEAA8B;AAC/D,2BAA2B,mBAAO,CAAC,2DAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sBAAsB;AACtB;AACA;AACA,gBAAgB;AAChB,mCAAmC;AACnC,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACxIhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;;;;;;;;;;ACzJjB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B;AAC9B,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,2BAA2B,mBAAO,CAAC,2DAAoB;AACvD,8CAA8C,mBAAO,CAAC,4HAAwD;AAC9G,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,+BAA+B;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;;;;;;;;;;ACjDjB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B;AAC/B,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,uCAAuC;AACvC,qCAAqC;AACrC,0BAA0B;AAC1B,wCAAwC;AACxC,sDAAsD;AACtD,cAAc;AACd;AACA,sDAAsD;AACtD,mCAAmC;AACnC,qCAAqC;AACrC,0BAA0B;AAC1B,oEAAoE;AACpE,2CAA2C;AAC3C,0CAA0C;AAC1C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;ACpClB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,0BAA0B;AAC1B,sDAAsD;AACtD,cAAc;AACd;AACA,wDAAwD;AACxD,kCAAkC;AAClC,0BAA0B;AAC1B,wCAAwC;AACxC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC5BT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;AClHN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,iCAAiC,mBAAO,CAAC,uEAA0B;AACnE,sBAAsB,mBAAO,CAAC,iDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;AC1EZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qDAAqD,GAAG,uBAAuB,GAAG,+BAA+B,GAAG,6BAA6B,GAAG,6BAA6B,GAAG,mBAAmB;AACvM,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,yBAAyB,mBAAO,CAAC,wEAA8B;AAC/D,2BAA2B,mBAAO,CAAC,2DAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,gBAAgB;AAChB,mCAAmC;AACnC,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;;;;;;;;;;ACjLxC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB;AACxB,eAAe,mBAAO,CAAC,0CAAe;AACtC,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D,oCAAoC,mBAAO,CAAC,6EAA6B;AACzE,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D,qCAAqC,mBAAO,CAAC,+EAA8B;AAC3E,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,sBAAsB,mBAAO,CAAC,iDAAe;AAC7C,4BAA4B,mBAAO,CAAC,6DAAqB;AACzD,gCAAgC,mBAAO,CAAC,qEAAyB;AACjE,iCAAiC,mBAAO,CAAC,0FAAuC;AAChF,6BAA6B,mBAAO,CAAC,+DAAsB;AAC3D,iCAAiC,mBAAO,CAAC,uEAA0B;AACnE;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;ACjIX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;ACzJZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,sCAAsC;AACtC,qCAAqC;AACrC,qDAAqD;AACrD,wCAAwC;AACxC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,8DAA8D;AAC9D,2CAA2C;AAC3C,kFAAkF;AAClF,cAAc;AACd;AACA,wDAAwD;AACxD,mCAAmC;AACnC,sCAAsC;AACtC,0CAA0C;AAC1C,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;AACrC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,kEAAkE;AAClE,+DAA+D;AAC/D,qDAAqD;AACrD,oEAAoE;AACpE,oEAAoE;AACpE,sFAAsF;AACtF,mDAAmD;AACnD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACjDV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B;AAC7B,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,sCAAsC;AACtC,qCAAqC;AACrC,qDAAqD;AACrD,wCAAwC;AACxC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,8DAA8D;AAC9D,6CAA6C;AAC7C,oFAAoF;AACpF,+FAA+F;AAC/F,cAAc;AACd;AACA,wDAAwD;AACxD,mCAAmC;AACnC,sCAAsC;AACtC,0CAA0C;AAC1C,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;AACrC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,kEAAkE;AAClE,+DAA+D;AAC/D,qDAAqD;AACrD,oEAAoE;AACpE,oEAAoE;AACpE,sFAAsF;AACtF,mDAAmD;AACnD,uDAAuD;AACvD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACnDhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D,kCAAkC,mBAAO,CAAC,yEAA2B;AACrE,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D,yBAAyB,mBAAO,CAAC,uDAAkB;AACnD,sBAAsB,mBAAO,CAAC,iDAAe;AAC7C,kCAAkC,mBAAO,CAAC,yEAA2B;AACrE,iCAAiC,mBAAO,CAAC,uEAA0B;AACnE,4BAA4B,mBAAO,CAAC,6DAAqB;AACzD,+BAA+B,mBAAO,CAAC,4EAAgC;AACvE,yCAAyC,mBAAO,CAAC,0GAA+C;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;;;;;;;;;;AC9HnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,2BAA2B,mBAAO,CAAC,2DAAoB;AACvD,8CAA8C,mBAAO,CAAC,4HAAwD;AAC9G,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,iCAAiC;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;ACjDb;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;;;;;;;;;;AChI3B;AACb,WAAW,iBAAiB;AAC5B,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;;;AAIL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACpLd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,0CAA0C,mBAAO,CAAC,iGAAmC;AACrF,oCAAoC,mBAAO,CAAC,qFAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;ACtBN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,wBAAwB,mBAAO,CAAC,6DAAiB;AACjD,wCAAwC,mBAAO,CAAC,6FAAiC;AACjF,mCAAmC,mBAAO,CAAC,mFAA4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;ACxBf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;ACzBT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,qBAAqB;;;;;;;;;;;ACpDR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,qCAAqC;;;;;;;;;;;AChHxB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,uCAAuC;;;;;;;;;;;AChH1B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,gCAAgC;;;;;;;;;;;ACjHnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,iCAAiC;;;;;;;;;;;ACjHpB;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtEa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACvBP;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,aAAa,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,mBAAmB,GAAG,cAAc,GAAG,gBAAgB,GAAG,qBAAqB;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;;;;;;;;;;;ACrSV;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,qBAAqB;AACzF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACxEJ;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,uCAAuC,YAAY,cAAc,gBAAgB,kBAAkB;AACnG;AACA,mDAAmD,aAAa,aAAa;AAC7E;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,eAAe,gCAAgC;AAC/C;AACA,eAAe,gBAAgB;AAC/B;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC9LA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,sBAAsB,mBAAO,CAAC,uDAAqB;AACnD,uBAAuB,mBAAO,CAAC,2DAAuB;AACtD,+BAA+B,mBAAO,CAAC,yFAAsC;AAC7E,2BAA2B,mBAAO,CAAC,iEAA0B;AAC7D,8BAA8B,mBAAO,CAAC,uEAA6B;AACnE,yBAAyB,mBAAO,CAAC,6EAAgC;AACjE,uBAAuB,mBAAO,CAAC,2DAAuB;AACtD,+BAA+B,mBAAO,CAAC,2EAA+B;AACtE,mCAAmC,mBAAO,CAAC,iFAAkC;AAC7E,2CAA2C,mBAAO,CAAC,iGAA0C;AAC7F,qBAAqB,mBAAO,CAAC,qEAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ","sources":["webpack://closed-curve/./src/bsplines/BinomialCoefficient.ts","webpack://closed-curve/./src/bsplines/Piegl_Tiller_NURBS_Book.ts","webpack://closed-curve/./src/bsplines/R1toR1/BSplineR1toR1.ts","webpack://closed-curve/./src/bsplines/R1toR1/BaseBSplineR1toR1.ts","webpack://closed-curve/./src/bsplines/R1toR1/BernsteinDecompositionR1toR1.ts","webpack://closed-curve/./src/bsplines/R1toR2/BSplineR1toR2.ts","webpack://closed-curve/./src/bsplines/R1toR2/BSplineR1toR2DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/R1toR2/BaseBSplineR1toR2.ts","webpack://closed-curve/./src/bsplines/R1toR2/BaseBSplineR1toR2DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/R1toR2/RationalBSplineR1toR2.ts","webpack://closed-curve/./src/bsplines/R1toR2/RationalBSplineR1toR2Adapter.ts","webpack://closed-curve/./src/bsplines/R1toR2/RationalBSplineR1toR2DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/R1toR3/BSplineR1toR3.ts","webpack://closed-curve/./src/bsplines/R1toR3/BSplineR1toR3DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/R1toR3/BaseBSplineR1toR3.ts","webpack://closed-curve/./src/controllers/CurveScene3dController.ts","webpack://closed-curve/./src/controllers/RationalCurveScene2dController.ts","webpack://closed-curve/./src/linearAlgebra/CholeskyDecomposition.ts","webpack://closed-curve/./src/linearAlgebra/DenseMatrix.ts","webpack://closed-curve/./src/linearAlgebra/DiagonalMatrix.ts","webpack://closed-curve/./src/linearAlgebra/LUSolve.ts","webpack://closed-curve/./src/linearAlgebra/MathVectorBasicOperations.ts","webpack://closed-curve/./src/linearAlgebra/SquareMatrix.ts","webpack://closed-curve/./src/linearAlgebra/SymmetricMatrix.ts","webpack://closed-curve/./src/mathVector/RotationMatrix.ts","webpack://closed-curve/./src/mathVector/Vector2d.ts","webpack://closed-curve/./src/mathVector/Vector3d.ts","webpack://closed-curve/./src/models/BaseCurve2dModel.ts","webpack://closed-curve/./src/models/BaseRationalCurve2dModel.ts","webpack://closed-curve/./src/models/Curve2dModel.ts","webpack://closed-curve/./src/models/CurveModel3d.ts","webpack://closed-curve/./src/models/RationalCurveModel2d.ts","webpack://closed-curve/./src/optimizationProblems/BaseOpBSplineR1toR2.ts","webpack://closed-curve/./src/optimizationProblems/BaseOpBSplineR1toR3.ts","webpack://closed-curve/./src/optimizationProblems/BaseOpRationalBSplineR1toR2.ts","webpack://closed-curve/./src/optimizationProblems/OpBSplineR1toR2.ts","webpack://closed-curve/./src/optimizationProblems/OpBSplineR1toR3.ts","webpack://closed-curve/./src/optimizationProblems/OpRationalBSplineR1toR2.ts","webpack://closed-curve/./src/optimizers/Optimizer.ts","webpack://closed-curve/./src/optimizers/TrustRegionSubproblem.ts","webpack://closed-curve/./src/views/ArrayConversion.ts","webpack://closed-curve/./src/views/BaseObject3dShadowView.ts","webpack://closed-curve/./src/views/BaseObject3dView.ts","webpack://closed-curve/./src/views/ControlPoints2dView.ts","webpack://closed-curve/./src/views/ControlPoints3dShadowView.ts","webpack://closed-curve/./src/views/ControlPoints3dView.ts","webpack://closed-curve/./src/views/ControlPointsShaders.ts","webpack://closed-curve/./src/views/ControlPolygon2dShaders.ts","webpack://closed-curve/./src/views/ControlPolygon2dView.ts","webpack://closed-curve/./src/views/ControlPolygon3dShadowView.ts","webpack://closed-curve/./src/views/ControlPolygon3dView.ts","webpack://closed-curve/./src/views/CurvatureExtrema2dView.ts","webpack://closed-curve/./src/views/CurvatureExtrema3dView.ts","webpack://closed-curve/./src/views/CurvatureExtremaShaders.ts","webpack://closed-curve/./src/views/Curve2dShaders.ts","webpack://closed-curve/./src/views/Curve2dView.ts","webpack://closed-curve/./src/views/Curve3dShadowView.ts","webpack://closed-curve/./src/views/Curve3dView.ts","webpack://closed-curve/./src/views/CurveScene3dView.ts","webpack://closed-curve/./src/views/Inflections2dView.ts","webpack://closed-curve/./src/views/Object3dShaders.ts","webpack://closed-curve/./src/views/Object3dShadowShaders.ts","webpack://closed-curve/./src/views/RationalCurveScene2dView.ts","webpack://closed-curve/./src/views/TorsionZeros3dView.ts","webpack://closed-curve/./src/views/Wire2dEventListenerRationalCurve.ts","webpack://closed-curve/./src/views/Wire3dEventListener.ts","webpack://closed-curve/./src/webComponents/AppCurve3d.ts","webpack://closed-curve/./src/webComponents/AppCurvesAndSurfaces.ts","webpack://closed-curve/./src/webComponents/CopyrightYears.ts","webpack://closed-curve/./src/webComponents/CurveCategory.ts","webpack://closed-curve/./src/webComponents/RoundedSwitchCurvatureExtrema.ts","webpack://closed-curve/./src/webComponents/RoundedSwitchCurvatureExtrema3d.ts","webpack://closed-curve/./src/webComponents/RoundedSwitchInflections.ts","webpack://closed-curve/./src/webComponents/RoundedSwitchTorsionZeros.ts","webpack://closed-curve/./src/webgl/cuon-utils.ts","webpack://closed-curve/./src/webgl/mat3.ts","webpack://closed-curve/./src/webgl/mat4.ts","webpack://closed-curve/./src/webgl/quat.ts","webpack://closed-curve/./src/webgl/webgl-utils.ts","webpack://closed-curve/webpack/bootstrap","webpack://closed-curve/./src/main.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memoizedBinomialCoefficient = exports.binomialCoefficient = void 0;\nfunction binomialCoefficient(n, k) {\n    let result = 1;\n    if (n < k || k < 0) {\n        return 0;\n    }\n    // take advantage of symmetry\n    if (k > n - k) {\n        k = n - k;\n    }\n    for (let x = n - k + 1; x <= n; x += 1) {\n        result *= x;\n    }\n    for (let x = 1; x <= k; x += 1) {\n        result /= x;\n    }\n    return result;\n}\nexports.binomialCoefficient = binomialCoefficient;\nfunction memoizedBinomialCoefficient() {\n    let cache = [];\n    return (n, k) => {\n        if (cache[n] !== undefined && cache[n][k] !== undefined) {\n            return cache[n][k];\n        }\n        else {\n            if (cache[n] === undefined) {\n                cache[n] = [];\n            }\n            const result = binomialCoefficient(n, k);\n            cache[n][k] = result;\n            return result;\n        }\n    };\n}\nexports.memoizedBinomialCoefficient = memoizedBinomialCoefficient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decomposeFunction = exports.basisFunctions = exports.clampingFindSpan = exports.findSpan = void 0;\n/**\n * Returns the span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i] ≤ u < knots[i+1]\n */\nfunction findSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        console.log(\"u: \" + u);\n        console.log(\"knots: \" + knots);\n        console.log(\"degree: \" + degree);\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 2;\n    }\n    // Do binary search\n    let low = degree;\n    let high = knots.length - 1 - degree;\n    let i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.findSpan = findSpan;\n/**\n * Returns the span index used for clamping a periodic B-Spline\n * Note: The only difference with findSpan is the special case u = knots[-degree - 1]\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i] ≤ u < knots[i+1]\n */\nfunction clampingFindSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 1;\n    }\n    // Do binary search\n    let low = degree;\n    let high = knots.length - 1 - degree;\n    let i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.clampingFindSpan = clampingFindSpan;\n/**\n * Returns the basis functions values\n * @param span span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns the array of values evaluated at u\n */\nfunction basisFunctions(span, u, knots, degree) {\n    // Bibliographic reference : The NURBS BOOK, p.70\n    let result = [1];\n    let left = [];\n    let right = [];\n    for (let j = 1; j <= degree; j += 1) {\n        left[j] = u - knots[span + 1 - j];\n        right[j] = knots[span + j] - u;\n        let saved = 0.0;\n        for (let r = 0; r < j; r += 1) {\n            let temp = result[r] / (right[r + 1] + left[j - r]);\n            result[r] = saved + right[r + 1] * temp;\n            saved = left[j - r] * temp;\n        }\n        result[j] = saved;\n    }\n    return result;\n}\nexports.basisFunctions = basisFunctions;\n/**\n * Decompose a BSpline function into Bézier segments\n */\nfunction decomposeFunction(spline) {\n    //Piegl and Tiller, The NURBS book, p.173\n    let result = [];\n    const number_of_bezier_segments = spline.distinctKnots().length - 1;\n    for (let i = 0; i < number_of_bezier_segments; i += 1) {\n        result.push([]);\n    }\n    for (let i = 0; i <= spline.degree; i += 1) {\n        result[0][i] = spline.controlPoints[i];\n    }\n    let a = spline.degree;\n    let b = spline.degree + 1;\n    let bezier_segment = 0;\n    let alphas = [];\n    while (b < spline.knots.length - 1) {\n        let i = b;\n        while (b < spline.knots.length - 1 && spline.knots[b + 1] === spline.knots[b]) {\n            b += 1;\n        }\n        let mult = b - i + 1;\n        if (mult < spline.degree) {\n            let numer = spline.knots[b] - spline.knots[a]; // Numerator of alpha\n            // Compute and store alphas\n            for (let j = spline.degree; j > mult; j -= 1) {\n                alphas[j - mult - 1] = numer / (spline.knots[a + j] - spline.knots[a]);\n            }\n            let r = spline.degree - mult; // insert knot r times\n            for (let j = 1; j <= r; j += 1) {\n                let save = r - j;\n                let s = mult + j; // this many new controlPoints\n                for (let k = spline.degree; k >= s; k -= 1) {\n                    let alpha = alphas[k - s];\n                    result[bezier_segment][k] = (result[bezier_segment][k] * alpha) + (result[bezier_segment][k - 1] * (1 - alpha));\n                }\n                if (b < spline.knots.length) {\n                    result[bezier_segment + 1][save] = result[bezier_segment][spline.degree]; // next segment\n                }\n            }\n        }\n        bezier_segment += 1; // Bezier segment completed\n        if (b < spline.knots.length - 1) {\n            //initialize next bezier_segment\n            for (i = Math.max(0, spline.degree - mult); i <= spline.degree; i += 1) {\n                result[bezier_segment][i] = spline.controlPoints[b - spline.degree + i];\n            }\n            a = b;\n            b += 1;\n        }\n    }\n    return result;\n}\nexports.decomposeFunction = decomposeFunction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BSplineR1toR1 = void 0;\nconst Piegl_Tiller_NURBS_Book_1 = require(\"../Piegl_Tiller_NURBS_Book\");\nconst BaseBSplineR1toR1_1 = require(\"./BaseBSplineR1toR1\");\nconst BernsteinDecompositionR1toR1_1 = require(\"./BernsteinDecompositionR1toR1\");\n/**\n * A B-Spline function from a one dimensional real space to a one dimensional real space\n */\nclass BSplineR1toR1 extends BaseBSplineR1toR1_1.BaseBSplineR1toR1 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [0], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    factory(controlPoints = [0], knots = [0, 1]) {\n        return new BSplineR1toR1(controlPoints, knots);\n    }\n    bernsteinDecomposition() {\n        // Piegl_Tiller_NURBS_Book.ts\n        return new BernsteinDecompositionR1toR1_1.BernsteinDecompositionR1toR1((0, Piegl_Tiller_NURBS_Book_1.decomposeFunction)(this));\n    }\n    clone() {\n        return new BSplineR1toR1(this._controlPoints.slice(), this._knots.slice());\n    }\n    derivative() {\n        let newControlPoints = [];\n        let newKnots = [];\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            newControlPoints[i] = (this._controlPoints[i + 1] - (this._controlPoints[i])) * (this._degree / (this._knots[i + this._degree + 1] - this._knots[i + 1]));\n        }\n        newKnots = this._knots.slice(1, this._knots.length - 1);\n        return new BSplineR1toR1(newControlPoints, newKnots);\n    }\n    elevateDegree() {\n        const bds = this.bernsteinDecomposition();\n        bds.elevateDegree();\n        const knots = this.distinctKnots();\n        const newSpline = (0, BernsteinDecompositionR1toR1_1.splineRecomposition)(bds, knots);\n        for (let i = 0; i < knots.length; i += 1) {\n            let m = this.knotMultiplicity((0, Piegl_Tiller_NURBS_Book_1.findSpan)(knots[i], this.knots, this.degree));\n            for (let j = 0; j < newSpline.degree - m - 1; j += 1) {\n                newSpline.removeKnot((0, Piegl_Tiller_NURBS_Book_1.findSpan)(newSpline.knots[i], newSpline.knots, newSpline.degree));\n            }\n        }\n        return newSpline;\n    }\n    removeKnot(indexFromFindSpan, tolerance = 10e-5) {\n        //Piegl and Tiller, The NURBS book, p : 185\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        const index = indexFromFindSpan;\n        // end knots are not removed\n        if (index > this._degree && index < this.knots.length - this._degree - 1) {\n            throw new Error(\"index out of range\");\n        }\n        //const double tolerance = 1;\n        const multiplicity = this.knotMultiplicity(index, knots);\n        const last = index - multiplicity;\n        const first = index - this.degree;\n        const offset = first - 1;\n        //std::vector<vectorType> local(2*degree+1);\n        let local = [];\n        local[0] = controlPoints[offset];\n        local[last + 1 - offset] = controlPoints[last + 1];\n        let i = first;\n        let j = last;\n        let ii = 1;\n        let jj = last - offset;\n        let removable = false;\n        // Compute new control point for one removal step\n        while (j > i) {\n            let alpha_i = (knots[index] - knots[i]) / (knots[i + this.degree + 1] - knots[i]);\n            let alpha_j = (knots[index] - knots[j]) / (knots[j + this.degree + 1] - knots[j]);\n            local[ii] = (controlPoints[i] - (local[ii - 1] * (1.0 - alpha_i))) / alpha_i;\n            local[jj] = (controlPoints[j] - (local[jj + 1] * (alpha_j))) / (1.0 - alpha_j);\n            ++i;\n            ++ii;\n            --j;\n            --jj;\n        }\n        if (j < i) {\n            if ((local[ii - 1] - (local[jj + 1])) <= tolerance) {\n                removable = true;\n            }\n        }\n        else {\n            const alpha_i = (knots[index] - knots[i]) / (knots[i + this.degree + 1] - knots[i]);\n            if (((controlPoints[i] - ((local[ii + 1] * (alpha_i)))) + (local[ii - 1] * (1.0 - alpha_i))) <= tolerance) {\n                removable = true;\n            }\n        }\n        if (removable == false)\n            return;\n        else {\n            let i = first;\n            let j = last;\n            while (j > i) {\n                controlPoints[i] = local[i - offset];\n                controlPoints[j] = local[j - offset];\n                ++i;\n                --j;\n            }\n        }\n        this.knots.splice(index, 1);\n        const fout = (2 * index - multiplicity - this.degree) / 2;\n        controlPoints.splice(fout, 1);\n        return new BSplineR1toR1(controlPoints, knots);\n    }\n    moveControlPoint(i, delta) {\n        if (i < 0 || i >= this.controlPoints.length) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        let newControlPoints = this.controlPoints;\n        newControlPoints[i] += delta;\n        return new BSplineR1toR1(newControlPoints, this.knots);\n    }\n}\nexports.BSplineR1toR1 = BSplineR1toR1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseBSplineR1toR1 = void 0;\nconst Piegl_Tiller_NURBS_Book_1 = require(\"../Piegl_Tiller_NURBS_Book\");\nconst Vector2d_1 = require(\"../../mathVector/Vector2d\");\nconst BSplineR1toR2_1 = require(\"../R1toR2/BSplineR1toR2\");\n/**\n * A B-Spline function from a one dimensional real space to a one dimensional real space\n */\nclass BaseBSplineR1toR1 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [0], knots = [0, 1]) {\n        this._controlPoints = [];\n        this._knots = [];\n        this._degree = 0;\n        this._controlPoints = [...controlPoints];\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    computeDegree() {\n        let degree = this._knots.length - this._controlPoints.length - 1;\n        if (degree < 0) {\n            throw new Error(\"Negative degree BSplineR1toR1 are not supported\");\n        }\n        return degree;\n    }\n    get controlPoints() {\n        return [...this._controlPoints];\n    }\n    get knots() {\n        return [...this._knots];\n    }\n    get degree() {\n        return this._degree;\n    }\n    /**\n     * B-Spline evaluation\n     * @param u the parameter\n     * @returns the value of the B-Spline at u\n     */\n    evaluate(u) {\n        const span = (0, Piegl_Tiller_NURBS_Book_1.findSpan)(u, this.knots, this._degree);\n        const basis = (0, Piegl_Tiller_NURBS_Book_1.basisFunctions)(span, u, this.knots, this._degree);\n        let result = 0;\n        for (let i = 0; i < this._degree + 1; i += 1) {\n            result += basis[i] * this._controlPoints[span - this._degree + i];\n        }\n        return result;\n    }\n    distinctKnots() {\n        let result = [this._knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this._knots.length; i += 1) {\n            if (this._knots[i] !== temp) {\n                result.push(this._knots[i]);\n                temp = this._knots[i];\n            }\n        }\n        return result;\n    }\n    zeros(tolerance = 10e-8) {\n        //see : chapter 11 : Computing Zeros of Splines by Tom Lyche and Knut Morken for u_star method\n        let spline = this.clone();\n        let greville = [];\n        let maxError = tolerance * 2;\n        let vertexIndex = [];\n        let it = 0;\n        while (maxError > tolerance && it < 10e8) {\n            it += 1;\n            let maximum = 0;\n            let newKnots = [];\n            vertexIndex = findControlPointsFollowingSignChanges(spline);\n            greville = spline.grevilleAbscissae();\n            for (let v of vertexIndex) {\n                let uLeft = greville[v - 1];\n                let uRight = greville[v];\n                if (uRight - uLeft > maximum) {\n                    maximum = uRight - uLeft;\n                }\n                if (uRight - uLeft > tolerance) {\n                    let lineZero = this.robustFindLineZero(uLeft, spline.controlPoints[v - 1], uRight, spline.controlPoints[v]);\n                    newKnots.push(0.05 * (uLeft + uRight) / 2 + 0.95 * lineZero);\n                }\n            }\n            for (let knot of newKnots) {\n                spline = spline.insertKnot(knot);\n            }\n            maxError = maximum;\n        }\n        vertexIndex = findControlPointsFollowingSignChanges(spline);\n        let result = [];\n        for (let v of vertexIndex) {\n            result.push(greville[v]);\n        }\n        return result;\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this._degree + 1; j += 1) {\n                sum += this._knots[j];\n            }\n            result.push(sum / this._degree);\n        }\n        return result;\n    }\n    insertKnot(u, times = 1) {\n        if (times <= 0) {\n            return this.factory(this.controlPoints, this.knots);\n        }\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        let index = (0, Piegl_Tiller_NURBS_Book_1.findSpan)(u, knots, this._degree);\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index, knots);\n        }\n        for (let t = 0; t < times; t += 1) {\n            let newControlPoints = [];\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - knots[i]) / (knots[i + this._degree] - knots[i]);\n                newControlPoints[i] = controlPoints[i - 1] * (1 - alpha) + controlPoints[i] * alpha;\n            }\n            for (let i = index - multiplicity; i < controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = controlPoints[i];\n            }\n            knots.splice(index + 1, 0, u);\n            controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n        return this.factory(controlPoints, knots);\n    }\n    knotMultiplicity(indexFromFindSpan, knots = this.knots) {\n        let result = 0;\n        let i = 0;\n        while (knots[indexFromFindSpan + i] === knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    clamp(u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        let index = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(u, this.knots, this._degree);\n        let newControlPoints = [];\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        const times = this._degree - multiplicity + 1;\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - knots[i]) / (knots[i + this._degree] - knots[i]);\n                newControlPoints[i] = controlPoints[i - 1] * (1 - alpha) + controlPoints[i] * alpha;\n            }\n            for (let i = index - multiplicity; i < controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = controlPoints[i];\n            }\n            knots.splice(index + 1, 0, u);\n            controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n        return this.factory(controlPoints, knots);\n    }\n    curve() {\n        let x = this.grevilleAbscissae();\n        let cp = [];\n        for (let i = 0; i < x.length; i += 1) {\n            cp.push(new Vector2d_1.Vector2d(x[i], this._controlPoints[i]));\n        }\n        return new BSplineR1toR2_1.BSplineR1toR2(cp, this._knots.slice());\n    }\n    controlPolygonNumberOfSignChanges() {\n        let result = 0;\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            if (Math.sign(this._controlPoints[i]) !== Math.sign(this._controlPoints[i + 1])) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    controlPolygonZeros() {\n        let result = [];\n        let greville = this.grevilleAbscissae();\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            if (Math.sign(this._controlPoints[i]) !== Math.sign(this._controlPoints[i + 1])) {\n                result.push(this.findLineZero(greville[i], this._controlPoints[i], greville[i + 1], this._controlPoints[i + 1]));\n            }\n        }\n        return result;\n    }\n    findLineZero(x1, y1, x2, y2) {\n        // find the zero of the line y = ax + b\n        let a = (y2 - y1) / (x2 - x1);\n        let b = y1 - a * x1;\n        return -b / a;\n    }\n    robustFindLineZero(x1, y1, x2, y2) {\n        let result = this.findLineZero(x1, y1, x2, y2);\n        if (isNaN(result)) {\n            return x1;\n        }\n        return result;\n    }\n}\nexports.BaseBSplineR1toR1 = BaseBSplineR1toR1;\nfunction findControlPointsFollowingSignChanges(spline) {\n    let cpLeft = spline.controlPoints[0];\n    let vertexIndex = [];\n    for (let index = 1; index < spline.controlPoints.length; index += 1) {\n        let cpRight = spline.controlPoints[index];\n        if (cpLeft <= 0 && cpRight > 0) {\n            vertexIndex.push(index);\n        }\n        if (cpLeft >= 0 && cpRight < 0) {\n            vertexIndex.push(index);\n        }\n        cpLeft = cpRight;\n    }\n    if (spline.controlPoints[spline.controlPoints.length - 1] == 0) {\n        vertexIndex.push(spline.controlPoints.length - 1);\n    }\n    return vertexIndex;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.determinant2by2 = exports.splineRecomposition = exports.BernsteinDecompositionR1toR1 = void 0;\nconst BinomialCoefficient_1 = require(\"../BinomialCoefficient\");\nconst BSplineR1toR1_1 = require(\"./BSplineR1toR1\");\n/**\n* A Bernstein decomposition of a B-Spline function from a one dimensional real space to a one dimensional real space\n*/\nclass BernsteinDecompositionR1toR1 {\n    /**\n     *\n     * @param controlPointsArray An array of array of control points\n     */\n    constructor(controlPointsArray = []) {\n        this.controlPointsArray = controlPointsArray;\n    }\n    add(bd) {\n        let result = [];\n        for (let i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] + bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    subtract(bd) {\n        let result = [];\n        for (let i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] - bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    multiply(bd) {\n        return new BernsteinDecompositionR1toR1(this.bernsteinMultiplicationArray(this.controlPointsArray, bd.controlPointsArray));\n    }\n    multiplyRange(bd, start, lessThan) {\n        let result = [];\n        for (let i = start; i < lessThan; i += 1) {\n            result[i - start] = this.bernsteinMultiplication(this.controlPointsArray[i], bd.controlPointsArray[i]);\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    multiplyRange2(bd, start, lessThan) {\n        let result = [];\n        for (let i = start; i < lessThan; i += 1) {\n            result[i - start] = this.bernsteinMultiplication(this.controlPointsArray[i - start], bd.controlPointsArray[i]);\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    bernsteinMultiplicationArray(f, g) {\n        let result = [];\n        for (let i = 0; i < f.length; i += 1) {\n            result[i] = this.bernsteinMultiplication(f[i], g[i]);\n        }\n        return result;\n    }\n    bernsteinMultiplication(f, g) {\n        const f_degree = f.length - 1;\n        const g_degree = g.length - 1;\n        let result = [];\n        for (let k = 0; k < f_degree + g_degree + 1; k += 1) {\n            let cp = 0;\n            for (let i = Math.max(0, k - g_degree); i < Math.min(f_degree, k) + 1; i += 1) {\n                let bfu = BernsteinDecompositionR1toR1.binomial(f_degree, i);\n                let bgu = BernsteinDecompositionR1toR1.binomial(g_degree, k - i);\n                let bfugu = BernsteinDecompositionR1toR1.binomial(f_degree + g_degree, k);\n                cp += bfu * bgu / bfugu * f[i] * g[k - i];\n            }\n            result[k] = cp;\n        }\n        return result;\n    }\n    multiplyByScalar(value) {\n        let result = [];\n        for (let i = 0; i < this.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < this.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] * value;\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    addScalar(value) {\n        let result = [];\n        for (let i = 0; i < this.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < this.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] + value;\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    flattenControlPointsArray() {\n        return this.controlPointsArray.reduce(function (acc, val) {\n            return acc.concat(val);\n        }, []);\n    }\n    subset(start, lessThan) {\n        return new BernsteinDecompositionR1toR1(this.controlPointsArray.slice(start, lessThan));\n    }\n    elevateDegree(times = 1) {\n        let newControlPointsArray = [];\n        for (let cps of this.controlPointsArray) {\n            newControlPointsArray.push(this.elevateDegreeB(cps, times));\n        }\n        this.controlPointsArray = newControlPointsArray;\n    }\n    elevateDegreeB(controlPoints, times = 1) {\n        const degree = controlPoints.length - 1;\n        let result = [];\n        for (let i = 0; i < controlPoints.length + times; i += 1) {\n            let cp = 0;\n            for (let j = Math.max(0, i - times); j <= Math.min(degree, i); j += 1) {\n                const bc0 = (0, BinomialCoefficient_1.binomialCoefficient)(times, i - j);\n                const bc1 = (0, BinomialCoefficient_1.binomialCoefficient)(degree, j);\n                const bc2 = (0, BinomialCoefficient_1.binomialCoefficient)(degree + times, i);\n                cp += bc0 * bc1 / bc2 * controlPoints[j];\n            }\n            result.push(cp);\n        }\n        return result;\n    }\n    splineRecomposition(distinctKnots) {\n        const cp = this.flattenControlPointsArray();\n        const degree = this.getDegree();\n        let knots = [];\n        for (let distinctKnot of distinctKnots) {\n            for (let j = 0; j < degree + 1; j += 1) {\n                knots.push(distinctKnot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(cp, knots);\n    }\n    getDegree() {\n        return this.controlPointsArray[0].length - 1;\n    }\n}\nexports.BernsteinDecompositionR1toR1 = BernsteinDecompositionR1toR1;\nBernsteinDecompositionR1toR1.binomial = (0, BinomialCoefficient_1.memoizedBinomialCoefficient)();\nBernsteinDecompositionR1toR1.flopsCounter = 0;\nfunction splineRecomposition(bernsteinDecomposiiton, distinctKnots) {\n    const cp = bernsteinDecomposiiton.flattenControlPointsArray();\n    const degree = bernsteinDecomposiiton.getDegree();\n    let knots = [];\n    for (let distinctKnot of distinctKnots) {\n        for (let j = 0; j < degree + 1; j += 1) {\n            knots.push(distinctKnot);\n        }\n    }\n    return new BSplineR1toR1_1.BSplineR1toR1(cp, knots);\n}\nexports.splineRecomposition = splineRecomposition;\nfunction determinant2by2(ax, ay, bx, by) {\n    return (ax.multiply(by)).subtract(bx.multiply(ay));\n}\nexports.determinant2by2 = determinant2by2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.create_BSplineR1toR2 = exports.BSplineR1toR2 = void 0;\nconst Piegl_Tiller_NURBS_Book_1 = require(\"../Piegl_Tiller_NURBS_Book\");\nconst Vector2d_1 = require(\"../../mathVector/Vector2d\");\nconst BaseBSplineR1toR2_1 = require(\"./BaseBSplineR1toR2\");\nconst BSplineR1toR2DifferentialProperties_1 = require(\"./BSplineR1toR2DifferentialProperties\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass BSplineR1toR2 extends BaseBSplineR1toR2_1.BaseBSplineR1toR2 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector2d_1.Vector2d(0, 0)], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    factory(controlPoints = [new Vector2d_1.Vector2d(0, 0)], knots = [0, 1]) {\n        return new BSplineR1toR2(controlPoints, knots);\n    }\n    get freeControlPoints() {\n        return this.controlPoints;\n    }\n    /**\n     * Return a deep copy of this b-spline\n     */\n    clone() {\n        let cloneControlPoints = (0, BaseBSplineR1toR2_1.deepCopyControlPoints)(this._controlPoints);\n        return new BSplineR1toR2(cloneControlPoints, this._knots.slice());\n    }\n    optimizerStep(step) {\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            this._controlPoints[i].x += step[i];\n            this._controlPoints[i].y += step[i + this._controlPoints.length];\n        }\n    }\n    /**\n     *\n     * @param fromU Parametric position where the section start\n     * @param toU Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    extract(fromU, toU) {\n        let spline = this.clone();\n        spline = spline.clamp(fromU);\n        spline = spline.clamp(toU);\n        const newFromSpan = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(fromU, spline._knots, spline._degree);\n        const newToSpan = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(toU, spline._knots, spline._degree);\n        let newKnots = [];\n        let newControlPoints = [];\n        for (let i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (let i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector2d_1.Vector2d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSplineR1toR2(newControlPoints, newKnots);\n    }\n    elevateDegree() {\n        const s = this.generateIntermediateSplinesForDegreeElevation();\n        let splineHigherDegree = new BSplineR1toR2(s.controlPolygons[0], s.knotVectors[0]);\n        if (this.knotMultiplicity(this._knots[0]) !== this._degree + 1 || this.knotMultiplicity(this.knots[this._knots.length - 1]) !== this._degree + 1) {\n            for (let i = 1; i <= this._degree; i += 1) {\n                let splineTemp = new BSplineR1toR2(s.controlPolygons[i], s.knotVectors[i]);\n                let j = 0;\n                while (j < splineHigherDegree.knots.length) {\n                    if (splineHigherDegree.knots[j] !== splineTemp.knots[j] && splineHigherDegree.knots[j] < splineTemp.knots[j]) {\n                        splineTemp = splineTemp.insertKnot(splineHigherDegree.knots[j]);\n                    }\n                    else if (splineHigherDegree.knots[j] !== splineTemp.knots[j] && splineHigherDegree.knots[j] > splineTemp.knots[j]) {\n                        splineHigherDegree = splineHigherDegree.insertKnot(splineTemp.knots[j]);\n                    }\n                    j += 1;\n                }\n                for (let ind = 0; ind < splineHigherDegree.controlPoints.length; ind += 1) {\n                    let cp = splineHigherDegree.controlPoints[ind].add(splineTemp.controlPoints[ind]);\n                    let cps = splineHigherDegree.controlPoints;\n                    cps[ind] = cp;\n                    splineHigherDegree = new BSplineR1toR2(cps, splineHigherDegree.knots);\n                }\n            }\n            for (let j = 0; j < splineHigherDegree.controlPoints.length; j += 1) {\n                let cp = splineHigherDegree.controlPoints[j].multiply(1 / (this.degree + 1));\n                let cps = splineHigherDegree.controlPoints;\n                cps[j] = cp;\n                splineHigherDegree = new BSplineR1toR2(cps, splineHigherDegree.knots);\n            }\n        }\n        else\n            throw new Error('incompatible knot vector of the input spline');\n        return new BSplineR1toR2(splineHigherDegree.controlPoints, splineHigherDegree.knots);\n    }\n    generateIntermediateSplinesForDegreeElevation() {\n        let knotVectors = [];\n        let controlPolygons = [];\n        for (let i = 0; i <= this.degree; i += 1) {\n            let knotVector = this.knots.slice();\n            let controlPolygon = this.controlPoints.slice();\n            let k = 0;\n            for (let j = i; j < this.knots.length; j += this.degree + 1) {\n                knotVector.splice((j + k), 0, this.knots[j]);\n                if (j < this.controlPoints.length) {\n                    let controlPoint = this.controlPoints[j];\n                    controlPolygon.splice((j + k), 0, controlPoint);\n                }\n                k += 1;\n            }\n            knotVectors.push(knotVector);\n            controlPolygons.push(controlPolygon);\n        }\n        return {\n            knotVectors: knotVectors,\n            controlPolygons: controlPolygons\n        };\n    }\n    /*\n        elevateDegreeWithRemoveKnot() {\n            const sx = new BSplineR1toR1(this.getControlPointsX(), this.knots)\n            const sy = new BSplineR1toR1(this.getControlPointsY(), this.knots)\n            const bdsx = sx.bernsteinDecomposition()\n            const bdsy = sy.bernsteinDecomposition()\n            bdsx.elevateDegree()\n            bdsy.elevateDegree()\n    \n            const knots = this.distinctKnots()\n    \n    \n            const sxNew = splineRecomposition(bdsx, knots)\n            const syNew = splineRecomposition(bdsy, knots)\n    \n            let newcp: Vector2d[] = []\n            for (let i = 0; i < sxNew.controlPoints.length; i += 1) {\n                newcp.push(new Vector2d(sxNew.controlPoints[i], syNew.controlPoints[i]))\n            }\n            let newSpline = new BSplineR1toR2(newcp, sxNew.knots)\n    \n            for (let i = 0; i < knots.length; i += 1) {\n                let m = this.knotMultiplicity(findSpan(knots[i], this.knots, this.degree))\n                for (let j = 0; j < newSpline.degree - m - 1; j += 1) {\n                    newSpline.removeKnot(findSpan(newSpline.knots[i], newSpline.knots, newSpline.degree))\n                }\n            }\n    \n            \n            this.controlPoints = newSpline.controlPoints\n            this.knots = newSpline.knots\n            this._degree = newSpline.degree\n            \n            \n            return newSpline\n        }\n    \n        removeKnot(indexFromFindSpan: number, tolerance: number = 10e-5) {\n            //Piegl and Tiller, The NURBS book, p : 185\n        \n            const index = indexFromFindSpan\n    \n            // end knots are not removed\n            if (index > this._degree && index < this.knots.length-this._degree - 1) {\n                throw new Error(\"index out of range\")\n            }\n            \n            //const double tolerance = 1;\n            \n            const multiplicity = this.knotMultiplicity(index);\n            \n            const last = index - multiplicity\n            const first = index -this.degree\n            const offset = first -1;\n            //std::vector<vectorType> local(2*degree+1);\n            let local: Vector2d[] = []\n            local[0] = this.controlPoints[offset];\n            local[last+1-offset] = this.controlPoints[last+1];\n            let i = first;\n            let j = last;\n            let ii = 1;\n            let jj = last - offset;\n            let removable = false;\n            \n            // Compute new control point for one removal step\n            while (j>i){\n                let alpha_i = (this.knots[index] - this.knots[i])/(this.knots[i+this.degree+1]-this.knots[i]);\n                let alpha_j = (this.knots[index] - this.knots[j])/(this.knots[j+this.degree+1] - this.knots[j]);\n                local[ii] = (this._controlPoints[i].subtract(local[ii-1].multiply(1.0-alpha_i))).multiply(1 / alpha_i )\n                local[jj] = (this._controlPoints[j].subtract(local[jj+1].multiply(alpha_j))).multiply(1 / (1.0-alpha_j) )\n                ++i;\n                ++ii;\n                --j;\n                --jj;\n            }\n            \n            if (j < i) {\n                if ((local[ii-1].subtract(local[jj+1])).norm() <= tolerance){\n                    removable = true;\n                }\n            }\n            else {\n                const alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i+this.degree+1]-this.knots[i]) ;\n                if ( ((this._controlPoints[i].subtract((local[ii+1].multiply(alpha_i)))).add (local[ii-1].multiply(1.0- alpha_i))).norm() <= tolerance) {\n                    removable = true;\n                }\n            }\n            \n            if (!removable) return;\n            else {\n                let iii = first;\n                let jjj = last;\n                while (jjj > i) {\n                    this._controlPoints[iii] = local[iii-offset];\n                    this._controlPoints[jjj] = local[jjj-offset];\n                    ++iii;\n                    --jjj;\n                }\n            }\n            \n            this.knots.splice(index, 1)\n            \n            const fout = (2*index - multiplicity - this.degree) / 2;\n            this._controlPoints.splice(fout, 1);\n        }\n    \n        */\n    distinctKnots() {\n        let result = [this.knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    }\n    getDifferentialProperties() {\n        return new BSplineR1toR2DifferentialProperties_1.BSplineR1toR2DifferentialProperties(this);\n    }\n    insertKnot(u, times = 1) {\n        return super.insertKnot(u, times);\n    }\n    clamp(u) {\n        return super.clamp(u);\n    }\n}\nexports.BSplineR1toR2 = BSplineR1toR2;\nfunction create_BSplineR1toR2(controlPoints, knots) {\n    let newControlPoints = [];\n    for (let cp of controlPoints) {\n        newControlPoints.push(new Vector2d_1.Vector2d(cp[0], cp[1]));\n    }\n    return new BSplineR1toR2(newControlPoints, knots);\n}\nexports.create_BSplineR1toR2 = create_BSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BSplineR1toR2DifferentialProperties = void 0;\nconst BaseBSplineR1toR2DifferentialProperties_1 = require(\"./BaseBSplineR1toR2DifferentialProperties\");\nconst BSplineR1toR1_1 = require(\"../R1toR1/BSplineR1toR1\");\nclass BSplineR1toR2DifferentialProperties extends BaseBSplineR1toR2DifferentialProperties_1.BaseBSplineR1toR2DifferentialProperties {\n    constructor(spline) {\n        super(spline);\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n}\nexports.BSplineR1toR2DifferentialProperties = BSplineR1toR2DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepCopyControlPoints = exports.BaseBSplineR1toR2 = void 0;\nconst Piegl_Tiller_NURBS_Book_1 = require(\"../Piegl_Tiller_NURBS_Book\");\nconst Vector2d_1 = require(\"../../mathVector/Vector2d\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass BaseBSplineR1toR2 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector2d_1.Vector2d(0, 0)], knots = [0, 1]) {\n        this._controlPoints = deepCopyControlPoints(controlPoints);\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    computeDegree() {\n        let degree = this._knots.length - this._controlPoints.length - 1;\n        if (degree < 0) {\n            throw new Error(\"Negative degree BSplineR1toR1 are not supported\");\n        }\n        return degree;\n    }\n    get controlPoints() {\n        return deepCopyControlPoints(this._controlPoints);\n    }\n    get knots() {\n        return [...this._knots];\n    }\n    get degree() {\n        return this._degree;\n    }\n    getControlPoint(index) {\n        return this._controlPoints[index].clone();\n    }\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    evaluate(u) {\n        const span = (0, Piegl_Tiller_NURBS_Book_1.findSpan)(u, this._knots, this._degree);\n        const basis = (0, Piegl_Tiller_NURBS_Book_1.basisFunctions)(span, u, this._knots, this._degree);\n        let result = new Vector2d_1.Vector2d(0, 0);\n        for (let i = 0; i < this._degree + 1; i += 1) {\n            result.x += basis[i] * this._controlPoints[span - this._degree + i].x;\n            result.y += basis[i] * this._controlPoints[span - this._degree + i].y;\n        }\n        return result;\n    }\n    //abstract optimizerStep(step: number[]) : void\n    getControlPointsX() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.x);\n        }\n        return result;\n    }\n    getControlPointsY() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.y);\n        }\n        return result;\n    }\n    getDistinctKnots() {\n        let result = [this._knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this._knots.length; i += 1) {\n            if (this._knots[i] !== temp) {\n                result.push(this._knots[i]);\n                temp = this._knots[i];\n            }\n        }\n        return result;\n    }\n    moveControlPoint(i, delta) {\n        if (i < 0 || i >= this._controlPoints.length - this._degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        let controlPoints = this.controlPoints;\n        controlPoints[i].add(delta);\n        return this.factory(controlPoints, this.knots);\n    }\n    moveControlPoints(delta) {\n        const n = this._controlPoints.length;\n        if (delta.length !== n) {\n            throw new Error(\"Array of unexpected dimension\");\n        }\n        let controlPoints = this.controlPoints;\n        for (let i = 0; i < n; i += 1) {\n            controlPoints[i] = controlPoints[i].add(delta[i]);\n        }\n        return this.factory(controlPoints, this._knots);\n    }\n    setControlPointPosition(index, value) {\n        let controlPoints = this.controlPoints;\n        controlPoints[index] = value;\n        return this.factory(controlPoints, this._knots);\n    }\n    insertKnot(u, times = 1) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        if (times <= 0) {\n            return this.factory(this.controlPoints, this.knots);\n        }\n        let index = (0, Piegl_Tiller_NURBS_Book_1.findSpan)(u, this._knots, this._degree);\n        let multiplicity = 0;\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (let t = 0; t < times; t += 1) {\n            let newControlPoints = [];\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - knots[i]) / (knots[i + this._degree] - knots[i]);\n                newControlPoints[i] = (controlPoints[i - 1].multiply(1 - alpha)).add(controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = controlPoints[i];\n            }\n            knots.splice(index + 1, 0, u);\n            controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n        return this.factory(controlPoints, knots);\n    }\n    knotMultiplicity(indexFromFindSpan) {\n        let result = 0;\n        let i = 0;\n        while (this._knots[indexFromFindSpan + i] === this._knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this._degree + 1; j += 1) {\n                sum += this._knots[j];\n            }\n            result.push(sum / this._degree);\n        }\n        return result;\n    }\n    clamp(u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        let index = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(u, this._knots, this._degree);\n        let newControlPoints = [];\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        const times = this._degree - multiplicity + 1;\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - knots[i]) / (knots[i + this._degree] - knots[i]);\n                newControlPoints[i] = (controlPoints[i - 1].multiply(1 - alpha)).add(controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = controlPoints[i];\n            }\n            knots.splice(index + 1, 0, u);\n            controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n        return this.factory(controlPoints, knots);\n    }\n}\nexports.BaseBSplineR1toR2 = BaseBSplineR1toR2;\nfunction deepCopyControlPoints(controlPoints) {\n    let result = [];\n    for (let cp of controlPoints) {\n        result.push(cp.clone());\n    }\n    return result;\n}\nexports.deepCopyControlPoints = deepCopyControlPoints;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseBSplineR1toR2DifferentialProperties = void 0;\nconst BSplineR1toR1_1 = require(\"../R1toR1/BSplineR1toR1\");\nclass BaseBSplineR1toR2DifferentialProperties {\n    constructor(spline) {\n        this._spline = spline.clone();\n    }\n    expensiveComputation(spline) {\n        const sx = this.bSplineR1toR1Factory(spline.getControlPointsX(), spline.knots);\n        const sy = this.bSplineR1toR1Factory(spline.getControlPointsY(), spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const bdsxu = sxu.bernsteinDecomposition();\n        const bdsyu = syu.bernsteinDecomposition();\n        const bdsxuu = sxuu.bernsteinDecomposition();\n        const bdsyuu = syuu.bernsteinDecomposition();\n        const bdsxuuu = sxuuu.bernsteinDecomposition();\n        const bdsyuuu = syuuu.bernsteinDecomposition();\n        const h1 = (bdsxu.multiply(bdsxu)).add((bdsyu.multiply(bdsyu)));\n        const h2 = (bdsxu.multiply(bdsyuuu)).subtract((bdsyu.multiply(bdsxuuu)));\n        const h3 = (bdsxu.multiply(bdsxuu)).add((bdsyu.multiply(bdsyuu)));\n        const h4 = (bdsxu.multiply(bdsyuu)).subtract((bdsyu.multiply(bdsxuu)));\n        return {\n            h1: h1,\n            h2: h2,\n            h3: h3,\n            h4: h4\n        };\n    }\n    curvatureNumerator() {\n        const e = this.expensiveComputation(this._spline);\n        const distinctKnots = this._spline.getDistinctKnots();\n        const controlPoints = e.h4.flattenControlPointsArray();\n        const curvatureNumeratorDegree = 2 * this._spline.degree - 3;\n        let knots = [];\n        for (let knot of distinctKnots) {\n            for (let j = 0; j < curvatureNumeratorDegree + 1; j += 1) {\n                knots.push(knot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    h1() {\n        const e = this.expensiveComputation(this._spline);\n        const distinctKnots = this._spline.getDistinctKnots();\n        const controlPoints = e.h1.flattenControlPointsArray();\n        const h1Degree = 2 * this._spline.degree - 2;\n        let knots = [];\n        for (let knot of distinctKnots) {\n            for (let j = 0; j < h1Degree + 1; j += 1) {\n                knots.push(knot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    inflections(curvatureNumerator) {\n        if (!curvatureNumerator) {\n            curvatureNumerator = this.curvatureNumerator();\n        }\n        const zeros = curvatureNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        return result;\n    }\n    curvatureDerivativeNumerator() {\n        const e = this.expensiveComputation(this._spline);\n        const bd_curvatureDerivativeNumerator = (e.h1.multiply(e.h2)).subtract(e.h3.multiply(e.h4).multiplyByScalar(3));\n        const distinctKnots = this._spline.getDistinctKnots();\n        const controlPoints = bd_curvatureDerivativeNumerator.flattenControlPointsArray();\n        const curvatureDerivativeNumeratorDegree = 4 * this._spline.degree - 6;\n        let knots = [];\n        for (let knot of distinctKnots) {\n            for (let j = 0; j < curvatureDerivativeNumeratorDegree + 1; j += 1) {\n                knots.push(knot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    curvatureExtrema(_curvatureDerivativeNumerator) {\n        if (!_curvatureDerivativeNumerator) {\n            _curvatureDerivativeNumerator = this.curvatureDerivativeNumerator();\n        }\n        const zeros = _curvatureDerivativeNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        return result;\n    }\n}\nexports.BaseBSplineR1toR2DifferentialProperties = BaseBSplineR1toR2DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.create_RationalBSplineR1toR2 = exports.RationalBSplineR1toR2 = void 0;\nconst Vector2d_1 = require(\"../../mathVector/Vector2d\");\nconst Vector3d_1 = require(\"../../mathVector/Vector3d\");\nconst BSplineR1toR3_1 = require(\"../R1toR3/BSplineR1toR3\");\nconst RationalBSplineR1toR2Adapter_1 = require(\"./RationalBSplineR1toR2Adapter\");\nconst RationalBSplineR1toR2DifferentialProperties_1 = require(\"./RationalBSplineR1toR2DifferentialProperties\");\nclass RationalBSplineR1toR2 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector3d_1.Vector3d(0, 0, 1)], knots = [0, 1]) {\n        this.spline = new BSplineR1toR3_1.BSplineR1toR3(controlPoints, knots);\n    }\n    get knots() {\n        return this.spline.knots;\n    }\n    get degree() {\n        return this.spline.degree;\n    }\n    get controlPoints() {\n        return this.spline.controlPoints;\n    }\n    get freeControlPoints() {\n        return this.spline.freeControlPoints;\n    }\n    evaluate(u) {\n        let result = this.spline.evaluate(u);\n        return new Vector2d_1.Vector2d(result.x / result.z, result.y / result.z);\n    }\n    controlPoints2D() {\n        let result = [];\n        for (let cp of this.spline.controlPoints) {\n            result.push(new Vector2d_1.Vector2d(cp.x / cp.z, cp.y / cp.z));\n        }\n        return result;\n    }\n    clone() {\n        return new RationalBSplineR1toR2(this.spline.controlPoints, this.spline.knots);\n    }\n    insertKnot(u, times = 1) {\n        let s = this.spline.insertKnot(u, times);\n        return new RationalBSplineR1toR2(s.controlPoints, s.knots);\n    }\n    /*\n    optimizerStep(step: number[]) {\n        this.spline.optimizerStep(step)\n    }\n    */\n    moveControlPoints(delta) {\n        const s = this.spline.moveControlPoints(delta);\n        return new RationalBSplineR1toR2(s.controlPoints, s.knots);\n    }\n    extract(fromU, toU) {\n        return this.spline.extract(fromU, toU);\n    }\n    getControlPointsX() {\n        return this.spline.getControlPointsX();\n    }\n    getControlPointsY() {\n        return this.spline.getControlPointsY();\n    }\n    getControlPointsW() {\n        return this.spline.getControlPointsZ();\n    }\n    setControlPointPosition(index, value) {\n        const s = this.spline.setControlPointPosition(index, value);\n        return new RationalBSplineR1toR2(s.controlPoints, s.knots);\n    }\n    setControlPointWeight(controlPointIndex, w) {\n        const x = this.controlPoints[controlPointIndex].x;\n        const y = this.controlPoints[controlPointIndex].y;\n        const z = this.controlPoints[controlPointIndex].z;\n        const s = this.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(x * w / z, y * w / z, w));\n        return new RationalBSplineR1toR2(s.controlPoints, s.knots);\n    }\n    getControlPointWeight(controlPointIndex) {\n        return this.controlPoints[controlPointIndex].z;\n    }\n    distinctKnots() {\n        let result = [this.knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    }\n    getSplineAdapter() {\n        return new RationalBSplineR1toR2Adapter_1.RationalBSplineR1toR2Adapter(this.controlPoints, this.knots);\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this.spline.controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this.spline.degree + 1; j += 1) {\n                sum += this.spline.knots[j];\n            }\n            result.push(sum / this.spline.degree);\n        }\n        return result;\n    }\n    elevateDegree() {\n        this.spline.elevateDegree();\n    }\n    getDifferentialProperties() {\n        return new RationalBSplineR1toR2DifferentialProperties_1.RationalBSplineR1toR2DifferentialProperties(this);\n    }\n}\nexports.RationalBSplineR1toR2 = RationalBSplineR1toR2;\nfunction create_RationalBSplineR1toR2(controlPoints, knots) {\n    let newControlPoints = [];\n    for (let cp of controlPoints) {\n        newControlPoints.push(new Vector3d_1.Vector3d(cp[0], cp[1], cp[2]));\n    }\n    return new RationalBSplineR1toR2(newControlPoints, knots);\n}\nexports.create_RationalBSplineR1toR2 = create_RationalBSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RationalBSplineR1toR2Adapter = void 0;\nconst Vector3d_1 = require(\"../../mathVector/Vector3d\");\nconst RationalBSplineR1toR2_1 = require(\"./RationalBSplineR1toR2\");\nclass RationalBSplineR1toR2Adapter {\n    constructor(controlPoints = [new Vector3d_1.Vector3d(0, 0, 1)], knots = [0, 1]) {\n        this._spline = new RationalBSplineR1toR2_1.RationalBSplineR1toR2(controlPoints, knots);\n    }\n    getControlPointsX() {\n        let result = [];\n        for (let cp of this._spline.controlPoints) {\n            result.push(cp.x);\n        }\n        return result;\n    }\n    getControlPointsY() {\n        let result = [];\n        for (let cp of this._spline.controlPoints) {\n            result.push(cp.y);\n        }\n        return result;\n    }\n    moveControlPoint(i, delta) {\n        if (i < 0 || i >= this._spline.controlPoints.length - this._spline.degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        const z = this._spline.controlPoints[i].z;\n        let controlPoints = this._spline.controlPoints;\n        controlPoints[i].x += delta.x * z;\n        controlPoints[i].y += delta.y * z;\n        return new RationalBSplineR1toR2Adapter(controlPoints, this.knots);\n    }\n    moveControlPoints(delta) {\n        const n = this._spline.controlPoints.length;\n        if (delta.length !== n) {\n            throw new Error(\"Array of unexpected dimension\");\n        }\n        let controlPoints = this._spline.controlPoints;\n        for (let i = 0; i < n; i += 1) {\n            const z = this._spline.controlPoints[i].z;\n            controlPoints[i].x += delta[i].x * z;\n            controlPoints[i].y += delta[i].y * z;\n        }\n        return new RationalBSplineR1toR2Adapter(controlPoints, this.knots);\n    }\n    setControlPointPosition(index, value) {\n        const z = this._spline.controlPoints[index].z;\n        let s = this._spline.setControlPointPosition(index, new Vector3d_1.Vector3d(value.x * z, value.y * z, z));\n        return new RationalBSplineR1toR2Adapter(s.controlPoints, s.knots);\n    }\n    get degree() {\n        return this._spline.degree;\n    }\n    get knots() {\n        return this._spline.knots;\n    }\n    get controlPoints() {\n        return this._spline.controlPoints2D();\n    }\n    get freeControlPoints() {\n        return this._spline.controlPoints2D();\n    }\n    clone() {\n        return new RationalBSplineR1toR2Adapter(this._spline.controlPoints, this._spline.knots);\n    }\n    evaluate(u) {\n        return this._spline.evaluate(u);\n    }\n    /*\n    optimizerStep(step: number[]): void {\n    }\n    */\n    getRationalBSplineR1toR2() {\n        return this._spline.clone();\n    }\n    setControlPointWeight(controlPointIndex, w) {\n        const x = this._spline.controlPoints[controlPointIndex].x;\n        const y = this._spline.controlPoints[controlPointIndex].y;\n        const z = this._spline.controlPoints[controlPointIndex].z;\n        this._spline.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(x * w / z, y * w / z, w));\n    }\n    getControlPointWeight(controlPointIndex) {\n        return this._spline.controlPoints[controlPointIndex].z;\n    }\n    getDifferentialProperties() {\n        return this._spline.getDifferentialProperties();\n    }\n}\nexports.RationalBSplineR1toR2Adapter = RationalBSplineR1toR2Adapter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RationalBSplineR1toR2DifferentialProperties = void 0;\nconst BernsteinDecompositionR1toR1_1 = require(\"../R1toR1/BernsteinDecompositionR1toR1\");\nconst BSplineR1toR1_1 = require(\"../R1toR1/BSplineR1toR1\");\nclass RationalBSplineR1toR2DifferentialProperties {\n    constructor(spline) {\n        this.spline = spline.clone();\n        this.derivatives = this.computeDerivatives();\n        this.ChenTerms = this.ComputeChenTerms();\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    computeDerivatives() {\n        const sx = this.bSplineR1toR1Factory(this.spline.getControlPointsX(), this.spline.knots);\n        const sy = this.bSplineR1toR1Factory(this.spline.getControlPointsY(), this.spline.knots);\n        const sw = this.bSplineR1toR1Factory(this.spline.getControlPointsW(), this.spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const swu = sw.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const swuu = swu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const swuuu = swuu.derivative();\n        return {\n            x: sx.bernsteinDecomposition(),\n            y: sy.bernsteinDecomposition(),\n            w: sw.bernsteinDecomposition(),\n            xu: sxu.bernsteinDecomposition(),\n            yu: syu.bernsteinDecomposition(),\n            wu: swu.bernsteinDecomposition(),\n            xuu: sxuu.bernsteinDecomposition(),\n            yuu: syuu.bernsteinDecomposition(),\n            wuu: swuu.bernsteinDecomposition(),\n            xuuu: sxuuu.bernsteinDecomposition(),\n            yuuu: syuuu.bernsteinDecomposition(),\n            wuuu: swuuu.bernsteinDecomposition()\n        };\n    }\n    ComputeChenTerms() {\n        // reference: XIANMING CHEN, COMPLEXITY REDUCTION FOR SYMBOLIC COMPUTATION WITH RATIONAL B-SPLINES\n        const s = this.derivatives;\n        return {\n            w: s.w,\n            wu: s.wu,\n            D1x: (s.xu.multiply(s.w)).subtract(s.x.multiply(s.wu)),\n            D1y: (s.yu.multiply(s.w)).subtract(s.y.multiply(s.wu)),\n            D2x: (s.xuu.multiply(s.w)).subtract(s.x.multiply(s.wuu)),\n            D2y: (s.yuu.multiply(s.w)).subtract(s.y.multiply(s.wuu)),\n            D3x: (s.xuuu.multiply(s.w)).subtract(s.x.multiply(s.wuuu)),\n            D3y: (s.yuuu.multiply(s.w)).subtract(s.y.multiply(s.wuuu)),\n            D21x: (s.xuu.multiply(s.wu)).subtract(s.xu.multiply(s.wuu)),\n            D21y: (s.yuu.multiply(s.wu)).subtract(s.yu.multiply(s.wuu))\n        };\n    }\n    curvatureNumerator() {\n        // reference: XIANMING CHEN, COMPLEXITY REDUCTION FOR SYMBOLIC COMPUTATION WITH RATIONAL B-SPLINES\n        const s = this.derivatives;\n        const t1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xu, s.yu, s.xuu, s.yuu).multiply(s.w);\n        const t2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.x, s.y, s.xuu, s.yuu).multiply(s.wu);\n        const t3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xu, s.yu, s.x, s.y).multiply(s.wuu);\n        const distinctKnots = this.spline.distinctKnots();\n        return (t1.subtract(t2).subtract(t3)).splineRecomposition(distinctKnots);\n    }\n    inflections(curvatureNumerator) {\n        if (!curvatureNumerator) {\n            curvatureNumerator = this.curvatureNumerator();\n        }\n        const zeros = curvatureNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this.spline.evaluate(z));\n        }\n        return result;\n    }\n    curvatureDerivativeNumerator() {\n        const s = this.derivatives;\n        const ct = this.ChenTerms;\n        const t0 = (ct.D1x.multiply(ct.D1x)).add(ct.D1y.multiply(ct.D1y));\n        const t1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D3x, ct.D3y);\n        const t2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D21x, ct.D21y);\n        const t3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D2x, ct.D2y);\n        const t4 = s.wu.multiplyByScalar(2);\n        const t5 = (ct.D1x.multiply(ct.D2x)).add(ct.D1y.multiply(ct.D2y)).multiplyByScalar(3);\n        const distinctKnots = this.spline.distinctKnots();\n        return ((t1.add(t2)).multiply(t0).multiply(s.w)).add(t4.multiply(t3).multiply(t0)).subtract(t5.multiply(t3).multiply(s.w)).splineRecomposition(distinctKnots);\n    }\n    curvatureExtrema(_curvatureDerivativeNumerator) {\n        if (!_curvatureDerivativeNumerator) {\n            _curvatureDerivativeNumerator = this.curvatureDerivativeNumerator();\n        }\n        const zeros = _curvatureDerivativeNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this.spline.evaluate(z));\n        }\n        return result;\n    }\n}\nexports.RationalBSplineR1toR2DifferentialProperties = RationalBSplineR1toR2DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.create_BSplineR1toR3 = exports.BSplineR1toR3 = void 0;\nconst Piegl_Tiller_NURBS_Book_1 = require(\"../Piegl_Tiller_NURBS_Book\");\nconst Vector3d_1 = require(\"../../mathVector/Vector3d\");\nconst BaseBSplineR1toR3_1 = require(\"./BaseBSplineR1toR3\");\nconst BSplineR1toR1_1 = require(\"../R1toR1/BSplineR1toR1\");\nconst BernsteinDecompositionR1toR1_1 = require(\"../R1toR1/BernsteinDecompositionR1toR1\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass BSplineR1toR3 extends BaseBSplineR1toR3_1.BaseBSplineR1toR3 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector3d_1.Vector3d(0, 0, 0)], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    factory(controlPoints = [new Vector3d_1.Vector3d(0, 0, 0)], knots = [0, 1]) {\n        return new BSplineR1toR3(controlPoints, knots);\n    }\n    get freeControlPoints() {\n        return this.controlPoints;\n    }\n    /**\n     * Return a deep copy of this b-spline\n     */\n    clone() {\n        let cloneControlPoints = (0, BaseBSplineR1toR3_1.deepCopyControlPoints)(this._controlPoints);\n        return new BSplineR1toR3(cloneControlPoints, this._knots.slice());\n    }\n    /*\n    optimizerStep(step: number[]) {\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            this._controlPoints[i].x += step[i]\n            this._controlPoints[i].y += step[i + this._controlPoints.length]\n            this._controlPoints[i].z += step[i + 2 * this._controlPoints.length]\n        }\n    }\n    */\n    /**\n     *\n     * @param fromU Parametric position where the section start\n     * @param toU Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    extract(fromU, toU) {\n        let spline = this.clone();\n        spline.clamp(fromU);\n        spline.clamp(toU);\n        const newFromSpan = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(fromU, spline._knots, spline._degree);\n        const newToSpan = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(toU, spline._knots, spline._degree);\n        let newKnots = [];\n        let newControlPoints = [];\n        for (let i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (let i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector3d_1.Vector3d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSplineR1toR3(newControlPoints, newKnots);\n    }\n    elevateDegree() {\n        const sx = new BSplineR1toR1_1.BSplineR1toR1(this.getControlPointsX(), this.knots);\n        const sy = new BSplineR1toR1_1.BSplineR1toR1(this.getControlPointsY(), this.knots);\n        const sz = new BSplineR1toR1_1.BSplineR1toR1(this.getControlPointsZ(), this.knots);\n        const bdsx = sx.bernsteinDecomposition();\n        const bdsy = sy.bernsteinDecomposition();\n        const bdsz = sz.bernsteinDecomposition();\n        bdsx.elevateDegree();\n        bdsy.elevateDegree();\n        bdsz.elevateDegree();\n        const knots = this.distinctKnots();\n        const sxNew = (0, BernsteinDecompositionR1toR1_1.splineRecomposition)(bdsx, knots);\n        const syNew = (0, BernsteinDecompositionR1toR1_1.splineRecomposition)(bdsy, knots);\n        const szNew = (0, BernsteinDecompositionR1toR1_1.splineRecomposition)(bdsz, knots);\n        let newcp = [];\n        for (let i = 0; i < sxNew.controlPoints.length; i += 1) {\n            newcp.push(new Vector3d_1.Vector3d(sxNew.controlPoints[i], syNew.controlPoints[i], szNew.controlPoints[i]));\n        }\n        let newSpline = new BSplineR1toR3(newcp, sxNew.knots);\n        for (let i = 0; i < knots.length; i += 1) {\n            let m = this.knotMultiplicity((0, Piegl_Tiller_NURBS_Book_1.findSpan)(knots[i], this.knots, this.degree));\n            for (let j = 0; j < newSpline.degree - m - 1; j += 1) {\n                newSpline = newSpline.removeKnot((0, Piegl_Tiller_NURBS_Book_1.findSpan)(newSpline.knots[i], newSpline.knots, newSpline.degree));\n            }\n        }\n        return newSpline;\n    }\n    removeKnot(indexFromFindSpan, tolerance = 10e-5) {\n        //Piegl and Tiller, The NURBS book, p : 185\n        const index = indexFromFindSpan;\n        // end knots are not removed\n        if (index > this._degree && index < this.knots.length - this._degree - 1) {\n            throw new Error(\"index out of range\");\n        }\n        //const double tolerance = 1;\n        const multiplicity = this.knotMultiplicity(index);\n        const last = index - multiplicity;\n        const first = index - this.degree;\n        const offset = first - 1;\n        //std::vector<vectorType> local(2*degree+1);\n        let local = [];\n        local[0] = this.controlPoints[offset];\n        local[last + 1 - offset] = this.controlPoints[last + 1];\n        let i = first;\n        let j = last;\n        let ii = 1;\n        let jj = last - offset;\n        let removable = false;\n        // Compute new control point for one removal step\n        while (j > i) {\n            let alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i + this.degree + 1] - this.knots[i]);\n            let alpha_j = (this.knots[index] - this.knots[j]) / (this.knots[j + this.degree + 1] - this.knots[j]);\n            local[ii] = (this.controlPoints[i].substract(local[ii - 1].multiply(1.0 - alpha_i))).multiply(1 / alpha_i);\n            local[jj] = (this.controlPoints[j].substract(local[jj + 1].multiply(alpha_j))).multiply(1 / (1.0 - alpha_j));\n            ++i;\n            ++ii;\n            --j;\n            --jj;\n        }\n        if (j < i) {\n            if ((local[ii - 1].substract(local[jj + 1])).norm() <= tolerance) {\n                removable = true;\n            }\n        }\n        else {\n            const alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i + this.degree + 1] - this.knots[i]);\n            if (((this.controlPoints[i].substract((local[ii + 1].multiply(alpha_i)))).add(local[ii - 1].multiply(1.0 - alpha_i))).norm() <= tolerance) {\n                removable = true;\n            }\n        }\n        if (removable == false)\n            return;\n        else {\n            let i = first;\n            let j = last;\n            while (j > i) {\n                this.controlPoints[i] = local[i - offset];\n                this.controlPoints[j] = local[j - offset];\n                ++i;\n                --j;\n            }\n        }\n        let knots = this.knots;\n        let controlPoints = this.controlPoints;\n        knots.splice(index, 1);\n        const fout = (2 * index - multiplicity - this.degree) / 2;\n        controlPoints.splice(fout, 1);\n        return new BSplineR1toR3(controlPoints, knots);\n    }\n    distinctKnots() {\n        let result = [this.knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    }\n}\nexports.BSplineR1toR3 = BSplineR1toR3;\nfunction create_BSplineR1toR3(controlPoints, knots) {\n    let newControlPoints = [];\n    for (let cp of controlPoints) {\n        newControlPoints.push(new Vector3d_1.Vector3d(cp[0], cp[1], cp[2]));\n    }\n    return new BSplineR1toR3(newControlPoints, knots);\n}\nexports.create_BSplineR1toR3 = create_BSplineR1toR3;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BSplineR1toR3DifferentialProperties = void 0;\nconst BSplineR1toR1_1 = require(\"../R1toR1/BSplineR1toR1\");\nclass BSplineR1toR3DifferentialProperties {\n    constructor(spline) {\n        this._spline = spline.clone();\n        this.derivatives = this.computeDerivatives(this._spline);\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    computeDerivatives(spline) {\n        const sx = this.bSplineR1toR1Factory(spline.getControlPointsX(), spline.knots);\n        const sy = this.bSplineR1toR1Factory(spline.getControlPointsY(), spline.knots);\n        const sz = this.bSplineR1toR1Factory(spline.getControlPointsZ(), spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const szu = sz.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const szuu = szu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const szuuu = szuu.derivative();\n        return {\n            xu: sxu.bernsteinDecomposition(),\n            yu: syu.bernsteinDecomposition(),\n            zu: szu.bernsteinDecomposition(),\n            xuu: sxuu.bernsteinDecomposition(),\n            yuu: syuu.bernsteinDecomposition(),\n            zuu: szuu.bernsteinDecomposition(),\n            xuuu: sxuuu.bernsteinDecomposition(),\n            yuuu: syuuu.bernsteinDecomposition(),\n            zuuu: szuuu.bernsteinDecomposition()\n        };\n    }\n    torsionNumerator() {\n        const s = this.derivatives;\n        const t1 = s.yu.multiply(s.zuu).subtract(s.yuu.multiply(s.zu));\n        const t2 = s.xuu.multiply(s.zu).subtract(s.xu.multiply(s.zuu));\n        const t3 = s.xu.multiply(s.yuu).subtract(s.xuu.multiply(s.yu));\n        const distinctKnots = this._spline.getDistinctKnots();\n        const result = s.xuuu.multiply(t1).add(s.yuuu.multiply(t2).add(s.zuuu.multiply(t3)));\n        return result.splineRecomposition(distinctKnots);\n    }\n    curvatureSquaredNumerator() {\n        const s = this.derivatives;\n        const t1 = s.zuu.multiply(s.yu).subtract(s.yuu.multiply(s.zu));\n        const t2 = s.xuu.multiply(s.zu).subtract(s.zuu.multiply(s.xu));\n        const t3 = s.yuu.multiply(s.xu).subtract(s.xuu.multiply(s.yu));\n        const result = (t1.multiply(t1).add(t2.multiply(t2)).add(t3.multiply(t3)));\n        const distinctKnots = this._spline.getDistinctKnots();\n        return result.splineRecomposition(distinctKnots);\n    }\n    curvatureSquaredDerivativeNumerator() {\n        const s = this.derivatives;\n        const t1 = s.zuu.multiply(s.yu).subtract(s.yuu.multiply(s.zu));\n        const t2 = s.xuu.multiply(s.zu).subtract(s.zuu.multiply(s.xu));\n        const t3 = s.yuu.multiply(s.xu).subtract(s.xuu.multiply(s.yu));\n        const t4 = s.zuuu.multiply(s.yu).subtract(s.yuuu.multiply(s.zu));\n        const t5 = s.xuuu.multiply(s.zu).subtract(s.zuuu.multiply(s.xu));\n        const t6 = s.yuuu.multiply(s.xu).subtract(s.xuuu.multiply(s.yu));\n        const t7 = s.xu.multiply(s.xu).add(s.yu.multiply(s.yu)).add(s.zu.multiply(s.zu));\n        const t8 = s.xu.multiply(s.xuu).add(s.yu.multiply(s.yuu)).add(s.zu.multiply(s.zuu));\n        const t9 = ((t1.multiply(t4)).add(t2.multiply(t5)).add(t3.multiply(t6))).multiply(t7);\n        const t10 = (t1.multiply(t1).add(t2.multiply(t2)).add(t3.multiply(t3))).multiply(t8);\n        const result = t9.subtract(t10.multiplyByScalar(3));\n        const distinctKnots = this._spline.getDistinctKnots();\n        return result.splineRecomposition(distinctKnots);\n    }\n    curvatureDerivativeZeros() {\n        const curvatureDerivative = this.curvatureSquaredDerivativeNumerator();\n        const zeros = curvatureDerivative.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        return result;\n    }\n    torsionZeros() {\n        const torsionNumerator = this.torsionNumerator();\n        const zeros = torsionNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        return result;\n    }\n}\nexports.BSplineR1toR3DifferentialProperties = BSplineR1toR3DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepCopyControlPoints = exports.BaseBSplineR1toR3 = void 0;\nconst Piegl_Tiller_NURBS_Book_1 = require(\"../Piegl_Tiller_NURBS_Book\");\nconst Vector3d_1 = require(\"../../mathVector/Vector3d\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\n//export abstract class AbstractBSplineR1toR3 implements BSplineR1toRxInterface<Vector3d> {\nclass BaseBSplineR1toR3 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector3d_1.Vector3d(0, 0, 0)], knots = [0, 1]) {\n        this._controlPoints = deepCopyControlPoints(controlPoints);\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    computeDegree() {\n        let degree = this._knots.length - this._controlPoints.length - 1;\n        if (degree < 0) {\n            throw new Error(\"Negative degree BSplineR1toR1 are not supported\");\n        }\n        return degree;\n    }\n    get controlPoints() {\n        return deepCopyControlPoints(this._controlPoints);\n    }\n    /*\n    set controlPoints(controlPoints: Vector3d[]) {\n        this._controlPoints = deepCopyControlPoints(controlPoints)\n    }\n    */\n    get knots() {\n        return [...this._knots];\n    }\n    /*\n    set knots(knots: number[]) {\n        this._knots = [...knots]\n        this._degree = this.computeDegree()\n    }\n    */\n    get degree() {\n        return this._degree;\n    }\n    getControlPoint(index) {\n        return this._controlPoints[index].clone();\n    }\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    evaluate(u) {\n        const span = (0, Piegl_Tiller_NURBS_Book_1.findSpan)(u, this._knots, this._degree);\n        const basis = (0, Piegl_Tiller_NURBS_Book_1.basisFunctions)(span, u, this._knots, this._degree);\n        let result = new Vector3d_1.Vector3d(0, 0, 0);\n        for (let i = 0; i < this._degree + 1; i += 1) {\n            result.x += basis[i] * this._controlPoints[span - this._degree + i].x;\n            result.y += basis[i] * this._controlPoints[span - this._degree + i].y;\n            result.z += basis[i] * this._controlPoints[span - this._degree + i].z;\n        }\n        return result;\n    }\n    getControlPointsX() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.x);\n        }\n        return result;\n    }\n    getControlPointsY() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.y);\n        }\n        return result;\n    }\n    getControlPointsZ() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.z);\n        }\n        return result;\n    }\n    getDistinctKnots() {\n        let result = [this._knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this._knots.length; i += 1) {\n            if (this._knots[i] !== temp) {\n                result.push(this._knots[i]);\n                temp = this._knots[i];\n            }\n        }\n        return result;\n    }\n    moveControlPoint(i, delta) {\n        if (i < 0 || i >= this._controlPoints.length - this._degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        let controlPoints = this.controlPoints;\n        controlPoints[i].x += delta.x;\n        controlPoints[i].y += delta.y;\n        controlPoints[i].z += delta.z;\n        return this.factory(controlPoints, this._knots);\n    }\n    moveControlPoints(delta) {\n        const n = this._controlPoints.length;\n        if (delta.length !== n) {\n            throw new Error(\"Array of unexpected dimension\");\n        }\n        let controlPoints = this.controlPoints;\n        for (let i = 0; i < n; i += 1) {\n            controlPoints[i] = controlPoints[i].add(delta[i]);\n        }\n        return this.factory(controlPoints, this._knots);\n    }\n    setControlPointPosition(index, value) {\n        let controlPoints = this.controlPoints;\n        controlPoints[index] = value;\n        return this.factory(controlPoints, this.knots);\n    }\n    insertKnot(u, times = 1) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        if (times <= 0) {\n            return this.factory(this.controlPoints, this.knots);\n        }\n        let index = (0, Piegl_Tiller_NURBS_Book_1.findSpan)(u, this._knots, this._degree);\n        let multiplicity = 0;\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (let t = 0; t < times; t += 1) {\n            let newControlPoints = [];\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - knots[i]) / (knots[i + this._degree] - knots[i]);\n                newControlPoints[i] = (controlPoints[i - 1].multiply(1 - alpha)).add(controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = controlPoints[i];\n            }\n            knots.splice(index + 1, 0, u);\n            controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n        return this.factory(controlPoints, knots);\n    }\n    knotMultiplicity(indexFromFindSpan) {\n        let result = 0;\n        let i = 0;\n        while (this._knots[indexFromFindSpan + i] === this._knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this._degree + 1; j += 1) {\n                sum += this._knots[j];\n            }\n            result.push(sum / this._degree);\n        }\n        return result;\n    }\n    clamp(u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        let index = (0, Piegl_Tiller_NURBS_Book_1.clampingFindSpan)(u, this._knots, this._degree);\n        let newControlPoints = [];\n        let controlPoints = this.controlPoints;\n        let knots = this.knots;\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        const times = this._degree - multiplicity + 1;\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - knots[i]) / (knots[i + this._degree] - knots[i]);\n                newControlPoints[i] = (controlPoints[i - 1].multiply(1 - alpha)).add(controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = controlPoints[i];\n            }\n            knots.splice(index + 1, 0, u);\n            controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    }\n}\nexports.BaseBSplineR1toR3 = BaseBSplineR1toR3;\nfunction deepCopyControlPoints(controlPoints) {\n    let result = [];\n    for (let cp of controlPoints) {\n        result.push(cp.clone());\n    }\n    return result;\n}\nexports.deepCopyControlPoints = deepCopyControlPoints;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveScene3dController = void 0;\nclass CurveScene3dController {\n    constructor(curveModel3d) {\n        this.curveModel3d = curveModel3d;\n    }\n    setControlPointPosition(selectedControlPoint, x, y, z) {\n        this.curveModel3d.setControlPointPosition(selectedControlPoint, x, y, z);\n    }\n}\nexports.CurveScene3dController = CurveScene3dController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RationalCurveScene2dController = void 0;\nclass RationalCurveScene2dController {\n    constructor(curveModel) {\n        this.curveModel = curveModel;\n    }\n    setControlPointPosition(selectedControlPoint, x, y) {\n        this.curveModel.setControlPointPositionXY(selectedControlPoint, x, y);\n    }\n}\nexports.RationalCurveScene2dController = RationalCurveScene2dController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CholeskyDecomposition = void 0;\n/**\n * A decomposition of a positive-definite matirx into a product of a lower triangular matrix and its conjugate transpose\n */\nclass CholeskyDecomposition {\n    /**\n     * The values of the decomposition are stored in the lower triangular portion of the matrix g\n     * @param matrix Matrix\n     */\n    constructor(matrix) {\n        this.success = false;\n        this.CLOSE_TO_ZERO = 10e-8;\n        this.firstNonPositiveDefiniteLeadingSubmatrixSize = -1;\n        this.g = matrix.squareMatrix();\n        const n = this.g.shape[0];\n        if (this.g.get(0, 0) < this.CLOSE_TO_ZERO) {\n            return;\n        }\n        let sqrtGjj = Math.sqrt(this.g.get(0, 0));\n        for (let i = 0; i < n; i += 1) {\n            this.g.divideAt(i, 0, sqrtGjj);\n        }\n        for (let j = 1; j < n; j += 1) {\n            for (let i = j; i < n; i += 1) {\n                let sum = 0;\n                for (let k = 0; k < j; k += 1) {\n                    sum += this.g.get(i, k) * this.g.get(j, k);\n                }\n                this.g.substractAt(i, j, sum);\n            }\n            if (this.g.get(j, j) < this.CLOSE_TO_ZERO) {\n                this.firstNonPositiveDefiniteLeadingSubmatrixSize = j + 1;\n                return;\n            }\n            sqrtGjj = Math.sqrt(this.g.get(j, j));\n            for (let i = j; i < n; i += 1) {\n                this.g.divideAt(i, j, sqrtGjj);\n            }\n        }\n        for (let j = 0; j < n; j += 1) {\n            for (let i = 0; i < j; i += 1) {\n                this.g.set(i, j, 0);\n            }\n        }\n        this.success = true;\n    }\n    /**\n     * Solve the linear system\n     * @param b Vector\n     * @return The vector x\n     * @throws If the Cholesky decomposition failed\n     */\n    solve(b) {\n        'use strict';\n        // See Numerical Recipes Third Edition p. 101\n        if (!this.success) {\n            throw new Error(\"CholeskyDecomposistion.success === false\");\n        }\n        if (b.length !== this.g.shape[0]) {\n            throw new Error(\"The size of the cholesky decomposed matrix g and the vector b do not match\");\n        }\n        const n = this.g.shape[0];\n        let x = b.slice();\n        // Ly = b\n        for (let i = 0; i < n; i += 1) {\n            let sum = b[i];\n            for (let k = i - 1; k >= 0; k -= 1) {\n                sum -= this.g.get(i, k) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        // LT x = Y\n        for (let i = n - 1; i >= 0; i -= 1) {\n            let sum = x[i];\n            for (let k = i + 1; k < n; k += 1) {\n                sum -= this.g.get(k, i) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        return x;\n    }\n    /**\n     * Solve the linear equation Lower triangular matrix LT * x = b\n     * @param b Vector\n     */\n    solve_LT_result_equal_b(b) {\n        const n = this.g.shape[0];\n        let x = b.slice();\n        for (let i = 0; i < n; i += 1) {\n            let sum = b[i];\n            for (let k = i - 1; k >= 0; k -= 1) {\n                sum -= this.g.get(i, k) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        return x;\n    }\n}\nexports.CholeskyDecomposition = CholeskyDecomposition;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DenseMatrix = void 0;\n/**\n * A dense matrix\n */\nclass DenseMatrix {\n    /**\n     * Create a square matrix\n     * @param nrows Number of rows\n     * @param ncols Number of columns\n     * @param data A row after row flat array\n     * @throws If data length is not equal to nrows*ncols\n     */\n    constructor(nrows, ncols, data) {\n        this._shape = [nrows, ncols];\n        if (data) {\n            if (data.length !== this.shape[0] * this.shape[1]) {\n                throw new Error(\"Dense matrix constructor expect the data to have nrows*ncols length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            for (let i = 0; i < this.shape[0] * this.shape[1]; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n     * Returns the shape of the matrix : [number of rows, number of columns]\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Return the corresponding index in the flat row by row data vector\n     * @param row The row index\n     * @param column The column index\n     */\n    dataIndex(row, column) {\n        return row * this.shape[1] + column;\n    }\n    /**\n     * Return the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    get(row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    }\n    /**\n     * Check that the column index is inside appropriate range\n     * @param index The column index\n     * @throws If index is out of range\n     */\n    checkColumnRange(index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"DenseMatrix column index out of range\");\n        }\n    }\n    /**\n     * Check that the row index is inside appropriate range\n     * @param index The row index\n     * @throws If index is out of range\n     */\n    checkRowRange(index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"DenseMatrix row index out of range\");\n        }\n    }\n    removeRows(rows) {\n        const numberOfRows = this.shape[0] - rows.length;\n        const numberOfColumns = this.shape[1];\n        let result = new DenseMatrix(numberOfRows, numberOfColumns);\n        let k = 0;\n        let newRowIndex = 0;\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            if (rows[k] != i) {\n                for (let j = 0; j < this.shape[1]; j += 1) {\n                    result.set(newRowIndex, j, this.get(i, j));\n                }\n                newRowIndex += 1;\n            }\n            else {\n                k += 1;\n            }\n        }\n        return result;\n    }\n}\nexports.DenseMatrix = DenseMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.identityMatrix = exports.DiagonalMatrix = void 0;\n/**\n * An identity matrix\n */\nclass DiagonalMatrix {\n    /**\n     * Create a Symmetric Matrix\n     * @param size The number of rows or the number columns\n     * @param data The matrix data in a flat vector\n     */\n    constructor(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size) {\n                throw new Error(\"Diagonal matrix constructor expect the data to have size length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            const n = size;\n            for (let i = 0; i < n; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n     * Returns the shape of the matrix : [number of rows, number of columns]\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n * Returns the value at a given row and column position\n * @param row The row index\n * @param column The column index\n * @return Scalar\n * @throws If an index is out of range\n */\n    get(row, column) {\n        this.checkRange(row, column);\n        return this.data[row];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRange(row, column);\n        this.data[row] = value;\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkRange(row, column) {\n        if (row < 0 || row >= this.shape[0] || row != column) {\n            throw new Error(\"DiagonalMatrix index is out of range\");\n        }\n    }\n}\nexports.DiagonalMatrix = DiagonalMatrix;\nfunction identityMatrix(n) {\n    let result = new DiagonalMatrix(n);\n    for (let i = 0; i < n; i += 1) {\n        result.set(i, i, 1);\n    }\n    return result;\n}\nexports.identityMatrix = identityMatrix;\n","\"use strict\";\n// https://rosettacode.org/wiki/Gaussian_elimination#JavaScript\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lusolve = void 0;\n// Lower Upper Solver\nfunction lusolve(matrix, b, update = false) {\n    let A = matrix.toNumberArray();\n    let lu = ludcmp(A, update);\n    if (lu === undefined)\n        return; // Singular Matrix!\n    return lubksb(lu, b, update);\n}\nexports.lusolve = lusolve;\n// Lower Upper Decomposition\nfunction ludcmp(A, update) {\n    // A is a matrix that we want to decompose into Lower and Upper matrices.\n    let d = true;\n    let n = A.length;\n    let idx = new Array(n); // Output vector with row permutations from partial pivoting\n    let vv = new Array(n); // Scaling information\n    for (let i = 0; i < n; i++) {\n        let max = 0;\n        for (let j = 0; j < n; j++) {\n            let temp = Math.abs(A[i][j]);\n            if (temp > max)\n                max = temp;\n        }\n        if (max == 0)\n            return; // Singular Matrix!\n        vv[i] = 1 / max; // Scaling\n    }\n    if (!update) { // make a copy of A \n        let Acpy = new Array(n);\n        for (let i = 0; i < n; i++) {\n            let Ai = A[i];\n            let Acpyi = new Array(Ai.length);\n            for (let j = 0; j < Ai.length; j += 1)\n                Acpyi[j] = Ai[j];\n            Acpy[i] = Acpyi;\n        }\n        A = Acpy;\n    }\n    let tiny = 1e-20; // in case pivot element is zero\n    for (let i = 0;; i++) {\n        for (let j = 0; j < i; j++) {\n            let sum = A[j][i];\n            for (let k = 0; k < j; k++)\n                sum -= A[j][k] * A[k][i];\n            A[j][i] = sum;\n        }\n        let jmax = 0;\n        let max = 0;\n        for (let j = i; j < n; j++) {\n            let sum = A[j][i];\n            for (let k = 0; k < i; k++)\n                sum -= A[j][k] * A[k][i];\n            A[j][i] = sum;\n            let temp = vv[j] * Math.abs(sum);\n            if (temp >= max) {\n                max = temp;\n                jmax = j;\n            }\n        }\n        if (i <= jmax) {\n            for (let j = 0; j < n; j++) {\n                let temp = A[jmax][j];\n                A[jmax][j] = A[i][j];\n                A[i][j] = temp;\n            }\n            d = !d;\n            vv[jmax] = vv[i];\n        }\n        idx[i] = jmax;\n        if (i == n - 1)\n            break;\n        let temp = A[i][i];\n        if (temp == 0)\n            A[i][i] = temp = tiny;\n        temp = 1 / temp;\n        for (let j = i + 1; j < n; j++)\n            A[j][i] *= temp;\n    }\n    return { A: A, idx: idx, d: d };\n}\n// Lower Upper Back Substitution\nfunction lubksb(lu, b, update) {\n    // solves the set of n linear equations A*x = b.\n    // lu is the object containing A, idx and d as determined by the routine ludcmp.\n    let A = lu.A;\n    let idx = lu.idx;\n    let n = idx.length;\n    if (!update) { // make a copy of b\n        let bcpy = new Array(n);\n        for (let i = 0; i < b.length; i += 1)\n            bcpy[i] = b[i];\n        b = bcpy;\n    }\n    for (let ii = -1, i = 0; i < n; i++) {\n        let ix = idx[i];\n        let sum = b[ix];\n        b[ix] = b[i];\n        if (ii > -1)\n            for (let j = ii; j < i; j++)\n                sum -= A[i][j] * b[j];\n        else if (sum)\n            ii = i;\n        b[i] = sum;\n    }\n    for (let i = n - 1; i >= 0; i--) {\n        let sum = b[i];\n        for (let j = i + 1; j < n; j++)\n            sum -= A[i][j] * b[j];\n        b[i] = sum / A[i][i];\n    }\n    return b; // solution vector x\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeElements = exports.sign = exports.containsNaN = exports.randomVector = exports.isZeroVector = exports.product_v1_v2t = exports.product_v_vt = exports.zeroVector = exports.norm1 = exports.norm = exports.squaredNorm = exports.addSecondVectorToFirst = exports.addTwoVectors = exports.dotProduct = exports.saxpy2 = exports.saxpy = exports.divideVectorByScalar = exports.multiplyVectorByScalar = void 0;\nconst SquareMatrix_1 = require(\"./SquareMatrix\");\nconst DenseMatrix_1 = require(\"./DenseMatrix\");\n/**\n * Multiply a vector by a scalar\n * @param vector vector\n * @param value scalar\n */\nfunction multiplyVectorByScalar(vector, value) {\n    let result = [];\n    for (let vi of vector) {\n        result.push(vi * value);\n    }\n    return result;\n}\nexports.multiplyVectorByScalar = multiplyVectorByScalar;\n/**\n * Divide a vector by a scalar\n * @param vector Vector\n * @param value Scalar\n * @throws If the scalar value is zero\n */\nfunction divideVectorByScalar(vector, value) {\n    if (value === 0) {\n        throw new Error(\"Division by zero\");\n    }\n    let result = [];\n    for (let vi of vector) {\n        result.push(vi / value);\n    }\n    return result;\n}\nexports.divideVectorByScalar = divideVectorByScalar;\n/**\n * A standard function in basic linear algebra : y = ax + y\n * @param a Scalar\n * @param x Vector\n * @param y Vector\n * @throws If x and y have different length\n */\nfunction saxpy(a, x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    for (let i = 0; i < x.length; i += 1) {\n        y[i] += a * x[i];\n    }\n}\nexports.saxpy = saxpy;\n/**\n * A standard function in basic linear algebra : z = ax + y\n * @param a Scalar\n * @param x Vector\n * @param y Vector\n * @returns ax + y\n * @throws If x and y have different length\n */\nfunction saxpy2(a, x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    let result = [];\n    for (let i = 0; i < x.length; i += 1) {\n        result.push(a * x[i] + y[i]);\n    }\n    return result;\n}\nexports.saxpy2 = saxpy2;\n/**\n * Compute the dot product of two vectors\n * @param x Vector\n * @param y Vector\n * @return The scalar result\n * @throws If x and y have different length\n */\nfunction dotProduct(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Making the dot product of two vectors of different length\");\n    }\n    let result = 0;\n    for (let i = 0; i < x.length; i += 1) {\n        result += x[i] * y[i];\n    }\n    return result;\n}\nexports.dotProduct = dotProduct;\n/**\n * Add two vectors\n * @param x Vector\n * @param y Vector\n * @return Vector\n * @throws If x and y have different length\n */\nfunction addTwoVectors(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    let result = [];\n    for (let i = 0; i < x.length; i += 1) {\n        result.push(x[i] + y[i]);\n    }\n    return result;\n}\nexports.addTwoVectors = addTwoVectors;\n/**\n * Add the second vector to the first vector\n * @param x Vector\n * @param y Vector\n * @throws If x and y have different length\n */\nfunction addSecondVectorToFirst(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    for (let i = 0; i < x.length; i += 1) {\n        x[i] += y[i];\n    }\n}\nexports.addSecondVectorToFirst = addSecondVectorToFirst;\n/**\n * Compute the square of the norm\n * @param v Vector\n * @return Non negative scalar\n */\nfunction squaredNorm(vector) {\n    let result = 0;\n    for (let vi of vector) {\n        result += vi * vi;\n    }\n    return result;\n}\nexports.squaredNorm = squaredNorm;\n/**\n * Compute the norm\n * @param v Vector\n * @return Non negative scalar\n */\nfunction norm(v) {\n    return Math.sqrt(squaredNorm(v));\n}\nexports.norm = norm;\n/**\n * Compute the norm p = 1\n * @param v Vector\n * @return Non negative scalar\n */\nfunction norm1(vector) {\n    let result = 0;\n    for (let vi of vector) {\n        result += Math.abs(vi);\n    }\n    return result;\n}\nexports.norm1 = norm1;\n/**\n * Create a zero vector of size n\n * @param n Size\n */\nfunction zeroVector(n) {\n    let result = [];\n    for (let i = 0; i < n; i += 1) {\n        result.push(0);\n    }\n    return result;\n}\nexports.zeroVector = zeroVector;\n/**\n * Compute the product of a vector and its transpose\n * @param v Vector\n */\nfunction product_v_vt(v) {\n    const n = v.length;\n    let result = new SquareMatrix_1.SquareMatrix(n);\n    for (let i = 0; i < n; i += 1) {\n        for (let j = 0; j < n; j += 1) {\n            result.set(i, j, v[i] * v[j]);\n        }\n    }\n    return result;\n}\nexports.product_v_vt = product_v_vt;\n/**\n * Compute the product of a first vector with the transpose of a second vector\n * @param v1 The first vector taken as a column vector\n * @param v2 The second vector taken after transposition as a row vector\n */\nfunction product_v1_v2t(v1, v2) {\n    const m = v1.length;\n    const n = v2.length;\n    let result = new DenseMatrix_1.DenseMatrix(m, n);\n    for (let i = 0; i < m; i += 1) {\n        for (let j = 0; j < n; j += 1) {\n            result.set(i, j, v1[i] * v2[j]);\n        }\n    }\n    return result;\n}\nexports.product_v1_v2t = product_v1_v2t;\nfunction isZeroVector(vector) {\n    for (let vi of vector) {\n        if (vi !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isZeroVector = isZeroVector;\n/**\n * Returns a vector filled with random values between 0 and 1\n * @param n The size of the random vector\n */\nfunction randomVector(n) {\n    let result = [];\n    for (let i = 0; i < n; i += 1) {\n        result.push((Math.random() - 0.5) * 10e8);\n        //result.push((Math.random())*10e8)\n    }\n    return result;\n}\nexports.randomVector = randomVector;\nfunction containsNaN(vector) {\n    for (let vi of vector) {\n        if (isNaN(vi)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.containsNaN = containsNaN;\n/**\n * Return the sign of a number.\n * It returns 1 if the number is positive, -1 if the number is negative and 0 if it is zero or minus zero\n * The standard Math.sign() function doesn't work with Windows Internet Explorer\n * @param x Number\n */\nfunction sign(x) {\n    if (x == 0)\n        return 0;\n    else\n        return x < 0 ? -1 : 1;\n}\nexports.sign = sign;\nfunction removeElements(array, indices) {\n    let result = array.slice();\n    for (let i = indices.length - 1; i >= 0; i--) {\n        result.splice(indices[i], 1);\n    }\n    return result;\n}\nexports.removeElements = removeElements;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SquareMatrix = void 0;\n/**\n * A square matrix\n */\nclass SquareMatrix {\n    /**\n     * Create a square matrix\n     * @param size Number of row and column\n     * @param data A row after row flat array\n     * @throws If data length is not equal to size*size\n     */\n    constructor(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size * size) {\n                throw new Error(\"Square matrix constructor expect the data to have size*size length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            for (let i = 0; i < this.shape[0] * this.shape[1]; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n     * Returns the shape of the matrix : [number of rows, number of columns]\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Return the corresponding index in the flat row by row data vector\n     * @param row The row index\n     * @param column The column index\n     */\n    dataIndex(row, column) {\n        let n = row * this._shape[1] + column;\n        return n;\n    }\n    /**\n     * Return the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    get(row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    }\n    /**\n     * Change the value of the matrix at a given row and column position by this value divided by the divisor value\n     * @param row The row index\n     * @param column The column index\n     * @param divisor The divisor value\n     * @throws If an index is out of range\n     */\n    divideAt(row, column, divisor) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] /= divisor;\n    }\n    /**\n     * Change the value of the matrix at a given row and column position by this value substracted by the subtrahend value\n     * @param row The row index\n     * @param column The column index\n     * @param divisor The divisor value\n     * @throws If an index is out of range\n     */\n    substractAt(row, column, subtrahend) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] -= subtrahend;\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkRowRange(index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkColumnRange(index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n     * Multiply two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    multiplyByMatrix(that) {\n        if (this.shape[1] !== that.shape[0]) {\n            throw new Error(\"Size mismatch in matrix multiplication\");\n        }\n        let result = new SquareMatrix(this.shape[1]);\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            for (let j = 0; j < this.shape[0]; j += 1) {\n                let temp = 0;\n                for (let k = 0; k < this.shape[0]; k += 1) {\n                    temp += this.get(i, k) * that.get(k, j);\n                }\n                result.set(i, j, temp);\n            }\n        }\n        return result;\n    }\n    multiplyByVector(v) {\n        if (this.shape[1] !== v.length) {\n            throw new Error(\"SquareMatrix multiply a vector of incorrect length\");\n        }\n        let result = [];\n        const n = this.shape[1];\n        for (let i = 0; i < n; i += 1) {\n            let temp = 0;\n            for (let j = 0; j < n; j += 1) {\n                temp += this.get(i, j) * v[j];\n            }\n            result.push(temp);\n        }\n        return result;\n    }\n    /**\n     * Add two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    addByMatrix(that) {\n        if (this.shape[1] !== that.shape[0]) {\n            throw new Error(\"Size mismatch in matrix addition\");\n        }\n        let result = new SquareMatrix(this.shape[1]);\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            for (let j = 0; j < this.shape[0]; j += 1) {\n                result.set(i, j, this.get(i, j) + that.get(i, j));\n            }\n        }\n        return result;\n    }\n    /**\n     * Add two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    mutiplyByConstant(value) {\n        let result = new SquareMatrix(this.shape[1]);\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            for (let j = 0; j < this.shape[0]; j += 1) {\n                result.set(i, j, this.get(i, j) * value);\n            }\n        }\n        return result;\n    }\n    toNumberArray() {\n        let result = [];\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            result.push([]);\n            for (let j = 0; j < this.shape[1]; j += 1) {\n                result[i].push(this.get(i, j));\n            }\n        }\n        return result;\n    }\n}\nexports.SquareMatrix = SquareMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SymmetricMatrix = void 0;\nconst SquareMatrix_1 = require(\"./SquareMatrix\");\nconst DiagonalMatrix_1 = require(\"./DiagonalMatrix\");\nconst MathVectorBasicOperations_1 = require(\"./MathVectorBasicOperations\");\n/**\n * A symmetric matrix\n */\nclass SymmetricMatrix {\n    /**\n     * Create a Symmetric Matrix\n     * @param size The number of rows or the number columns\n     * @param data The matrix data in a flat vector\n     */\n    constructor(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size * (size + 1) / 2) {\n                throw new Error(\"Square matrix constructor expect the data to have (size * (size + 1) / 2) length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            const n = (size * (size + 1)) / 2;\n            for (let i = 0; i < n; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n    * Returns the shape of the matrix : [number of rows, number of columns]\n    */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Returns the corresponding index in the flat data vector.\n     * In this flat data vector the upper triangular matrix is store row-wise.\n     * @param row The row index\n     * @param column The column index\n     */\n    dataIndex(row, column) {\n        if (row <= column) {\n            return row * this.shape[1] - (row - 1) * row / 2 + column - row;\n        }\n        return column * this.shape[0] - (column - 1) * column / 2 + row - column;\n    }\n    /**\n     * Returns the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    get(row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkRowRange(index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n * Check that the index is inside appropriate range\n * @param index The column or the row index\n * @throws If an index is out of range\n */\n    checkColumnRange(index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n     * Compute the product v^t M v\n     * @param v Vector\n     * @return Scalar\n     */\n    quadraticForm(v) {\n        let result = 0;\n        for (let i = 1; i < this.shape[1]; i += 1) {\n            for (let j = 0; j < i; j += 1) {\n                result += this.get(i, j) * v[i] * v[j];\n            }\n        }\n        result *= 2;\n        for (let i = 0; i < this.shape[1]; i += 1) {\n            result += this.get(i, i) * Math.pow(v[i], 2);\n        }\n        return result;\n    }\n    /**\n     * Return a safe copy of this matrix\n     * */\n    clone() {\n        return new SymmetricMatrix(this.shape[0], this.data);\n    }\n    /**\n     * Increases the given element of the matrix by the value\n     * @param row The row index\n     * @param column The column index\n     * @param value The number to be added\n     * @throws If an index is out of range\n     */\n    addAt(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(row);\n        this.data[this.dataIndex(row, column)] += value;\n    }\n    /**\n     * Increases every diagonal element of the matrix by the value\n     * @param value The number to be added\n     */\n    addValueOnDiagonalInPlace(value) {\n        const m = this.shape[0];\n        for (let i = 0; i < m; i += 1) {\n            this.data[this.dataIndex(i, i)] += value;\n        }\n    }\n    /**\n     * Returns the new matrix: this.matrix + value * I\n     * @param value\n     * @returns SymmetricMatrix\n     */\n    addValueOnDiagonal(value) {\n        let result = this.clone();\n        result.addValueOnDiagonalInPlace(value);\n        return result;\n    }\n    /**\n     * Returns a SquareMatrix with the values of this matrix\n     */\n    squareMatrix() {\n        const n = this.shape[0];\n        let result = new SquareMatrix_1.SquareMatrix(n);\n        for (let i = 0; i < n; i += 1) {\n            for (let j = 0; j < n; j += 1) {\n                result.set(i, j, this.get(i, j));\n            }\n        }\n        return result;\n    }\n    plusSymmetricMatrixMultipliedByValue(matrix, value) {\n        if (this.shape[0] !== matrix.shape[0]) {\n            throw new Error(\"Adding two symmetric matrix with different shapes\");\n        }\n        let result = this.clone();\n        const n = result.shape[0];\n        if (matrix instanceof DiagonalMatrix_1.DiagonalMatrix) {\n            for (let i = 0; i < n; i += 1) {\n                result.addAt(i, i, matrix.get(i, i) * value);\n            }\n            return result;\n        }\n        else {\n            for (let i = 0; i < n; i += 1) {\n                for (let j = 0; j <= i; j += 1) {\n                    result.addAt(i, j, matrix.get(i, j) * value);\n                }\n            }\n            return result;\n        }\n    }\n    multiplyByVector(v) {\n        if (this.shape[1] !== v.length) {\n            throw new Error(\"SymmetricMatrix multiply a vector of incorrect length\");\n        }\n        let result = [];\n        const n = this.shape[1];\n        for (let i = 0; i < n; i += 1) {\n            let temp = 0;\n            for (let j = 0; j < n; j += 1) {\n                temp += this.get(i, j) * v[j];\n            }\n            result.push(temp);\n        }\n        return result;\n    }\n    containsNaN() {\n        return (0, MathVectorBasicOperations_1.containsNaN)(this.data);\n    }\n    getData() {\n        return this.data;\n    }\n}\nexports.SymmetricMatrix = SymmetricMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rotationMatrixFromTwoVectors = void 0;\nconst SquareMatrix_1 = require(\"../linearAlgebra/SquareMatrix\");\nfunction rotationMatrixFromTwoVectors(unitVector1, unitVector2, tolerance = 10e-5) {\n    // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d\n    let p = unitVector1.crossPoduct(unitVector2);\n    let i = new SquareMatrix_1.SquareMatrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1]);\n    let v = new SquareMatrix_1.SquareMatrix(3, [0, -p.z, p.y, p.z, 0, -p.x, -p.y, p.x, 0]);\n    let c = unitVector1.dot(unitVector2);\n    if (1 + c < tolerance) {\n        throw new Error(\"The two given vectors points in opposite directions, the rotation matrix is indeterminate\");\n    }\n    return i.addByMatrix(v).addByMatrix(v.multiplyByMatrix(v).mutiplyByConstant(1 / (1 + c)));\n}\nexports.rotationMatrixFromTwoVectors = rotationMatrixFromTwoVectors;\n","\"use strict\";\n//import { VectorInterface } from \"./VectorInterface\"\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scaleY = exports.scaleX = exports.scale = exports.Vector2d = void 0;\n/**\n * A two dimensional vector\n */\nclass Vector2d {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    negative() {\n        return new Vector2d(-this.x, -this.y);\n    }\n    add(v) {\n        return new Vector2d(this.x + v.x, this.y + v.y);\n    }\n    multiply(value) {\n        return new Vector2d(this.x * value, this.y * value);\n    }\n    subtract(v) {\n        return new Vector2d(this.x - v.x, this.y - v.y);\n    }\n    rotate90degrees() {\n        return new Vector2d(-this.y, this.x);\n    }\n    normalize() {\n        let norm = Math.sqrt(this.x * this.x + this.y * this.y);\n        let x = this.x / norm;\n        let y = this.y / norm;\n        return new Vector2d(x, y);\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n    distance(v) {\n        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\n    }\n    norm() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n    }\n    clone() {\n        return new Vector2d(this.x, this.y);\n    }\n}\nexports.Vector2d = Vector2d;\nfunction scale(factor, v) {\n    let result = [];\n    v.forEach(element => {\n        result.push(element.multiply(factor));\n    });\n    return result;\n}\nexports.scale = scale;\nfunction scaleX(factor, v) {\n    let result = [];\n    v.forEach(element => {\n        v.push(new Vector2d(element.x * factor, element.y));\n    });\n    return result;\n}\nexports.scaleX = scaleX;\nfunction scaleY(factor, v) {\n    let result = [];\n    v.forEach(element => {\n        v.push(new Vector2d(element.x, element.y * factor));\n    });\n    return result;\n}\nexports.scaleY = scaleY;\n","\"use strict\";\n//import { VectorInterface } from \"./VectorInterface\"\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.linePlaneIntersection = exports.pointLineDistance = exports.Vector3d = void 0;\n/**\n * A three dimensional vector\n */\nclass Vector3d {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    negative() {\n        return new Vector3d(-this.x, -this.y, -this.z);\n    }\n    add(v) {\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    multiply(value) {\n        return new Vector3d(this.x * value, this.y * value, this.z * value);\n    }\n    substract(v) {\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    normalize() {\n        let norm = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        let x = this.x / norm;\n        let y = this.y / norm;\n        let z = this.z / norm;\n        return new Vector3d(x, y, z);\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    distance(v) {\n        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2) + Math.pow(this.z - v.z, 2));\n    }\n    norm() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n    }\n    clone() {\n        return new Vector3d(this.x, this.y, this.z);\n    }\n    crossPoduct(v) {\n        return new Vector3d(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);\n    }\n    axisAngleRotation(axis, angle) {\n        //https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n        const k = axis.normalize();\n        const firstTerm = this.multiply(Math.cos(angle));\n        const secondTerm = k.crossPoduct(this).multiply(Math.sin(angle));\n        const thirdTerm = k.multiply(k.dot(this)).multiply(1 - Math.cos(angle));\n        return firstTerm.add(secondTerm).add(thirdTerm);\n    }\n}\nexports.Vector3d = Vector3d;\n/**\n* @param p0 point\n* @param p1 first point of the line\n* @param p2 second point of the line\n*/\nfunction pointLineDistance(p0, p1, p2) {\n    // https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n    return ((p0.substract(p1)).crossPoduct(p0.substract(p2))).norm() / p2.substract(p1).norm();\n}\nexports.pointLineDistance = pointLineDistance;\nfunction linePlaneIntersection(lineP1, lineP2, lookAtOrigin, cameraPosition, objectCenter) {\n    //https://en.wikipedia.org/wiki/Line–plane_intersection\n    const l = lineP2.substract(lineP1);\n    const n = lookAtOrigin.substract(cameraPosition);\n    const nn = n.normalize();\n    const a = nn.dot(objectCenter.substract(cameraPosition));\n    const p0 = nn.multiply(a).add(cameraPosition);\n    const d = (p0.substract(lineP1)).dot(n) / (l.dot(n));\n    return lineP1.add(l.multiply(d));\n}\nexports.linePlaneIntersection = linePlaneIntersection;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseCurve2dModel = void 0;\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst BaseOpBSplineR1toR2_1 = require(\"../optimizationProblems/BaseOpBSplineR1toR2\");\nconst RationalBSplineR1toR2Adapter_1 = require(\"../bsplines/R1toR2/RationalBSplineR1toR2Adapter\");\nclass BaseCurve2dModel {\n    constructor() {\n        this.observers = [];\n        this.observersCP = [];\n        this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.both;\n        this.activeOptimizer = true;\n        this.optimizationProblem = null;\n        this.optimizer = null;\n    }\n    registerObserver(observer) {\n        this.observers.push(observer);\n    }\n    removeObserver(observer) {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.clone());\n        }\n        for (let observer of this.observersCP) {\n            observer.update(this._spline.clone());\n        }\n    }\n    setControlPointPosition(controlPointIndex, x, y) {\n        this._spline = this._spline.setControlPointPosition(controlPointIndex, new Vector2d_1.Vector2d(x, y));\n        this.notifyObservers();\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y);\n        }\n    }\n    setControlPointWeight(controlPointIndex, w) {\n        if (this._spline instanceof RationalBSplineR1toR2Adapter_1.RationalBSplineR1toR2Adapter) {\n            this._spline.setControlPointWeight(controlPointIndex, w);\n            this.notifyObservers();\n            /*\n            if (this.activeOptimizer) {\n                this.optimize(controlPointIndex, x, y)\n            }\n            */\n        }\n    }\n    increaseControlPointWeight(controlPointIndex) {\n        if (this._spline instanceof RationalBSplineR1toR2Adapter_1.RationalBSplineR1toR2Adapter) {\n            const delta = 1.1;\n            const w = this._spline.getControlPointWeight(controlPointIndex);\n            this._spline.setControlPointWeight(controlPointIndex, w * delta);\n            this.notifyObservers();\n            /*\n            if (this.activeOptimizer) {\n                this.optimize(controlPointIndex, x, y)\n            }\n            */\n        }\n    }\n    decreaseControlPointWeight(controlPointIndex) {\n        if (this._spline instanceof RationalBSplineR1toR2Adapter_1.RationalBSplineR1toR2Adapter) {\n            const delta = 0.9;\n            const w = this._spline.getControlPointWeight(controlPointIndex);\n            this._spline.setControlPointWeight(controlPointIndex, w * delta);\n            this.notifyObservers();\n            /*\n            if (this.activeOptimizer) {\n                this.optimize(controlPointIndex, x, y)\n            }\n            */\n        }\n    }\n    optimize(selectedControlPoint, ndcX, ndcY) {\n        if (this.optimizationProblem && this.optimizer) {\n            //const p = this._spline.freeControlPoints[selectedControlPoint].clone()\n            const p = this.optimizationProblem.spline.freeControlPoints[selectedControlPoint].clone();\n            const distance = Math.sqrt(Math.pow(ndcX - p.x, 2) + Math.pow(ndcY - p.y, 2));\n            //console.log(ndcX - p.x)\n            const numberOfStep = 3 * Math.ceil(distance * 10);\n            //const numberOfStep = 1\n            for (let i = 1; i <= numberOfStep; i += 1) {\n                let alpha = Math.pow(i / numberOfStep, 3);\n                this._spline.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d((1 - alpha) * p.x + alpha * ndcX, (1 - alpha) * p.y + alpha * ndcY));\n                this.optimizationProblem.setTargetSpline(this._spline);\n                try {\n                    this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                    if (this.optimizer.success === true) {\n                        this.setSpline(this.optimizationProblem.spline.clone());\n                    }\n                }\n                catch (e) {\n                    this._spline.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d(p.x, p.y));\n                    console.log(e);\n                }\n            }\n        }\n    }\n    toggleActiveControlOfCurvatureExtrema() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    toggleActiveControlOfInflections() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n}\nexports.BaseCurve2dModel = BaseCurve2dModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseRationalCurve2dModel = void 0;\nconst BaseOpBSplineR1toR2_1 = require(\"../optimizationProblems/BaseOpBSplineR1toR2\");\nconst RationalBSplineR1toR2_1 = require(\"../bsplines/R1toR2/RationalBSplineR1toR2\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nclass BaseRationalCurve2dModel {\n    constructor() {\n        this.observers = [];\n        this.observersCP = [];\n        this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.both;\n        this.activeOptimizer = true;\n        this.optimizationProblem = null;\n        this.optimizer = null;\n    }\n    registerObserver(observer) {\n        this.observers.push(observer);\n    }\n    removeObserver(observer) {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.getSplineAdapter());\n        }\n        for (let observer of this.observersCP) {\n            observer.update(this._spline.getSplineAdapter());\n        }\n    }\n    setControlPointPosition(controlPointIndex, x, y, z) {\n        this._spline = this._spline.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(x, y, z));\n        this.notifyObservers();\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y);\n        }\n    }\n    setControlPointPositionXY(controlPointIndex, x, y) {\n        const cp = this._spline.controlPoints[controlPointIndex];\n        this._spline = this._spline.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(x * cp.z, y * cp.z, cp.z));\n        this.notifyObservers();\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y);\n        }\n    }\n    setControlPointWeight(controlPointIndex, w) {\n        const p = this._spline.controlPoints[controlPointIndex];\n        const s = this._spline.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(p.x * w, p.y * w, w));\n        this._spline = new RationalBSplineR1toR2_1.RationalBSplineR1toR2(s.controlPoints, s.knots);\n        this.notifyObservers();\n        if (this.activeOptimizer) {\n            this.optimizeWeight(controlPointIndex, w);\n        }\n    }\n    increaseControlPointWeight(controlPointIndex) {\n        if (this._spline instanceof RationalBSplineR1toR2_1.RationalBSplineR1toR2) {\n            const delta = 1.1;\n            const w = this._spline.getControlPointWeight(controlPointIndex);\n            const newW = w * delta;\n            this._spline = this._spline.setControlPointWeight(controlPointIndex, newW);\n            this.notifyObservers();\n            if (this.activeOptimizer) {\n                this.optimizeWeight(controlPointIndex, newW);\n            }\n        }\n    }\n    decreaseControlPointWeight(controlPointIndex) {\n        if (this._spline instanceof RationalBSplineR1toR2_1.RationalBSplineR1toR2) {\n            const delta = 0.9;\n            const w = this._spline.getControlPointWeight(controlPointIndex);\n            const newW = w * delta;\n            this._spline = this._spline.setControlPointWeight(controlPointIndex, newW);\n            this.notifyObservers();\n            if (this.activeOptimizer) {\n                this.optimizeWeight(controlPointIndex, newW);\n            }\n        }\n    }\n    optimize(selectedControlPoint, ndcX, ndcY) {\n        if (this.optimizationProblem && this.optimizer) {\n            //const p = this._spline.freeControlPoints[selectedControlPoint].clone()\n            const p = this.optimizationProblem.spline.freeControlPoints[selectedControlPoint].clone();\n            const distance = Math.sqrt(Math.pow(ndcX - p.x, 2) + Math.pow(ndcY - p.y, 2));\n            //console.log(ndcX - p.x)\n            //const numberOfStep = 3 * Math.ceil(distance * 10)\n            const numberOfStep = 1;\n            //const numberOfStep = 1\n            for (let i = 1; i <= numberOfStep; i += 1) {\n                let alpha = Math.pow(i / numberOfStep, 3);\n                //this._spline.setControlPointPosition(selectedControlPoint, new Vector3d((1-alpha)*p.x + alpha * ndcX, (1-alpha)*p.y + alpha * ndcY, (1-alpha)*p.z + alpha * ndcY ))\n                this._spline.setControlPointPosition(selectedControlPoint, new Vector3d_1.Vector3d(ndcX * p.z, ndcY * p.z, p.z));\n                this.optimizationProblem.setTargetSpline(this._spline);\n                try {\n                    this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                    if (this.optimizer.success === true) {\n                        this.setSpline(this.optimizationProblem.spline.clone());\n                    }\n                }\n                catch (e) {\n                    this._spline.setControlPointPosition(selectedControlPoint, new Vector3d_1.Vector3d(p.x, p.y, p.z));\n                    console.log(e);\n                }\n            }\n        }\n    }\n    optimizeWeight(selectedControlPoint, w) {\n        if (this.optimizationProblem && this.optimizer) {\n            //const p = this._spline.freeControlPoints[selectedControlPoint].clone()\n            const p = this.optimizationProblem.spline.freeControlPoints[selectedControlPoint].clone();\n            //const distance = Math.sqrt(Math.pow(ndcX - p.x, 2) + Math.pow(ndcY - p.y, 2))\n            //console.log(ndcX - p.x)\n            //const numberOfStep = 3 * Math.ceil(distance * 10)\n            const numberOfStep = 1;\n            //const numberOfStep = 1\n            for (let i = 1; i <= numberOfStep; i += 1) {\n                //let alpha = Math.pow(i / numberOfStep, 3)\n                //this._spline.setControlPointPosition(selectedControlPoint, new Vector3d((1-alpha)*p.x + alpha * ndcX, (1-alpha)*p.y + alpha * ndcY, (1-alpha)*p.z + alpha * ndcY ))\n                this._spline.setControlPointPosition(selectedControlPoint, new Vector3d_1.Vector3d(p.x * w / p.z, p.y * w / p.z, w));\n                this.optimizationProblem.setTargetSpline(this._spline);\n                try {\n                    this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                    if (this.optimizer.success === true) {\n                        this.setSpline(this.optimizationProblem.spline.clone());\n                    }\n                }\n                catch (e) {\n                    this._spline.setControlPointPosition(selectedControlPoint, new Vector3d_1.Vector3d(p.x, p.y, p.z));\n                    console.log(e);\n                }\n            }\n        }\n    }\n    toggleActiveControlOfCurvatureExtrema() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    toggleActiveControlOfInflections() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeControl = BaseOpBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == BaseOpBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n}\nexports.BaseRationalCurve2dModel = BaseRationalCurve2dModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Curve2dModel = void 0;\nconst BSplineR1toR2_1 = require(\"../bsplines/R1toR2/BSplineR1toR2\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst OpBSplineR1toR2_1 = require(\"../optimizationProblems/OpBSplineR1toR2\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nconst BaseCurve2dModel_1 = require(\"./BaseCurve2dModel\");\nclass Curve2dModel extends BaseCurve2dModel_1.BaseCurve2dModel {\n    constructor() {\n        super();\n        /*\n        const cp0 = new Vector2d(-0.5, 0)\n        const cp1 = new Vector2d(-0.1, 0.5)\n        const cp2 = new Vector2d(0.1, 0.5)\n        const cp3 = new Vector2d(0.5, 0)\n\n        this._spline = new BSplineR1toR2([ cp0, cp1, cp2, cp3 ], [ 0, 0, 0, 0, 1, 1, 1, 1 ])\n        */\n        const cp0 = new Vector2d_1.Vector2d(-0.5, 0);\n        const cp1 = new Vector2d_1.Vector2d(-0.3, 0.5);\n        const cp2 = new Vector2d_1.Vector2d(0, 0.7);\n        const cp3 = new Vector2d_1.Vector2d(0.3, 0.5);\n        const cp4 = new Vector2d_1.Vector2d(0.5, 0);\n        this._spline = new BSplineR1toR2_1.BSplineR1toR2([cp0, cp1, cp2, cp3, cp4], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);\n        this.optimizationProblem = new OpBSplineR1toR2_1.OpBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        //this.optimizer = new QuasiNewtonOptimizer(this.optimizationProblem)\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    get isClosed() {\n        return false;\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n    addControlPoint(controlPointIndex) {\n        let cp = controlPointIndex;\n        if (cp != null) {\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this._spline.controlPoints.length - 1) {\n                cp -= 1;\n            }\n            const grevilleAbscissae = this._spline.grevilleAbscissae();\n            this._spline = this._spline.insertKnot(grevilleAbscissae[cp]);\n        }\n        this.optimizationProblem = new OpBSplineR1toR2_1.OpBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OpBSplineR1toR2_1.OpBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n}\nexports.Curve2dModel = Curve2dModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveModel3d = exports.ActiveControl = void 0;\nconst BSplineR1toR3_1 = require(\"../bsplines/R1toR3/BSplineR1toR3\");\nconst OpBSplineR1toR3_1 = require(\"../optimizationProblems/OpBSplineR1toR3\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nvar ActiveControl;\n(function (ActiveControl) {\n    ActiveControl[ActiveControl[\"curvatureExtrema\"] = 0] = \"curvatureExtrema\";\n    ActiveControl[ActiveControl[\"torsionZeros\"] = 1] = \"torsionZeros\";\n    ActiveControl[ActiveControl[\"both\"] = 2] = \"both\";\n})(ActiveControl = exports.ActiveControl || (exports.ActiveControl = {}));\nclass CurveModel3d {\n    constructor() {\n        this.activeOptimizer = true;\n        this.activeControl = ActiveControl.both;\n        this.optimizer = null;\n        this.observers = [];\n        const cp0 = new Vector3d_1.Vector3d(-0.25, 0, -0.15);\n        const cp1 = new Vector3d_1.Vector3d(-0.15, 0.15, -0.05);\n        const cp2 = new Vector3d_1.Vector3d(0, 0.25, -0.05);\n        const cp3 = new Vector3d_1.Vector3d(0.15, 0.15, -0.05);\n        const cp4 = new Vector3d_1.Vector3d(0.25, 0, 0.05);\n        this._spline = new BSplineR1toR3_1.BSplineR1toR3([cp0, cp1, cp2, cp3, cp4], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);\n        this.optimizationProblem = new OpBSplineR1toR3_1.OpBSplineR1toR3(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n    }\n    registerObserver(observer) {\n        this.observers.push(observer);\n    }\n    removeObserver(observer) {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.clone());\n        }\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    get isClosed() {\n        return false;\n    }\n    setControlPointPosition(controlPointIndex, x, y, z) {\n        this._spline = this._spline.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(x, y, z));\n        this.notifyObservers();\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y, z);\n        }\n    }\n    optimize(selectedControlPoint, x, y, z) {\n        if (this.optimizationProblem && this.optimizer) {\n            const p = this.optimizationProblem.spline.freeControlPoints[selectedControlPoint].clone();\n            this._spline.setControlPointPosition(selectedControlPoint, new Vector3d_1.Vector3d(x, y, z));\n            this.optimizationProblem.setTargetSpline(this._spline);\n            try {\n                this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                if (this.optimizer.success === true) {\n                    this.setSpline(this.optimizationProblem.spline.clone());\n                }\n            }\n            catch (e) {\n                this._spline = this._spline.setControlPointPosition(selectedControlPoint, new Vector3d_1.Vector3d(p.x, p.y, p.z));\n                console.log(e);\n            }\n        }\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n    toggleActiveControlOfCurvatureExtrema() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == ActiveControl.both) {\n            this.activeControl = ActiveControl.torsionZeros;\n        }\n        else if (this.activeControl == ActiveControl.torsionZeros) {\n            this.activeControl = ActiveControl.both;\n        }\n        else if (this.activeControl == ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    toggleActiveControlOfTorsionZeros() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = ActiveControl.torsionZeros;\n        }\n        else if (this.activeControl == ActiveControl.both) {\n            this.activeControl = ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == ActiveControl.curvatureExtrema) {\n            this.activeControl = ActiveControl.both;\n        }\n        else if (this.activeControl == ActiveControl.torsionZeros) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OpBSplineR1toR3_1.OpBSplineR1toR3(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n}\nexports.CurveModel3d = CurveModel3d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RationalCurveModel2d = void 0;\nconst RationalBSplineR1toR2_1 = require(\"../bsplines/R1toR2/RationalBSplineR1toR2\");\nconst OpRationalBSplineR1toR2_1 = require(\"../optimizationProblems/OpRationalBSplineR1toR2\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nconst BaseRationalCurve2dModel_1 = require(\"./BaseRationalCurve2dModel\");\nconst RationalBSplineR1toR2Adapter_1 = require(\"../bsplines/R1toR2/RationalBSplineR1toR2Adapter\");\nclass RationalCurveModel2d extends BaseRationalCurve2dModel_1.BaseRationalCurve2dModel {\n    constructor() {\n        super();\n        const cp0 = new Vector3d_1.Vector3d(-0.5, 0, 1);\n        const cp1 = new Vector3d_1.Vector3d(-0.3, 0.5, 1);\n        const cp2 = new Vector3d_1.Vector3d(0, 0.7, 1);\n        const cp3 = new Vector3d_1.Vector3d(0.3, 0.5, 1);\n        const cp4 = new Vector3d_1.Vector3d(0.5, 0, 1);\n        this._spline = new RationalBSplineR1toR2_1.RationalBSplineR1toR2([cp0, cp1, cp2, cp3, cp4], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);\n        //this._spline.elevateDegree()\n        /*\n        const cp0 = new Vector3d(1, 0, 4)\n        const cp1 = new Vector3d(1, 1, Math.pow(2, 0.5) / 2 * 4)\n        const cp2 = new Vector3d(0, 1, 4)\n        let spline = new RationalBSplineR1toR2([ cp0, cp1, cp2], [ 0, 0, 0, 1, 1, 1 ])\n        spline.elevateDegree()\n        spline.elevateDegree()\n        this._spline = spline\n        */\n        this.optimizationProblem = new OpRationalBSplineR1toR2_1.OpRationalBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    getSplineAdapter() {\n        return new RationalBSplineR1toR2Adapter_1.RationalBSplineR1toR2Adapter(this._spline.controlPoints, this._spline.knots);\n    }\n    get isClosed() {\n        return false;\n    }\n    addControlPoint(controlPointIndex) {\n        let cp = controlPointIndex;\n        if (cp != null) {\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this._spline.controlPoints.length - 1) {\n                cp -= 1;\n            }\n            const grevilleAbscissae = this._spline.grevilleAbscissae();\n            this._spline = this._spline.insertKnot(grevilleAbscissae[cp]);\n        }\n        this.optimizationProblem = new OpRationalBSplineR1toR2_1.OpRationalBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OpRationalBSplineR1toR2_1.OpRationalBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n}\nexports.RationalCurveModel2d = RationalCurveModel2d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertStepToVector2d = exports.ActiveControl = exports.BaseOpProblemBSplineR1toR2 = void 0;\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst DiagonalMatrix_1 = require(\"../linearAlgebra/DiagonalMatrix\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nclass BaseOpProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = ActiveControl.curvatureExtrema) {\n        this.activeControl = activeControl;\n        this._hessian_f = undefined;\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        this.inflectionConstraintsSign = [];\n        this._inflectionInactiveConstraints = [];\n        this.curvatureExtremaConstraintsSign = [];\n        this._curvatureExtremaInactiveConstraints = [];\n        this._spline = initial.clone();\n        this._target = target.clone();\n        this.computeBasisFunctionsDerivatives();\n        this._numberOfIndependentVariables = this._spline.freeControlPoints.length * 2;\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        this._hessian_f0 = (0, DiagonalMatrix_1.identityMatrix)(this._numberOfIndependentVariables);\n        const e = this.expensiveComputation(this._spline);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        //this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g)\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        //this._inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator)\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        if (this._f.length !== this._gradient_f.shape[0]) {\n            throw new Error(\"Problem about f length and gradient_f shape in the optimization problem construtor\");\n        }\n    }\n    get inflectionInactiveConstraints() {\n        return this._inflectionInactiveConstraints;\n    }\n    get curvatureExtremaInactiveConstraints() {\n        return this._curvatureExtremaInactiveConstraints;\n    }\n    get numberOfIndependentVariables() {\n        return this._numberOfIndependentVariables;\n    }\n    get f0() {\n        return this._f0;\n    }\n    get gradient_f0() {\n        return this._gradient_f0;\n    }\n    get hessian_f0() {\n        return this._hessian_f0;\n    }\n    get numberOfConstraints() {\n        switch (this.activeControl) {\n            case ActiveControl.both: {\n                return this.inflectionConstraintsSign.length - this._inflectionInactiveConstraints.length + this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case ActiveControl.curvatureExtrema: {\n                return this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case ActiveControl.inflections: {\n                return this.inflectionConstraintsSign.length - this._inflectionInactiveConstraints.length;\n            }\n        }\n    }\n    get f() {\n        return this._f;\n    }\n    get gradient_f() {\n        return this._gradient_f;\n    }\n    get hessian_f() {\n        return this._hessian_f;\n    }\n    step(deltaX) {\n        this._spline = this.spline.moveControlPoints(convertStepToVector2d(deltaX));\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        const e = this.expensiveComputation(this._spline);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        //this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g)\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        //this._inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator)\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    fStep(step) {\n        let splineTemp = this.spline.clone();\n        splineTemp = splineTemp.moveControlPoints(convertStepToVector2d(step));\n        let e = this.expensiveComputation(splineTemp);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        return this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    f0Step(step) {\n        let splineTemp = this.spline.clone();\n        splineTemp = splineTemp.moveControlPoints(convertStepToVector2d(step));\n        return this.compute_f0(this.compute_gradient_f0(splineTemp));\n    }\n    expensiveComputation(spline) {\n        const sx = this.bSplineR1toR1Factory(spline.getControlPointsX(), spline.knots);\n        const sy = this.bSplineR1toR1Factory(spline.getControlPointsY(), spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const bdsxu = sxu.bernsteinDecomposition();\n        const bdsyu = syu.bernsteinDecomposition();\n        const bdsxuu = sxuu.bernsteinDecomposition();\n        const bdsyuu = syuu.bernsteinDecomposition();\n        const bdsxuuu = sxuuu.bernsteinDecomposition();\n        const bdsyuuu = syuuu.bernsteinDecomposition();\n        const h1 = (bdsxu.multiply(bdsxu)).add(bdsyu.multiply(bdsyu));\n        const h2 = (bdsxu.multiply(bdsyuuu)).subtract(bdsyu.multiply(bdsxuuu));\n        const h3 = (bdsxu.multiply(bdsxuu)).add(bdsyu.multiply(bdsyuu));\n        const h4 = (bdsxu.multiply(bdsyuu)).subtract(bdsyu.multiply(bdsxuu));\n        return {\n            bdsxu: bdsxu,\n            bdsyu: bdsyu,\n            bdsxuu: bdsxuu,\n            bdsyuu: bdsyuu,\n            bdsxuuu: bdsxuuu,\n            bdsyuuu: bdsyuuu,\n            h1: h1,\n            h2: h2,\n            h3: h3,\n            h4: h4\n        };\n    }\n    compute_gradient_f0(spline) {\n        let result = [];\n        const n = spline.freeControlPoints.length;\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x);\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y);\n        }\n        return result;\n    }\n    compute_f0(gradient_f0) {\n        let result = 0;\n        const n = gradient_f0.length;\n        for (let i = 0; i < n; i += 1) {\n            result += Math.pow(gradient_f0[i], 2);\n        }\n        return 0.5 * result;\n    }\n    compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureDerivativeNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints(curvatureNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    curvatureNumerator(h4) {\n        return h4.flattenControlPointsArray();\n    }\n    curvatureDerivativeNumerator(h1, h2, h3, h4) {\n        const g = (h1.multiply(h2)).subtract(h3.multiply(h4).multiplyByScalar(3));\n        return g.flattenControlPointsArray();\n    }\n    computeConstraintsSign(controlPoints) {\n        let result = [];\n        for (let i = 0, n = controlPoints.length; i < n; i += 1) {\n            if (controlPoints[i] > 0) {\n                result.push(-1);\n            }\n            else {\n                result.push(1);\n            }\n        }\n        return result;\n    }\n    compute_f(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            const r1 = this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const r2 = this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n            return r1.concat(r2);\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n    compute_gradient_f(e, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            const m1 = this.compute_curvatureExtremaConstraints_gradient(e, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const m2 = this.compute_inflectionConstraints_gradient(e, inflectionConstraintsSign, inflectionInactiveConstraints);\n            const [row_m1, n] = m1.shape;\n            const [row_m2,] = m2.shape;\n            const m = row_m1 + row_m2;\n            let result = new DenseMatrix_1.DenseMatrix(m, n);\n            for (let i = 0; i < row_m1; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(i, j, m1.get(i, j));\n                }\n            }\n            for (let i = 0; i < row_m2; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(row_m1 + i, j, m2.get(i, j));\n                }\n            }\n            return result;\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints_gradient(e, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints_gradient(e, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n}\nexports.BaseOpProblemBSplineR1toR2 = BaseOpProblemBSplineR1toR2;\nvar ActiveControl;\n(function (ActiveControl) {\n    ActiveControl[ActiveControl[\"curvatureExtrema\"] = 0] = \"curvatureExtrema\";\n    ActiveControl[ActiveControl[\"inflections\"] = 1] = \"inflections\";\n    ActiveControl[ActiveControl[\"both\"] = 2] = \"both\";\n})(ActiveControl = exports.ActiveControl || (exports.ActiveControl = {}));\nfunction convertStepToVector2d(step) {\n    let n = step.length / 2;\n    let result = [];\n    for (let i = 0; i < n; i += 1) {\n        result.push(new Vector2d_1.Vector2d(step[i], step[n + i]));\n    }\n    return result;\n}\nexports.convertStepToVector2d = convertStepToVector2d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertStepToVector3d = exports.BaseOpBSplineR1toR3 = void 0;\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst DiagonalMatrix_1 = require(\"../linearAlgebra/DiagonalMatrix\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst CurveModel3d_1 = require(\"../models/CurveModel3d\");\nclass BaseOpBSplineR1toR3 {\n    constructor(target, initial, activeControl = CurveModel3d_1.ActiveControl.curvatureExtrema) {\n        this.activeControl = activeControl;\n        this._hessian_f = undefined;\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        this.torsionConstraintsSign = [];\n        this._torsionZerosInactiveConstraints = [];\n        this.curvatureExtremaConstraintsSign = [];\n        this._curvatureExtremaInactiveConstraints = [];\n        this._spline = initial.clone();\n        this._target = target.clone();\n        this.computeBasisFunctionsDerivatives();\n        this._numberOfIndependentVariables = this._spline.freeControlPoints.length * 3;\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        this._hessian_f0 = (0, DiagonalMatrix_1.identityMatrix)(this._numberOfIndependentVariables);\n        const derivatives = this.computeDerivatives(this._spline);\n        const torsionNumerator = this.torsionNumerator(derivatives);\n        const g = this.curvatureSquaredDerivativeNumerator(derivatives);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        this.torsionConstraintsSign = this.computeConstraintsSign(torsionNumerator);\n        this._torsionZerosInactiveConstraints = this.computeInactiveConstraints(torsionNumerator);\n        this._f = this.compute_f(torsionNumerator, this.torsionConstraintsSign, this._torsionZerosInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(derivatives, this.torsionConstraintsSign, this._torsionZerosInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        if (this._f.length !== this._gradient_f.shape[0]) {\n            throw new Error(\"Problem about f length and gradient_f shape in the optimization problem construtor\");\n        }\n    }\n    get torsionZerosInactiveConstraints() {\n        return this._torsionZerosInactiveConstraints;\n    }\n    get curvatureExtremaInactiveConstraints() {\n        return this._curvatureExtremaInactiveConstraints;\n    }\n    get numberOfIndependentVariables() {\n        return this._numberOfIndependentVariables;\n    }\n    get f0() {\n        return this._f0;\n    }\n    get gradient_f0() {\n        return this._gradient_f0;\n    }\n    get hessian_f0() {\n        return this._hessian_f0;\n    }\n    get numberOfConstraints() {\n        switch (this.activeControl) {\n            case CurveModel3d_1.ActiveControl.both: {\n                return this.torsionConstraintsSign.length - this._torsionZerosInactiveConstraints.length + this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case CurveModel3d_1.ActiveControl.curvatureExtrema: {\n                return this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case CurveModel3d_1.ActiveControl.torsionZeros: {\n                return this.torsionConstraintsSign.length - this._torsionZerosInactiveConstraints.length;\n            }\n        }\n    }\n    get f() {\n        return this._f;\n    }\n    get gradient_f() {\n        return this._gradient_f;\n    }\n    get hessian_f() {\n        return this._hessian_f;\n    }\n    step(deltaX) {\n        this._spline = this.spline.moveControlPoints(convertStepToVector3d(deltaX));\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        const derivatives = this.computeDerivatives(this._spline);\n        const g = this.curvatureSquaredDerivativeNumerator(derivatives);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        const torsionNumerator = this.torsionNumerator(derivatives);\n        this.torsionConstraintsSign = this.computeConstraintsSign(torsionNumerator);\n        this._torsionZerosInactiveConstraints = this.computeInactiveConstraints(torsionNumerator);\n        this._f = this.compute_f(torsionNumerator, this.torsionConstraintsSign, this._torsionZerosInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(derivatives, this.torsionConstraintsSign, this._torsionZerosInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    fStep(step) {\n        const splineTemp = this.spline.moveControlPoints(convertStepToVector3d(step));\n        const s = this.computeDerivatives(splineTemp);\n        const g = this.curvatureSquaredDerivativeNumerator(s);\n        const torsionNumerator = this.torsionNumerator(s);\n        return this.compute_f(torsionNumerator, this.torsionConstraintsSign, this._torsionZerosInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    f0Step(step) {\n        const splineTemp = this.spline.moveControlPoints(convertStepToVector3d(step));\n        return this.compute_f0(this.compute_gradient_f0(splineTemp));\n    }\n    computeDerivatives(spline) {\n        const sx = this.bSplineR1toR1Factory(spline.getControlPointsX(), spline.knots);\n        const sy = this.bSplineR1toR1Factory(spline.getControlPointsY(), spline.knots);\n        const sz = this.bSplineR1toR1Factory(spline.getControlPointsZ(), spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const szu = sz.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const szuu = szu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const szuuu = szuu.derivative();\n        return {\n            x: sx.bernsteinDecomposition(),\n            y: sy.bernsteinDecomposition(),\n            z: sz.bernsteinDecomposition(),\n            xu: sxu.bernsteinDecomposition(),\n            yu: syu.bernsteinDecomposition(),\n            zu: szu.bernsteinDecomposition(),\n            xuu: sxuu.bernsteinDecomposition(),\n            yuu: syuu.bernsteinDecomposition(),\n            zuu: szuu.bernsteinDecomposition(),\n            xuuu: sxuuu.bernsteinDecomposition(),\n            yuuu: syuuu.bernsteinDecomposition(),\n            zuuu: szuuu.bernsteinDecomposition()\n        };\n    }\n    compute_gradient_f0(spline) {\n        let result = [];\n        const n = spline.freeControlPoints.length;\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x);\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y);\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].z - this._target.freeControlPoints[i].z);\n        }\n        return result;\n    }\n    compute_f0(gradient_f0) {\n        let result = 0;\n        const n = gradient_f0.length;\n        for (let i = 0; i < n; i += 1) {\n            result += Math.pow(gradient_f0[i], 2);\n        }\n        return 0.5 * result;\n    }\n    compute_curvatureExtremaConstraints(curvatureSquaredDerivativeNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureSquaredDerivativeNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    compute_torsionConstraints(torsionNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(torsionNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    /*\n    curvatureSquaredNumerator(s: Derivatives) {\n        const t1 = s.zuu.multiply(s.yu).subtract(s.yuu.multiply(s.zu))\n        const t2 = s.xuu.multiply(s.zu).subtract(s.zuu.multiply(s.xu))\n        const t3 = s.yuu.multiply(s.xu).subtract(s.xuu.multiply(s.yu))\n        const result = (t1.multiply(t1).add(t2.multiply(t2)).add(t3.multiply(t3)))\n        return result.flattenControlPointsArray()\n    }\n    */\n    curvatureSquaredDerivativeNumerator(s) {\n        const t1 = s.zuu.multiply(s.yu).subtract(s.yuu.multiply(s.zu));\n        const t2 = s.xuu.multiply(s.zu).subtract(s.zuu.multiply(s.xu));\n        const t3 = s.yuu.multiply(s.xu).subtract(s.xuu.multiply(s.yu));\n        const t4 = s.zuuu.multiply(s.yu).subtract(s.yuuu.multiply(s.zu));\n        const t5 = s.xuuu.multiply(s.zu).subtract(s.zuuu.multiply(s.xu));\n        const t6 = s.yuuu.multiply(s.xu).subtract(s.xuuu.multiply(s.yu));\n        const t7 = s.xu.multiply(s.xu).add(s.yu.multiply(s.yu)).add(s.zu.multiply(s.zu));\n        const t8 = s.xu.multiply(s.xuu).add(s.yu.multiply(s.yuu)).add(s.zu.multiply(s.zuu));\n        const t9 = ((t1.multiply(t4)).add(t2.multiply(t5)).add(t3.multiply(t6))).multiply(t7);\n        const t10 = (t1.multiply(t1).add(t2.multiply(t2)).add(t3.multiply(t3))).multiply(t8);\n        const result = t9.subtract(t10.multiplyByScalar(3));\n        return result.flattenControlPointsArray();\n    }\n    torsionNumerator(s) {\n        const t1 = s.yu.multiply(s.zuu).subtract(s.yuu.multiply(s.zu));\n        const t2 = s.xuu.multiply(s.zu).subtract(s.xu.multiply(s.zuu));\n        const t3 = s.xu.multiply(s.yuu).subtract(s.xuu.multiply(s.yu));\n        const result = s.xuuu.multiply(t1).add(s.yuuu.multiply(t2).add(s.zuuu.multiply(t3)));\n        //console.log(result.flattenControlPointsArray())\n        //console.log(t1)\n        return result.flattenControlPointsArray();\n    }\n    computeConstraintsSign(controlPoints) {\n        let result = [];\n        for (let i = 0, n = controlPoints.length; i < n; i += 1) {\n            if (controlPoints[i] > 0) {\n                result.push(-1);\n            }\n            else {\n                result.push(1);\n            }\n        }\n        return result;\n    }\n    compute_f(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === CurveModel3d_1.ActiveControl.both) {\n            const r1 = this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const r2 = this.compute_torsionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n            return r1.concat(r2);\n        }\n        else if (this.activeControl === CurveModel3d_1.ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_torsionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n    compute_gradient_f(s, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === CurveModel3d_1.ActiveControl.both) {\n            const m1 = this.compute_curvatureExtremaConstraints_gradient(s, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const m2 = this.compute_zeroTorsionConstraints_gradient(s, inflectionConstraintsSign, inflectionInactiveConstraints);\n            const [row_m1, n] = m1.shape;\n            const [row_m2,] = m2.shape;\n            const m = row_m1 + row_m2;\n            let result = new DenseMatrix_1.DenseMatrix(m, n);\n            for (let i = 0; i < row_m1; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(i, j, m1.get(i, j));\n                }\n            }\n            for (let i = 0; i < row_m2; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(row_m1 + i, j, m2.get(i, j));\n                }\n            }\n            return result;\n        }\n        else if (this.activeControl === CurveModel3d_1.ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints_gradient(s, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_zeroTorsionConstraints_gradient(s, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n}\nexports.BaseOpBSplineR1toR3 = BaseOpBSplineR1toR3;\nfunction convertStepToVector3d(step) {\n    let n = step.length / 3;\n    let result = [];\n    for (let i = 0; i < n; i += 1) {\n        result.push(new Vector3d_1.Vector3d(step[i], step[n + i], step[2 * n + i]));\n    }\n    return result;\n}\nexports.convertStepToVector3d = convertStepToVector3d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComputeChenTerms = exports.computeDerivatives = exports.ActiveControl = exports.BaseOpRationalBSplineR1toR2 = void 0;\nconst BernsteinDecompositionR1toR1_1 = require(\"../bsplines/R1toR1/BernsteinDecompositionR1toR1\");\nconst BSplineR1toR1_1 = require(\"../bsplines/R1toR1/BSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst SymmetricMatrix_1 = require(\"../linearAlgebra/SymmetricMatrix\");\nconst BaseOpBSplineR1toR3_1 = require(\"./BaseOpBSplineR1toR3\");\nclass BaseOpRationalBSplineR1toR2 {\n    constructor(target, initial, activeControl = ActiveControl.curvatureExtrema) {\n        this.activeControl = activeControl;\n        this._hessian_f = undefined;\n        this.basisFunctions = [];\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        this.inflectionConstraintsSign = [];\n        this._inflectionInactiveConstraints = [];\n        this.curvatureExtremaConstraintsSign = [];\n        this._curvatureExtremaInactiveConstraints = [];\n        this.weightingFactors = [];\n        this._spline = initial.clone();\n        this._target = target.clone();\n        for (let i = 0; i < this._spline.freeControlPoints.length * 3; i += 1) {\n            this.weightingFactors.push(1);\n        }\n        this.computeBasisFunctionsDerivatives();\n        this._numberOfIndependentVariables = this._spline.freeControlPoints.length * 3;\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        //this._f0 = this.compute_f0(this._gradient_f0)\n        this._f0 = this.compute_f0(this._spline);\n        //this._hessian_f0 = identityMatrix(this._numberOfIndependentVariables)\n        const derivatives = computeDerivatives(this._spline);\n        const ct = ComputeChenTerms(derivatives);\n        const curvatureNumerator = this.curvatureNumerator(derivatives);\n        const g = this.curvatureDerivativeNumerator(derivatives, ct);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        //this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g)\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        //this._inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator)\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(derivatives, ct, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        if (this._f.length !== this._gradient_f.shape[0]) {\n            throw new Error(\"Problem about f length and gradient_f shape in the optimization problem construtor\");\n        }\n    }\n    get inflectionInactiveConstraints() {\n        return this._inflectionInactiveConstraints;\n    }\n    get curvatureExtremaInactiveConstraints() {\n        return this._curvatureExtremaInactiveConstraints;\n    }\n    get numberOfIndependentVariables() {\n        return this._numberOfIndependentVariables;\n    }\n    get f0() {\n        return this._f0;\n    }\n    get gradient_f0() {\n        return this._gradient_f0;\n    }\n    get hessian_f0() {\n        //return this._hessian_f0\n        return this.homogeneous_hessian_f0();\n    }\n    get numberOfConstraints() {\n        switch (this.activeControl) {\n            case ActiveControl.both: {\n                return this.inflectionConstraintsSign.length - this._inflectionInactiveConstraints.length + this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case ActiveControl.curvatureExtrema: {\n                return this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case ActiveControl.inflections: {\n                return this.inflectionConstraintsSign.length - this._inflectionInactiveConstraints.length;\n            }\n        }\n    }\n    get f() {\n        return this._f;\n    }\n    get gradient_f() {\n        return this._gradient_f;\n    }\n    get hessian_f() {\n        return this._hessian_f;\n    }\n    step(deltaX) {\n        this._spline = this.spline.moveControlPoints((0, BaseOpBSplineR1toR3_1.convertStepToVector3d)(deltaX));\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        //this._f0 = this.compute_f0(this._gradient_f0)\n        this._f0 = this.compute_f0(this._spline);\n        const derivatives = computeDerivatives(this._spline);\n        const ct = ComputeChenTerms(derivatives);\n        const g = this.curvatureDerivativeNumerator(derivatives, ct);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        //this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g)\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        const curvatureNumerator = this.curvatureNumerator(derivatives);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        //this._inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator)\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(derivatives, ct, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    fStep(step) {\n        const splineTemp = this.spline.moveControlPoints((0, BaseOpBSplineR1toR3_1.convertStepToVector3d)(step));\n        const derivatives = computeDerivatives(splineTemp);\n        const ct = ComputeChenTerms(derivatives);\n        const g = this.curvatureDerivativeNumerator(derivatives, ct);\n        const curvatureNumerator = this.curvatureNumerator(derivatives);\n        return this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    f0Step(step) {\n        const splineTemp = this.spline.moveControlPoints((0, BaseOpBSplineR1toR3_1.convertStepToVector3d)(step));\n        //return this.compute_f0(this.compute_gradient_f0(splineTemp))\n        return this.homogeneous_f0(splineTemp);\n    }\n    compute_gradient_f0(spline) {\n        /*\n        let result: number[] = []\n        const n =  spline.freeControlPoints.length\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x)\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y)\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push((spline.freeControlPoints[i].z - this._target.freeControlPoints[i].z))\n        }\n        return result\n        */\n        return this.homogeneous_gradient_f0(spline);\n    }\n    homogeneous_f0(spline, factor = 0.1) {\n        let result = 0;\n        const n = spline.freeControlPoints.length;\n        for (let i = 0; i < n; i += 1) {\n            result += 0.5 * Math.pow((spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x / this._target.freeControlPoints[i].z * spline.freeControlPoints[i].z), 2);\n            result += 0.5 * Math.pow((spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y / this._target.freeControlPoints[i].z * spline.freeControlPoints[i].z), 2);\n            result += 0.5 * Math.pow(spline.freeControlPoints[i].z - this._target.freeControlPoints[i].z, 2) * factor;\n        }\n        return result;\n    }\n    homogeneous_gradient_f0(spline, factor = 0.1) {\n        let result = [];\n        const n = spline.freeControlPoints.length;\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x / this._target.freeControlPoints[i].z * spline.freeControlPoints[i].z);\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y / this._target.freeControlPoints[i].z * spline.freeControlPoints[i].z);\n        }\n        for (let i = 0; i < n; i += 1) {\n            const t1 = (spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x / this._target.freeControlPoints[i].z * spline.freeControlPoints[i].z) * (-this._target.freeControlPoints[i].x / this._target.freeControlPoints[i].z);\n            const t2 = (spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y / this._target.freeControlPoints[i].z * spline.freeControlPoints[i].z) * (-this._target.freeControlPoints[i].y / this._target.freeControlPoints[i].z);\n            const t3 = (spline.freeControlPoints[i].z - this._target.freeControlPoints[i].z) * factor;\n            result.push(t1 + t2 + t3);\n        }\n        return result;\n    }\n    homogeneous_hessian_f0(factor = 0.1) {\n        const startY = this._numberOfIndependentVariables * 1 / 3;\n        const startZ = this._numberOfIndependentVariables * 2 / 3;\n        const end = this._numberOfIndependentVariables;\n        let result = new SymmetricMatrix_1.SymmetricMatrix(this._numberOfIndependentVariables);\n        for (let i = 0; i < this._numberOfIndependentVariables * 2 / 3; i += 1) {\n            result.set(i, i, 1);\n        }\n        for (let i = startZ; i < end; i += 1) {\n            let cp = this._target.freeControlPoints[i - this._numberOfIndependentVariables * 2 / 3];\n            result.set(i, i, Math.pow(cp.x / cp.z, 2) + Math.pow(cp.y / cp.z, 2) + factor);\n        }\n        for (let i = 0; i < startY; i += 1) {\n            result.set(i, i + startZ, -this._target.freeControlPoints[i].x / this._target.freeControlPoints[i].z);\n            result.set(i + startY, i + startZ, -this._target.freeControlPoints[i].y / this._target.freeControlPoints[i].z);\n        }\n        return result;\n    }\n    /*\n        compute_f0(gradient_f0: number[]) {\n            let result = 0\n            const n = gradient_f0.length;\n            for (let i = 0; i < n; i += 1) {\n                result += Math.pow(gradient_f0[i], 2)\n            }\n            return 0.5 * result\n        }\n    */\n    compute_f0(spline) {\n        return this.homogeneous_f0(spline);\n    }\n    compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureDerivativeNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints(curvatureNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    curvatureNumerator(s) {\n        // reference: XIANMING CHEN, COMPLEXITY REDUCTION FOR SYMBOLIC COMPUTATION WITH RATIONAL B-SPLINES\n        const t1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xu, s.yu, s.xuu, s.yuu).multiply(s.w);\n        const t2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.x, s.y, s.xuu, s.yuu).multiply(s.wu);\n        const t3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xu, s.yu, s.x, s.y).multiply(s.wuu);\n        return (t1.subtract(t2).subtract(t3)).flattenControlPointsArray();\n    }\n    curvatureDerivativeNumerator(s, ct) {\n        const t0 = (ct.D1x.multiply(ct.D1x)).add(ct.D1y.multiply(ct.D1y));\n        const t1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D3x, ct.D3y);\n        const t2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D21x, ct.D21y);\n        const t3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D2x, ct.D2y);\n        const t4 = s.wu.multiplyByScalar(2);\n        const t5 = (ct.D1x.multiply(ct.D2x)).add(ct.D1y.multiply(ct.D2y)).multiplyByScalar(3);\n        return ((t1.add(t2)).multiply(t0).multiply(s.w)).add(t4.multiply(t3).multiply(t0)).subtract(t5.multiply(t3).multiply(s.w)).flattenControlPointsArray();\n    }\n    computeConstraintsSign(controlPoints) {\n        let result = [];\n        for (let i = 0, n = controlPoints.length; i < n; i += 1) {\n            if (controlPoints[i] > 0) {\n                result.push(-1);\n            }\n            else {\n                result.push(1);\n            }\n        }\n        return result;\n    }\n    compute_f(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            const r1 = this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const r2 = this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n            return r1.concat(r2);\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n    compute_gradient_f(d, ct, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            const m1 = this.compute_curvatureExtremaConstraints_gradient(d, ct, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const m2 = this.compute_inflectionConstraints_gradient(d, inflectionConstraintsSign, inflectionInactiveConstraints);\n            const [row_m1, n] = m1.shape;\n            const [row_m2,] = m2.shape;\n            const m = row_m1 + row_m2;\n            let result = new DenseMatrix_1.DenseMatrix(m, n);\n            for (let i = 0; i < row_m1; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(i, j, m1.get(i, j));\n                }\n            }\n            for (let i = 0; i < row_m2; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(row_m1 + i, j, m2.get(i, j));\n                }\n            }\n            return result;\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints_gradient(d, ct, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints_gradient(d, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n}\nexports.BaseOpRationalBSplineR1toR2 = BaseOpRationalBSplineR1toR2;\nvar ActiveControl;\n(function (ActiveControl) {\n    ActiveControl[ActiveControl[\"curvatureExtrema\"] = 0] = \"curvatureExtrema\";\n    ActiveControl[ActiveControl[\"inflections\"] = 1] = \"inflections\";\n    ActiveControl[ActiveControl[\"both\"] = 2] = \"both\";\n})(ActiveControl = exports.ActiveControl || (exports.ActiveControl = {}));\nfunction computeDerivatives(spline) {\n    const sx = new BSplineR1toR1_1.BSplineR1toR1(spline.getControlPointsX(), spline.knots);\n    const sy = new BSplineR1toR1_1.BSplineR1toR1(spline.getControlPointsY(), spline.knots);\n    const sw = new BSplineR1toR1_1.BSplineR1toR1(spline.getControlPointsW(), spline.knots);\n    const sxu = sx.derivative();\n    const syu = sy.derivative();\n    const swu = sw.derivative();\n    const sxuu = sxu.derivative();\n    const syuu = syu.derivative();\n    const swuu = swu.derivative();\n    const sxuuu = sxuu.derivative();\n    const syuuu = syuu.derivative();\n    const swuuu = swuu.derivative();\n    return {\n        x: sx.bernsteinDecomposition(),\n        y: sy.bernsteinDecomposition(),\n        w: sw.bernsteinDecomposition(),\n        xu: sxu.bernsteinDecomposition(),\n        yu: syu.bernsteinDecomposition(),\n        wu: swu.bernsteinDecomposition(),\n        xuu: sxuu.bernsteinDecomposition(),\n        yuu: syuu.bernsteinDecomposition(),\n        wuu: swuu.bernsteinDecomposition(),\n        xuuu: sxuuu.bernsteinDecomposition(),\n        yuuu: syuuu.bernsteinDecomposition(),\n        wuuu: swuuu.bernsteinDecomposition()\n    };\n}\nexports.computeDerivatives = computeDerivatives;\nfunction ComputeChenTerms(s) {\n    // reference: XIANMING CHEN, COMPLEXITY REDUCTION FOR SYMBOLIC COMPUTATION WITH RATIONAL B-SPLINES\n    return {\n        w: s.w,\n        wu: s.wu,\n        D1x: (s.xu.multiply(s.w)).subtract(s.x.multiply(s.wu)),\n        D1y: (s.yu.multiply(s.w)).subtract(s.y.multiply(s.wu)),\n        D2x: (s.xuu.multiply(s.w)).subtract(s.x.multiply(s.wuu)),\n        D2y: (s.yuu.multiply(s.w)).subtract(s.y.multiply(s.wuu)),\n        D3x: (s.xuuu.multiply(s.w)).subtract(s.x.multiply(s.wuuu)),\n        D3y: (s.yuuu.multiply(s.w)).subtract(s.y.multiply(s.wuuu)),\n        D21x: (s.xuu.multiply(s.wu)).subtract(s.xu.multiply(s.wuu)),\n        D21y: (s.yuu.multiply(s.wu)).subtract(s.yu.multiply(s.wuu))\n    };\n}\nexports.ComputeChenTerms = ComputeChenTerms;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OpBSplineR1toR2 = void 0;\nconst BSplineR1toR1_1 = require(\"../bsplines/R1toR1/BSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst BaseOpBSplineR1toR2_1 = require(\"./BaseOpBSplineR1toR2\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nclass OpBSplineR1toR2 extends BaseOpBSplineR1toR2_1.BaseOpProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial, activeControl);\n        this.activeControl = activeControl;\n    }\n    get spline() {\n        return this._spline;\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    setTargetSpline(spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n    }\n    /**\n     * Some contraints are set inactive to allowed the point of inflection or curvature extrema\n     * to slide along the curve.\n     **/\n    computeInactiveConstraints(controlPoints) {\n        let controlPointsSequences = this.extractChangingSignControlPointsSequences(controlPoints);\n        return this.extractControlPointsClosestToZero(controlPointsSequences);\n    }\n    extractChangingSignControlPointsSequences(controlPoints) {\n        let result = [];\n        let successiveControlPoints = [];\n        let i = 1;\n        while (i < controlPoints.length) {\n            successiveControlPoints = [];\n            if (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                successiveControlPoints.push({ index: i - 1, value: controlPoints[i - 1] });\n                successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                i += 1;\n                while (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                    successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                    i += 1;\n                }\n                result.push(successiveControlPoints);\n            }\n            i += 1;\n        }\n        return result;\n    }\n    extractControlPointsClosestToZero(polygonSegments) {\n        let result = [];\n        for (let polygonSegment of polygonSegments) {\n            let s = this.removeBiggest(polygonSegment);\n            for (let iv of s) {\n                result.push(iv.index);\n            }\n        }\n        return result;\n    }\n    removeBiggest(controlPointsSequence) {\n        let result = controlPointsSequence.slice();\n        let maxIndex = 0;\n        for (let i = 1; i < controlPointsSequence.length; i += 1) {\n            if (Math.pow(controlPointsSequence[i].value, 2) > Math.pow(controlPointsSequence[maxIndex].value, 2)) {\n                maxIndex = i;\n            }\n        }\n        result.splice(maxIndex, 1);\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const sxuuu = e.bdsxuuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        const syuuu = e.bdsyuuu;\n        const h1 = e.h1;\n        const h2 = e.h2;\n        const h3 = e.h3;\n        const h4 = e.h4;\n        let dgx = [];\n        let dgy = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const totalNumberOfConstraints = constraintsSign.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(sxu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(syuuu, start, lessThan);\n            let h7 = syu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan).multiplyByScalar(-1);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan);\n            let h9 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(syu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            let h7 = sxu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h9 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (4 * degree - 5);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (4 * degree - 5);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        let dgx = [];\n        let dgy = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        const totalNumberOfConstraints = this.inflectionConstraintsSign.length;\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (2 * degree - 2);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (2 * degree - 2);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    computeBasisFunctionsDerivatives() {\n        const n = this._spline.controlPoints.length;\n        //??????????\n        this._numberOfIndependentVariables = n * 2;\n        let diracControlPoints = (0, MathVectorBasicOperations_1.zeroVector)(n);\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        for (let i = 0; i < n; i += 1) {\n            diracControlPoints[i] = 1;\n            let basisFunction = this.bSplineR1toR1Factory(diracControlPoints.slice(), this._spline.knots.slice());\n            let dBasisFunction_du = basisFunction.derivative();\n            let d2BasisFunction_du2 = dBasisFunction_du.derivative();\n            let d3BasisFunction_du3 = d2BasisFunction_du2.derivative();\n            this.dBasisFunctions_du.push(dBasisFunction_du.bernsteinDecomposition());\n            this.d2BasisFunctions_du2.push(d2BasisFunction_du2.bernsteinDecomposition());\n            this.d3BasisFunctions_du3.push(d3BasisFunction_du3.bernsteinDecomposition());\n            diracControlPoints[i] = 0;\n        }\n    }\n}\nexports.OpBSplineR1toR2 = OpBSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OpBSplineR1toR3 = void 0;\nconst BSplineR1toR1_1 = require(\"../bsplines/R1toR1/BSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst BernsteinDecompositionR1toR1_1 = require(\"../bsplines/R1toR1/BernsteinDecompositionR1toR1\");\nconst BaseOpBSplineR1toR3_1 = require(\"./BaseOpBSplineR1toR3\");\nconst CurveModel3d_1 = require(\"../models/CurveModel3d\");\nclass OpBSplineR1toR3 extends BaseOpBSplineR1toR3_1.BaseOpBSplineR1toR3 {\n    constructor(target, initial, activeControl = CurveModel3d_1.ActiveControl.curvatureExtrema) {\n        super(target, initial, activeControl);\n        this.activeControl = activeControl;\n    }\n    get spline() {\n        return this._spline;\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    setTargetSpline(spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n    }\n    /**\n     * Some contraints are set inactive to allowed the point of inflection or curvature extrema\n     * to slide along the curve.\n     **/\n    computeInactiveConstraints(controlPoints) {\n        let controlPointsSequences = this.extractChangingSignControlPointsSequences(controlPoints);\n        return this.extractControlPointsClosestToZero(controlPointsSequences);\n    }\n    extractChangingSignControlPointsSequences(controlPoints) {\n        let result = [];\n        let successiveControlPoints = [];\n        let i = 1;\n        while (i < controlPoints.length) {\n            successiveControlPoints = [];\n            if (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                successiveControlPoints.push({ index: i - 1, value: controlPoints[i - 1] });\n                successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                i += 1;\n                while (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                    successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                    i += 1;\n                }\n                result.push(successiveControlPoints);\n            }\n            i += 1;\n        }\n        return result;\n    }\n    extractControlPointsClosestToZero(polygonSegments) {\n        let result = [];\n        for (let polygonSegment of polygonSegments) {\n            let s = this.removeBiggest(polygonSegment);\n            for (let iv of s) {\n                result.push(iv.index);\n            }\n        }\n        return result;\n    }\n    removeBiggest(controlPointsSequence) {\n        let result = controlPointsSequence.slice();\n        let maxIndex = 0;\n        for (let i = 1; i < controlPointsSequence.length; i += 1) {\n            if (Math.pow(controlPointsSequence[i].value, 2) > Math.pow(controlPointsSequence[maxIndex].value, 2)) {\n                maxIndex = i;\n            }\n        }\n        result.splice(maxIndex, 1);\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient(s, constraintsSign, inactiveConstraints) {\n        let dgx = [];\n        let dgy = [];\n        let dgz = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const totalNumberOfConstraints = constraintsSign.length;\n        const degree = this.spline.degree;\n        const d1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.zuu, s.yuu, s.zu, s.yu);\n        const dd1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.zuuu, s.yuuu, s.zu, s.yu);\n        const d2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xuu, s.zuu, s.xu, s.zu);\n        const dd2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xuuu, s.zuuu, s.xu, s.zu);\n        const d3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.yuu, s.xuu, s.yu, s.xu);\n        const dd3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.yuuu, s.xuuu, s.yu, s.xu);\n        const l2 = s.xu.multiply(s.xu).add(s.yu.multiply(s.yu)).add(s.zu.multiply(s.zu));\n        const ddd = d1.multiply(dd1).add(d2.multiply(dd2)).add(d3.multiply(dd3));\n        const dl2 = s.xu.multiply(s.xuu).add(s.yu.multiply(s.yuu)).add(s.zu.multiply(s.zuu));\n        const ddd2 = d1.multiply(d1).add(d2.multiply(d2)).add(d3.multiply(d3));\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t2a = this.d2BasisFunctions_du2[i].multiplyRange(s.zu, start, lessThan);\n            let t2b = this.dBasisFunctions_du[i].multiplyRange(s.zuu, start, lessThan);\n            let t2c = this.d3BasisFunctions_du3[i].multiplyRange(s.zu, start, lessThan);\n            let t2d = this.dBasisFunctions_du[i].multiplyRange(s.zuuu, start, lessThan);\n            let t2e = (t2a.subtract(t2b)).multiplyRange2(dd2, start, lessThan);\n            let t2f = (t2c.subtract(t2d)).multiplyRange2(d2, start, lessThan);\n            let t2 = t2e.add(t2f);\n            let t3a = this.dBasisFunctions_du[i].multiplyRange(s.yuu, start, lessThan);\n            let t3b = this.d2BasisFunctions_du2[i].multiplyRange(s.yu, start, lessThan);\n            let t3c = this.dBasisFunctions_du[i].multiplyRange(s.yuuu, start, lessThan);\n            let t3d = this.d3BasisFunctions_du3[i].multiplyRange(s.yu, start, lessThan);\n            let t3e = (t3a.subtract(t3b)).multiplyRange2(dd3, start, lessThan);\n            let t3f = (t3c.subtract(t3d)).multiplyRange2(d3, start, lessThan);\n            let t3 = t3e.add(t3f);\n            let z1 = (t2.add(t3)).multiplyRange2(l2, start, lessThan);\n            let t4 = this.dBasisFunctions_du[i].multiplyRange(s.xu, start, lessThan).multiplyByScalar(2);\n            let z2 = t4.multiplyRange2(ddd, start, lessThan);\n            let z3a = (t2a.subtract(t2b)).multiplyRange2(d2, start, lessThan);\n            let z3b = (t3a.subtract(t3b)).multiplyRange2(d3, start, lessThan);\n            let z3 = (z3a.add(z3b)).multiplyRange2(dl2, start, lessThan).multiplyByScalar(-6);\n            let z4a = this.dBasisFunctions_du[i].multiplyRange(s.xuu, start, lessThan);\n            let z4b = this.d2BasisFunctions_du2[i].multiplyRange(s.xu, start, lessThan);\n            let z4 = (z4a.add(z4b)).multiplyRange2(ddd2, start, lessThan).multiplyByScalar(-3);\n            dgx.push(z1.add(z2).add(z3).add(z4));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1a = this.dBasisFunctions_du[i].multiplyRange(s.zuu, start, lessThan);\n            let t1b = this.d2BasisFunctions_du2[i].multiplyRange(s.zu, start, lessThan);\n            let t1c = this.dBasisFunctions_du[i].multiplyRange(s.zuuu, start, lessThan);\n            let t1d = this.d3BasisFunctions_du3[i].multiplyRange(s.zu, start, lessThan);\n            let t1e = (t1a.subtract(t1b)).multiplyRange2(dd3, start, lessThan);\n            let t1f = (t1c.subtract(t1d)).multiplyRange2(d3, start, lessThan);\n            let t1 = t1e.add(t1f);\n            let t3a = this.d2BasisFunctions_du2[i].multiplyRange(s.xu, start, lessThan);\n            let t3b = this.dBasisFunctions_du[i].multiplyRange(s.xuu, start, lessThan);\n            let t3c = this.d3BasisFunctions_du3[i].multiplyRange(s.xu, start, lessThan);\n            let t3d = this.dBasisFunctions_du[i].multiplyRange(s.xuuu, start, lessThan);\n            let t3e = (t3a.subtract(t3b)).multiplyRange2(dd2, start, lessThan);\n            let t3f = (t3c.subtract(t3d)).multiplyRange2(d2, start, lessThan);\n            let t3 = t3e.add(t3f);\n            let z1 = (t1.add(t3)).multiplyRange2(l2, start, lessThan);\n            let t4 = this.dBasisFunctions_du[i].multiplyRange(s.yu, start, lessThan).multiplyByScalar(2);\n            let z2 = t4.multiplyRange2(ddd, start, lessThan);\n            let z3a = (t1a.subtract(t1b)).multiplyRange2(d1, start, lessThan);\n            let z3b = (t3a.subtract(t3b)).multiplyRange2(d3, start, lessThan);\n            let z3 = (z3a.add(z3b)).multiplyRange2(dl2, start, lessThan).multiplyByScalar(-6);\n            let z4a = this.dBasisFunctions_du[i].multiplyRange(s.yuu, start, lessThan);\n            let z4b = this.d2BasisFunctions_du2[i].multiplyRange(s.yu, start, lessThan);\n            let z4 = (z4a.add(z4b)).multiplyRange2(ddd2, start, lessThan).multiplyByScalar(-3);\n            dgy.push(z1.add(z2).add(z3).add(z4));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1a = this.d2BasisFunctions_du2[i].multiplyRange(s.yu, start, lessThan);\n            let t1b = this.dBasisFunctions_du[i].multiplyRange(s.yuu, start, lessThan);\n            let t1c = this.d3BasisFunctions_du3[i].multiplyRange(s.yu, start, lessThan);\n            let t1d = this.dBasisFunctions_du[i].multiplyRange(s.yuuu, start, lessThan);\n            let t1e = (t1a.subtract(t1b)).multiplyRange2(dd2, start, lessThan);\n            let t1f = (t1c.subtract(t1d)).multiplyRange2(d2, start, lessThan);\n            let t1 = t1e.add(t1f);\n            let t2a = this.dBasisFunctions_du[i].multiplyRange(s.xuu, start, lessThan);\n            let t2b = this.d2BasisFunctions_du2[i].multiplyRange(s.xu, start, lessThan);\n            let t2c = this.dBasisFunctions_du[i].multiplyRange(s.xuuu, start, lessThan);\n            let t2d = this.d3BasisFunctions_du3[i].multiplyRange(s.xu, start, lessThan);\n            let t2e = (t2a.subtract(t2b)).multiplyRange2(dd3, start, lessThan);\n            let t2f = (t2c.subtract(t2d)).multiplyRange2(d3, start, lessThan);\n            let t2 = t2e.add(t2f);\n            let z1 = (t1.add(t2)).multiplyRange2(l2, start, lessThan);\n            let t4 = this.dBasisFunctions_du[i].multiplyRange(s.yu, start, lessThan).multiplyByScalar(2);\n            let z2 = t4.multiplyRange2(ddd, start, lessThan);\n            let z3a = (t1a.subtract(t1b)).multiplyRange2(d1, start, lessThan);\n            let z3b = (t2a.subtract(t2b)).multiplyRange2(d2, start, lessThan);\n            let z3 = (z3a.add(z3b)).multiplyRange2(dl2, start, lessThan).multiplyByScalar(-6);\n            let z4a = this.dBasisFunctions_du[i].multiplyRange(s.zuu, start, lessThan);\n            let z4b = this.d2BasisFunctions_du2[i].multiplyRange(s.zu, start, lessThan);\n            let z4 = (z4a.add(z4b)).multiplyRange2(ddd2, start, lessThan).multiplyByScalar(-3);\n            dgz.push(z1.add(z2).add(z3).add(z4));\n        }\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 3 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let cpz = dgz[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (6 * degree - 8);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (6 * degree - 8);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, 2 * controlPointsLength + i, cpz[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    compute_zeroTorsionConstraints_gradient(s, constraintsSign, inactiveConstraints) {\n        let dgx = [];\n        let dgy = [];\n        let dgz = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const degree = this.spline.degree;\n        const d1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.zuu, s.yuu, s.zu, s.yu);\n        const d2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xuu, s.zuu, s.xu, s.zu);\n        const d3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.yuu, s.xuu, s.yu, s.xu);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1 = this.d3BasisFunctions_du3[i].multiplyRange(d1, start, lessThan);\n            let t2 = this.d2BasisFunctions_du2[i].multiplyRange(s.yuuu, start, lessThan).multiplyRange2(s.zu, start, lessThan);\n            let t3 = this.dBasisFunctions_du[i].multiplyRange(s.yuuu, start, lessThan).multiplyRange2(s.zuu, start, lessThan);\n            let t4 = this.dBasisFunctions_du[i].multiplyRange(s.yuu, start, lessThan).multiplyRange2(s.zuuu, start, lessThan);\n            let t5 = this.d2BasisFunctions_du2[i].multiplyRange(s.yu, start, lessThan).multiplyRange2(s.zuuu, start, lessThan);\n            dgx.push((t1.add(t2).subtract(t3).add(t4).subtract(t5)));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1 = this.d3BasisFunctions_du3[i].multiplyRange(d2, start, lessThan);\n            let t2 = this.dBasisFunctions_du[i].multiplyRange(s.xuuu, start, lessThan).multiplyRange2(s.zuu, start, lessThan);\n            let t3 = this.d2BasisFunctions_du2[i].multiplyRange(s.xuuu, start, lessThan).multiplyRange2(s.zu, start, lessThan);\n            let t4 = this.d2BasisFunctions_du2[i].multiplyRange(s.zuuu, start, lessThan).multiplyRange2(s.xu, start, lessThan);\n            let t5 = this.dBasisFunctions_du[i].multiplyRange(s.zuuu, start, lessThan).multiplyRange2(s.xuu, start, lessThan);\n            dgy.push((t1.add(t2).subtract(t3).add(t4).subtract(t5)));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1 = this.d3BasisFunctions_du3[i].multiplyRange(d3, start, lessThan);\n            let t2 = this.d2BasisFunctions_du2[i].multiplyRange(s.xuuu, start, lessThan).multiplyRange2(s.yu, start, lessThan);\n            let t3 = this.dBasisFunctions_du[i].multiplyRange(s.xuuu, start, lessThan).multiplyRange2(s.yuu, start, lessThan);\n            let t4 = this.dBasisFunctions_du[i].multiplyRange(s.yuuu, start, lessThan).multiplyRange2(s.xuu, start, lessThan);\n            let t5 = this.d2BasisFunctions_du2[i].multiplyRange(s.yuuu, start, lessThan).multiplyRange2(s.xu, start, lessThan);\n            dgz.push((t1.add(t2).subtract(t3).add(t4).subtract(t5)));\n        }\n        const totalNumberOfConstraints = this.torsionConstraintsSign.length;\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 3 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let cpz = dgz[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (3 * degree - 5);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (3 * degree - 5);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, 2 * controlPointsLength + i, cpz[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    computeBasisFunctionsDerivatives() {\n        const n = this._spline.controlPoints.length;\n        this._numberOfIndependentVariables = n * 2;\n        let diracControlPoints = (0, MathVectorBasicOperations_1.zeroVector)(n);\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        for (let i = 0; i < n; i += 1) {\n            diracControlPoints[i] = 1;\n            let basisFunction = this.bSplineR1toR1Factory(diracControlPoints.slice(), this._spline.knots.slice());\n            let dBasisFunction_du = basisFunction.derivative();\n            let d2BasisFunction_du2 = dBasisFunction_du.derivative();\n            let d3BasisFunction_du3 = d2BasisFunction_du2.derivative();\n            this.dBasisFunctions_du.push(dBasisFunction_du.bernsteinDecomposition());\n            this.d2BasisFunctions_du2.push(d2BasisFunction_du2.bernsteinDecomposition());\n            this.d3BasisFunctions_du3.push(d3BasisFunction_du3.bernsteinDecomposition());\n            diracControlPoints[i] = 0;\n        }\n    }\n}\nexports.OpBSplineR1toR3 = OpBSplineR1toR3;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OpRationalBSplineR1toR2 = void 0;\nconst BSplineR1toR1_1 = require(\"../bsplines/R1toR1/BSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst BaseOpBSplineR1toR2_1 = require(\"./BaseOpBSplineR1toR2\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst BernsteinDecompositionR1toR1_1 = require(\"../bsplines/R1toR1/BernsteinDecompositionR1toR1\");\nconst BaseOpRationalBSplineR1toR2_1 = require(\"./BaseOpRationalBSplineR1toR2\");\nclass OpRationalBSplineR1toR2 extends BaseOpRationalBSplineR1toR2_1.BaseOpRationalBSplineR1toR2 {\n    constructor(target, initial, activeControl = BaseOpBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial, activeControl);\n        this.activeControl = activeControl;\n    }\n    get spline() {\n        return this._spline;\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    setTargetSpline(spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        //this._f0 = this.compute_f0(this._gradient_f0)\n        this._f0 = this.compute_f0(this.spline);\n    }\n    /**\n     * Some contraints are set inactive to allowed the point of inflection or curvature extrema\n     * to slide along the curve.\n     **/\n    computeInactiveConstraints(controlPoints) {\n        let controlPointsSequences = this.extractChangingSignControlPointsSequences(controlPoints);\n        return this.extractControlPointsClosestToZero(controlPointsSequences);\n    }\n    extractChangingSignControlPointsSequences(controlPoints) {\n        let result = [];\n        let successiveControlPoints = [];\n        let i = 1;\n        while (i < controlPoints.length) {\n            successiveControlPoints = [];\n            if (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                successiveControlPoints.push({ index: i - 1, value: controlPoints[i - 1] });\n                successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                i += 1;\n                while (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                    successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                    i += 1;\n                }\n                result.push(successiveControlPoints);\n            }\n            i += 1;\n        }\n        return result;\n    }\n    extractControlPointsClosestToZero(polygonSegments) {\n        let result = [];\n        for (let polygonSegment of polygonSegments) {\n            let s = this.removeBiggest(polygonSegment);\n            for (let iv of s) {\n                result.push(iv.index);\n            }\n        }\n        return result;\n    }\n    removeBiggest(controlPointsSequence) {\n        let result = controlPointsSequence.slice();\n        let maxIndex = 0;\n        for (let i = 1; i < controlPointsSequence.length; i += 1) {\n            if (Math.pow(controlPointsSequence[i].value, 2) > Math.pow(controlPointsSequence[maxIndex].value, 2)) {\n                maxIndex = i;\n            }\n        }\n        result.splice(maxIndex, 1);\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient(s, ct, constraintsSign, inactiveConstraints) {\n        let dgx = [];\n        let dgy = [];\n        let dgw = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const totalNumberOfConstraints = constraintsSign.length;\n        const degree = this.spline.degree;\n        const D1xD3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D3x, ct.D3y);\n        const D1xD21 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D21x, ct.D21y);\n        const D1xD2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(ct.D1x, ct.D1y, ct.D2x, ct.D2y);\n        const D1dotD1 = ct.D1x.multiply(ct.D1x).add(ct.D1y.multiply(ct.D1y));\n        const D1dotD2 = ct.D1x.multiply(ct.D2x).add(ct.D1y.multiply(ct.D2y));\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            // Can be improved since the same 4 lines occur in the next for loop!\n            let dD1 = this.dBasisFunctions_du[i].multiplyRange(s.w, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.wu, start, lessThan));\n            let dD2 = this.d2BasisFunctions_du2[i].multiplyRange(s.w, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.wuu, start, lessThan));\n            let dD3 = this.d3BasisFunctions_du3[i].multiplyRange(s.w, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.wuuu, start, lessThan));\n            let dD21 = this.d2BasisFunctions_du2[i].multiplyRange(s.wu, start, lessThan).subtract(this.dBasisFunctions_du[i].multiplyRange(s.wuu, start, lessThan));\n            let dD1xD3 = dD1.multiplyRange2(ct.D3y, start, lessThan).subtract(dD3.multiplyRange2(ct.D1y, start, lessThan));\n            let dD1xD21 = dD1.multiplyRange2(ct.D21y, start, lessThan).subtract(dD21.multiplyRange2(ct.D1y, start, lessThan));\n            let dD1xD2 = dD1.multiplyRange2(ct.D2y, start, lessThan).subtract(dD2.multiplyRange2(ct.D1y, start, lessThan));\n            let dD1dotD1 = dD1.multiplyRange2(ct.D1x, start, lessThan).multiplyByScalar(2);\n            let dD1dotD2 = dD1.multiplyRange2(ct.D2x, start, lessThan).add(dD2.multiplyRange2(ct.D1x, start, lessThan));\n            let t1a = dD1xD3.multiplyRange2(D1dotD1, start, lessThan);\n            let t1b = dD1dotD1.multiplyRange2(D1xD3, start, lessThan);\n            let t1 = t1a.add(t1b).multiplyRange2(s.w, start, lessThan);\n            let t2a = dD1xD21.multiplyRange2(D1dotD1, start, lessThan);\n            let t2b = dD1dotD1.multiplyRange2(D1xD21, start, lessThan);\n            let t2 = (t2a.add(t2b)).multiplyRange2(s.w, start, lessThan);\n            let t3a = dD1xD2.multiplyRange2(D1dotD1, start, lessThan);\n            let t3b = dD1dotD1.multiplyRange2(D1xD2, start, lessThan);\n            let t3 = t3a.add(t3b).multiplyRange2(s.wu, start, lessThan).multiplyByScalar(2);\n            let t4a = dD1xD2.multiplyRange2(D1dotD2, start, lessThan);\n            let t4b = dD1dotD2.multiplyRange2(D1xD2, start, lessThan);\n            let t4 = t4a.add(t4b).multiplyRange2(s.w, start, lessThan).multiplyByScalar(-3);\n            dgx.push(t1.add(t2).add(t3).add(t4));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let dD1 = this.dBasisFunctions_du[i].multiplyRange(s.w, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.wu, start, lessThan));\n            let dD2 = this.d2BasisFunctions_du2[i].multiplyRange(s.w, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.wuu, start, lessThan));\n            let dD3 = this.d3BasisFunctions_du3[i].multiplyRange(s.w, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.wuuu, start, lessThan));\n            let dD21 = this.d2BasisFunctions_du2[i].multiplyRange(s.wu, start, lessThan).subtract(this.dBasisFunctions_du[i].multiplyRange(s.wuu, start, lessThan));\n            let dD1xD3 = dD3.multiplyRange2(ct.D1x, start, lessThan).subtract(dD1.multiplyRange2(ct.D3x, start, lessThan));\n            let dD1xD21 = dD21.multiplyRange2(ct.D1x, start, lessThan).subtract(dD1.multiplyRange2(ct.D21x, start, lessThan));\n            let dD1xD2 = dD2.multiplyRange2(ct.D1x, start, lessThan).subtract(dD1.multiplyRange2(ct.D2x, start, lessThan));\n            let dD1dotD1 = dD1.multiplyRange2(ct.D1y, start, lessThan).multiplyByScalar(2);\n            let dD1dotD2 = dD1.multiplyRange2(ct.D2y, start, lessThan).add(dD2.multiplyRange2(ct.D1y, start, lessThan));\n            let t1a = dD1xD3.multiplyRange2(D1dotD1, start, lessThan);\n            let t1b = dD1dotD1.multiplyRange2(D1xD3, start, lessThan);\n            let t1 = t1a.add(t1b).multiplyRange2(s.w, start, lessThan);\n            let t2a = dD1xD21.multiplyRange2(D1dotD1, start, lessThan);\n            let t2b = dD1dotD1.multiplyRange2(D1xD21, start, lessThan);\n            let t2 = t2a.add(t2b).multiplyRange2(s.w, start, lessThan);\n            let t3a = dD1xD2.multiplyRange2(D1dotD1, start, lessThan);\n            let t3b = dD1dotD1.multiplyRange2(D1xD2, start, lessThan);\n            let t3 = t3a.add(t3b).multiplyRange2(s.wu, start, lessThan).multiplyByScalar(2);\n            let t4a = dD1xD2.multiplyRange2(D1dotD2, start, lessThan);\n            let t4b = dD1dotD2.multiplyRange2(D1xD2, start, lessThan);\n            let t4 = t4a.add(t4b).multiplyRange2(s.w, start, lessThan).multiplyByScalar(-3);\n            dgy.push(t1.add(t2).add(t3).add(t4));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let dD1x = this.basisFunctions[i].multiplyRange(s.xu, start, lessThan).subtract(this.dBasisFunctions_du[i].multiplyRange(s.x, start, lessThan));\n            let dD1y = this.basisFunctions[i].multiplyRange(s.yu, start, lessThan).subtract(this.dBasisFunctions_du[i].multiplyRange(s.y, start, lessThan));\n            let dD2x = this.basisFunctions[i].multiplyRange(s.xuu, start, lessThan).subtract(this.d2BasisFunctions_du2[i].multiplyRange(s.x, start, lessThan));\n            let dD2y = this.basisFunctions[i].multiplyRange(s.yuu, start, lessThan).subtract(this.d2BasisFunctions_du2[i].multiplyRange(s.y, start, lessThan));\n            let dD3x = this.basisFunctions[i].multiplyRange(s.xuuu, start, lessThan).subtract(this.d3BasisFunctions_du3[i].multiplyRange(s.x, start, lessThan));\n            let dD3y = this.basisFunctions[i].multiplyRange(s.yuuu, start, lessThan).subtract(this.d3BasisFunctions_du3[i].multiplyRange(s.y, start, lessThan));\n            let dD21x = this.dBasisFunctions_du[i].multiplyRange(s.xuu, start, lessThan).subtract(this.d2BasisFunctions_du2[i].multiplyRange(s.xu, start, lessThan));\n            let dD21y = this.dBasisFunctions_du[i].multiplyRange(s.yuu, start, lessThan).subtract(this.d2BasisFunctions_du2[i].multiplyRange(s.yu, start, lessThan));\n            let dD1xD3 = dD1x.multiplyRange2(ct.D3y, start, lessThan).subtract(dD1y.multiplyRange2(ct.D3x, start, lessThan)).add(dD3y.multiplyRange2(ct.D1x, start, lessThan).subtract(dD3x.multiplyRange2(ct.D1y, start, lessThan)));\n            let dD1xD21 = dD1x.multiplyRange2(ct.D21y, start, lessThan).subtract(dD1y.multiplyRange2(ct.D21x, start, lessThan)).add(dD21y.multiplyRange2(ct.D1x, start, lessThan).subtract(dD21x.multiplyRange2(ct.D1y, start, lessThan)));\n            let dD1xD2 = dD1x.multiplyRange2(ct.D2y, start, lessThan).subtract(dD1y.multiplyRange2(ct.D2x, start, lessThan)).add(dD2y.multiplyRange2(ct.D1x, start, lessThan).subtract(dD2x.multiplyRange2(ct.D1y, start, lessThan)));\n            let dD1dotD1 = (dD1x.multiplyRange2(ct.D1x, start, lessThan).add(dD1y.multiplyRange2(ct.D1y, start, lessThan)).multiplyByScalar(2));\n            let dD1dotD2 = dD1x.multiplyRange2(ct.D2x, start, lessThan).add(dD2x.multiplyRange2(ct.D1x, start, lessThan)).add(dD1y.multiplyRange2(ct.D2y, start, lessThan).add(dD2y.multiplyRange2(ct.D1y, start, lessThan)));\n            let t1a = dD1xD3.multiplyRange2(D1dotD1, start, lessThan).multiplyRange2(s.w, start, lessThan);\n            let t1b = dD1dotD1.multiplyRange2(D1xD3, start, lessThan).multiplyRange2(s.w, start, lessThan);\n            let t1c = this.basisFunctions[i].multiplyRange(D1xD3, start, lessThan).multiplyRange2(D1dotD1, start, lessThan);\n            let t1 = t1a.add(t1b).add(t1c);\n            let t2a = dD1xD21.multiplyRange2(D1dotD1, start, lessThan).multiplyRange2(s.w, start, lessThan);\n            let t2b = dD1dotD1.multiplyRange2(D1xD21, start, lessThan).multiplyRange2(s.w, start, lessThan);\n            let t2c = this.basisFunctions[i].multiplyRange(D1xD21, start, lessThan).multiplyRange2(D1dotD1, start, lessThan);\n            let t2 = t2a.add(t2b).add(t2c);\n            let t3a = dD1xD2.multiplyRange2(D1dotD1, start, lessThan).multiplyRange2(s.wu, start, lessThan);\n            let t3b = dD1dotD1.multiplyRange2(D1xD2, start, lessThan).multiplyRange2(s.wu, start, lessThan);\n            let t3c = this.dBasisFunctions_du[i].multiplyRange(D1xD2, start, lessThan).multiplyRange2(D1dotD1, start, lessThan);\n            let t3 = (t3a.add(t3b).add(t3c)).multiplyByScalar(2);\n            let t4a = dD1xD2.multiplyRange2(D1dotD2, start, lessThan).multiplyRange2(s.w, start, lessThan);\n            let t4b = dD1dotD2.multiplyRange2(D1xD2, start, lessThan).multiplyRange2(s.w, start, lessThan);\n            let t4c = this.basisFunctions[i].multiplyRange(D1xD2, start, lessThan).multiplyRange2(D1dotD2, start, lessThan);\n            let t4 = (t4a.add(t4b).add(t4c)).multiplyByScalar(-3);\n            dgw.push(t1.add(t2).add(t3).add(t4));\n        }\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 3 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let cpw = dgw[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (9 * degree - 5);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (9 * degree - 5);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, 2 * controlPointsLength + i, cpw[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints_gradient(s, constraintsSign, inactiveConstraints) {\n        let dgx = [];\n        let dgy = [];\n        let dgw = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1 = (this.dBasisFunctions_du[i].multiplyRange(s.yuu, start, lessThan).subtract(this.d2BasisFunctions_du2[i].multiplyRange(s.yu, start, lessThan))).multiplyRange2(s.w, start, lessThan);\n            let t2 = (this.basisFunctions[i].multiplyRange(s.yuu, start, lessThan).subtract(this.d2BasisFunctions_du2[i].multiplyRange(s.y, start, lessThan))).multiplyRange2(s.wu, start, lessThan);\n            let t3 = (this.dBasisFunctions_du[i].multiplyRange(s.y, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.yu, start, lessThan))).multiplyRange2(s.wuu, start, lessThan);\n            dgx.push(t1.subtract(t2).subtract(t3));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1 = (this.d2BasisFunctions_du2[i].multiplyRange(s.xu, start, lessThan).subtract(this.dBasisFunctions_du[i].multiplyRange(s.xuu, start, lessThan))).multiplyRange2(s.w, start, lessThan);\n            let t2 = (this.d2BasisFunctions_du2[i].multiplyRange(s.x, start, lessThan).subtract(this.basisFunctions[i].multiplyRange(s.xuu, start, lessThan))).multiplyRange2(s.wu, start, lessThan);\n            let t3 = (this.basisFunctions[i].multiplyRange(s.xu, start, lessThan).subtract(this.dBasisFunctions_du[i].multiplyRange(s.x, start, lessThan))).multiplyRange2(s.wuu, start, lessThan);\n            dgy.push(t1.subtract(t2).subtract(t3));\n        }\n        const h1 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xu, s.yu, s.xuu, s.yuu);\n        const h2 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.x, s.y, s.xuu, s.yuu);\n        const h3 = (0, BernsteinDecompositionR1toR1_1.determinant2by2)(s.xu, s.yu, s.x, s.y);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let t1 = this.basisFunctions[i].multiplyRange(h1, start, lessThan);\n            let t2 = this.dBasisFunctions_du[i].multiplyRange(h2, start, lessThan);\n            let t3 = this.d2BasisFunctions_du2[i].multiplyRange(h3, start, lessThan);\n            dgw.push(t1.subtract(t2).subtract(t3));\n        }\n        const totalNumberOfConstraints = this.inflectionConstraintsSign.length;\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 3 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            const cpx = dgx[i].flattenControlPointsArray();\n            const cpy = dgy[i].flattenControlPointsArray();\n            const cpw = dgw[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (3 * degree - 2);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (3 * degree - 2);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, 2 * controlPointsLength + i, cpw[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    computeBasisFunctionsDerivatives() {\n        const n = this._spline.controlPoints.length;\n        //???????\n        //this._numberOfIndependentVariables = n * 2\n        let diracControlPoints = (0, MathVectorBasicOperations_1.zeroVector)(n);\n        this.basisFunctions = [];\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        for (let i = 0; i < n; i += 1) {\n            diracControlPoints[i] = 1;\n            let basisFunction = this.bSplineR1toR1Factory(diracControlPoints.slice(), this._spline.knots.slice());\n            let dBasisFunction_du = basisFunction.derivative();\n            let d2BasisFunction_du2 = dBasisFunction_du.derivative();\n            let d3BasisFunction_du3 = d2BasisFunction_du2.derivative();\n            this.basisFunctions.push(basisFunction.bernsteinDecomposition());\n            this.dBasisFunctions_du.push(dBasisFunction_du.bernsteinDecomposition());\n            this.d2BasisFunctions_du2.push(d2BasisFunction_du2.bernsteinDecomposition());\n            this.d3BasisFunctions_du3.push(d3BasisFunction_du3.bernsteinDecomposition());\n            diracControlPoints[i] = 0;\n        }\n    }\n}\nexports.OpRationalBSplineR1toR2 = OpRationalBSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Optimizer = void 0;\nconst TrustRegionSubproblem_1 = require(\"./TrustRegionSubproblem\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst SymmetricMatrix_1 = require(\"../linearAlgebra/SymmetricMatrix\");\nconst CholeskyDecomposition_1 = require(\"../linearAlgebra/CholeskyDecomposition\");\nclass Optimizer {\n    constructor(o) {\n        this.o = o;\n        this.success = false;\n        if (this.o.f.length !== this.o.gradient_f.shape[0]) {\n            console.log(\"Problem about f length and gradient_f shape 0 is in the Optimizer Constructor\");\n            console.log(this.o.f);\n            console.log(this.o.gradient_f);\n        }\n    }\n    optimize_using_trust_region(epsilon = 10e-8, maxTrustRadius = 10, maxNumSteps = 800) {\n        this.success = false;\n        // Bibliographic reference: Numerical Optimization, second edition, Jorge Nocedal and Stephen J. Wright, p. 69\n        let numSteps = 0;\n        let t = this.o.numberOfConstraints / this.o.f0;\n        //let t = 10 / this.o.f0\n        let trustRadius = 0.1;\n        let rho;\n        const eta = 0.1; // [0, 1/4)\n        const mu = 10; // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 569\n        let counter = 0;\n        let numStepsX = 0;\n        //while (this.o.numberOfConstraints / t > epsilon) {\n        while (10 / t > epsilon) {\n            //console.log(t)\n            while (true) {\n                counter += 1;\n                numSteps += 1;\n                if (this.o.f.length !== this.o.gradient_f.shape[0]) {\n                    console.log(\"Problem about f length and gradient_f shape 0 is in the function optimize_using_trust_region\");\n                }\n                let b = this.barrier(this.o.f, this.o.gradient_f, this.o.hessian_f);\n                let gradient = (0, MathVectorBasicOperations_1.saxpy2)(t, this.o.gradient_f0, b.gradient);\n                let hessian = b.hessian.plusSymmetricMatrixMultipliedByValue(this.o.hessian_f0, t);\n                let trustRegionSubproblem = new TrustRegionSubproblem_1.TrustRegionSubproblem(gradient, hessian);\n                let tr = trustRegionSubproblem.solve(trustRadius);\n                let fStep = this.o.fStep(tr.step);\n                let numSteps2 = 0;\n                while (Math.max.apply(null, fStep) >= 0) {\n                    numSteps2 += 1;\n                    trustRadius *= 0.25;\n                    tr = trustRegionSubproblem.solve(trustRadius);\n                    fStep = this.o.fStep(tr.step);\n                    if (numSteps2 > 100) {\n                        throw new Error(\"maxSteps2 > 100\");\n                    }\n                }\n                let barrierValueStep = this.barrierValue(fStep);\n                let actualReduction = t * (this.o.f0 - this.o.f0Step(tr.step)) + (b.value - barrierValueStep);\n                let predictedReduction = -(0, MathVectorBasicOperations_1.dotProduct)(gradient, tr.step) - 0.5 * hessian.quadraticForm(tr.step);\n                rho = actualReduction / predictedReduction;\n                if (rho < 0.25) {\n                    trustRadius *= 0.25;\n                }\n                else if (rho > 0.75 && tr.hitsBoundary) {\n                    trustRadius = Math.min(2 * trustRadius, maxTrustRadius);\n                }\n                if (rho > eta) {\n                    this.o.step(tr.step);\n                    numStepsX += 1;\n                }\n                if (numSteps > maxNumSteps) {\n                    return;\n                }\n                if ((new CholeskyDecomposition_1.CholeskyDecomposition(hessian).success)) {\n                    let newtonDecrementSquared = -(0, MathVectorBasicOperations_1.dotProduct)(gradient, tr.step);\n                    if (newtonDecrementSquared < 0) {\n                        throw new Error(\"newtonDecrementSquared is smaller than zero\");\n                    }\n                    if (newtonDecrementSquared < epsilon) {\n                        break;\n                    }\n                }\n                if (trustRadius < 10e-18) {\n                    console.log(b);\n                    throw new Error(\"trust Radius < 10e-18\");\n                }\n            }\n            if (trustRadius > 0.001) {\n                t *= mu;\n            }\n            else {\n                t *= 100 * mu;\n                //console.log(\"100*mu\")\n            }\n        }\n        this.success = true;\n        if (numSteps > 100) {\n            console.log(\"numSteps: \" + numSteps);\n            console.log(\"t: \" + t);\n            console.log(\"trustRadius: \" + trustRadius);\n        }\n        //console.log(counter)\n    }\n    optimize_using_line_search(epsilon = 10e-6, maxNumSteps = 300) {\n        // Bibliographic reference: Numerical Optimization, second edition, Jorge Nocedal and Stephen J. Wright, p. 69\n        let numSteps = 0;\n        let t = this.o.numberOfConstraints / this.o.f0;\n        let rho;\n        const eta = 0.1; // [0, 1/4)\n        const mu = 10; // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 569\n        while (this.o.numberOfConstraints / t > epsilon) {\n            while (true) {\n                numSteps += 1;\n                const b = this.barrier(this.o.f, this.o.gradient_f, this.o.hessian_f);\n                const gradient = (0, MathVectorBasicOperations_1.saxpy2)(t, this.o.gradient_f0, b.gradient);\n                const hessian = b.hessian.plusSymmetricMatrixMultipliedByValue(this.o.hessian_f0, t);\n                const newtonStep = this.computeNewtonStep(gradient, hessian);\n                const stepRatio = this.backtrackingLineSearch(t, newtonStep, this.o.f0, b.value, this.o.gradient_f0, b.gradient);\n                const step = (0, MathVectorBasicOperations_1.multiplyVectorByScalar)(newtonStep, stepRatio);\n                this.o.step(step);\n                if (numSteps > maxNumSteps) {\n                    console.log(\"numSteps > maxNumSteps\");\n                    return;\n                }\n                let newtonDecrementSquared = this.newtonDecrementSquared(step, t, this.o.gradient_f0, b.gradient);\n                if (newtonDecrementSquared < 0) {\n                    throw new Error(\"newtonDecrementSquared is smaller than zero\");\n                }\n                if (newtonDecrementSquared < epsilon) {\n                    break;\n                }\n            }\n            t *= mu;\n        }\n    }\n    newtonDecrementSquared(newtonStep, t, gradient_f0, barrierGradient) {\n        return -(0, MathVectorBasicOperations_1.dotProduct)((0, MathVectorBasicOperations_1.saxpy2)(t, gradient_f0, barrierGradient), newtonStep);\n    }\n    barrierValue(f) {\n        let result = 0;\n        const n = f.length;\n        for (let i = 0; i < n; i += 1) {\n            result -= Math.log(-f[i]);\n        }\n        return result;\n    }\n    barrierGradient(f, gradient_f) {\n        let result = (0, MathVectorBasicOperations_1.zeroVector)(gradient_f.shape[1]);\n        const n = f.length;\n        const m = gradient_f.shape[1];\n        if (n !== gradient_f.shape[0]) {\n            throw new Error(\"barrierGradient f and gradient_f dimensions do not match\");\n        }\n        for (let i = 0; i < n; i += 1) {\n            for (let j = 0; j < m; j += 1) {\n                if (f[i] === 0) {\n                    throw new Error(\"barrierGradient makes a division by zero\");\n                }\n                result[j] += -gradient_f.get(i, j) / f[i];\n            }\n        }\n        return result;\n    }\n    barrierHessian(f, gradient_f, hessian_f) {\n        // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 564\n        const m = gradient_f.shape[0];\n        const n = gradient_f.shape[1];\n        let result = new SymmetricMatrix_1.SymmetricMatrix(n);\n        // barrier hessian first term\n        for (let i = 0; i < m; i += 1) {\n            for (let k = 0; k < n; k += 1) {\n                for (let l = 0; l <= k; l += 1) {\n                    result.addAt(k, l, gradient_f.get(i, k) * gradient_f.get(i, l) / (f[i] * f[i]));\n                }\n            }\n        }\n        // barrier hessian second term\n        if (hessian_f) {\n            for (let i = 0; i < n; i += 1) {\n                for (let j = 0; j <= i; j += 1) {\n                    for (let k = 0; k < f.length; k += 1) {\n                        if (hessian_f.length != f.length) {\n                            console.log(\"f.length: \" + f.length);\n                            console.log(\"hessian_f.length: \" + hessian_f.length);\n                            throw new Error(\"hessian_f.length != f.length\");\n                        }\n                        result.addAt(i, j, -hessian_f[k].get(i, j) / f[k]);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    barrier(f, gradient_f, hessian_f) {\n        return { value: this.barrierValue(f),\n            gradient: this.barrierGradient(f, gradient_f),\n            hessian: this.barrierHessian(f, gradient_f, hessian_f)\n        };\n    }\n    backtrackingLineSearch(t, newtonStep, f0, barrierValue, gradient_f0, barrierGradient) {\n        const alpha = 0.2;\n        const beta = 0.5;\n        let result = 1;\n        let step = newtonStep.slice();\n        while (Math.max(...this.o.fStep(step)) > 0) {\n            result *= beta;\n            step = (0, MathVectorBasicOperations_1.multiplyVectorByScalar)(newtonStep, result);\n        }\n        while (t * this.o.f0Step(step) + this.barrierValue(this.o.fStep(step)) > t * f0 + barrierValue\n            + alpha * result * (0, MathVectorBasicOperations_1.dotProduct)((0, MathVectorBasicOperations_1.addTwoVectors)((0, MathVectorBasicOperations_1.multiplyVectorByScalar)(gradient_f0, t), barrierGradient), newtonStep)) {\n            result *= beta;\n            step = (0, MathVectorBasicOperations_1.multiplyVectorByScalar)(newtonStep, result);\n        }\n        return result;\n    }\n    computeNewtonStep(gradient, hessian) {\n        let choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessian);\n        if (choleskyDecomposition.success === false) {\n            console.log(\"choleskyDecomposition failed\");\n        }\n        return choleskyDecomposition.solve((0, MathVectorBasicOperations_1.multiplyVectorByScalar)(gradient, -1));\n    }\n}\nexports.Optimizer = Optimizer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBoundariesIntersections = exports.gershgorin_bounds = exports.frobeniusNorm = exports.TrustRegionSubproblem = void 0;\nconst SquareMatrix_1 = require(\"../linearAlgebra/SquareMatrix\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst CholeskyDecomposition_1 = require(\"../linearAlgebra/CholeskyDecomposition\");\n// Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 187\n// note: lambda is never negative\nvar lambdaRange;\n(function (lambdaRange) {\n    lambdaRange[lambdaRange[\"N\"] = 0] = \"N\";\n    lambdaRange[lambdaRange[\"L\"] = 1] = \"L\";\n    lambdaRange[lambdaRange[\"G\"] = 2] = \"G\";\n    lambdaRange[lambdaRange[\"F\"] = 3] = \"F\";\n})(lambdaRange || (lambdaRange = {}));\n/**\n * A trust region subproblem solver\n */\nclass TrustRegionSubproblem {\n    /**\n     * Create the trust region subproblem solver\n     * @param gradient The gradient of the objective function to minimize\n     * @param hessian The hessian of the objective function to minimize\n     * @param k_easy Optional value in the range (0, 1)\n     * @param k_hard Optional value in the range (0, 1)\n     */\n    constructor(gradient, hessian, k_easy = 0.1, k_hard = 0.2) {\n        this.gradient = gradient;\n        this.hessian = hessian;\n        this.k_easy = k_easy;\n        this.k_hard = k_hard;\n        this.CLOSE_TO_ZERO = 10e-8;\n        this.numberOfIterations = 0;\n        this.lambda = { current: 0, lowerBound: 0, upperBound: 0 };\n        this.hitsBoundary = true;\n        this.step = [];\n        this.stepSquaredNorm = 0;\n        this.stepNorm = 0;\n        this.range = lambdaRange.F;\n        this.lambdaPlus = 0;\n        this.hardCase = false;\n        this.gNorm = (0, MathVectorBasicOperations_1.norm)(this.gradient);\n        if ((0, MathVectorBasicOperations_1.containsNaN)(gradient)) {\n            throw new Error(\"The gradient parameter passed to the TrustRegionSubproblem constructor contains NaN\");\n        }\n        if (hessian.containsNaN()) {\n            throw new Error(\"The hessian parameter passed to the TrustRegionSubproblem to constructor contains NaN\");\n        }\n        this.cauchyPoint = (0, MathVectorBasicOperations_1.zeroVector)(this.gradient.length);\n    }\n    /**\n     * Find the nearly exact trust region subproblem minimizer\n     * @param trustRegionRadius The trust region radius\n     * @returns The vector .step and the boolean .hitsBoundary\n     */\n    solve(trustRegionRadius) {\n        // Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 193\n        // see also the list of errata: ftp://ftp.numerical.rl.ac.uk/pub/trbook/trbook-errata.pdf for Algorithm 7.3.4 Step 1a\n        this.cauchyPoint = this.computeCauchyPoint(trustRegionRadius);\n        this.lambda = this.initialLambdas(trustRegionRadius);\n        this.numberOfIterations = 0;\n        const maxNumberOfIterations = 300;\n        while (true) {\n            this.numberOfIterations += 1;\n            // step 1.\n            let hessianPlusLambda = this.hessian.addValueOnDiagonal(this.lambda.current);\n            let choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n            //We have found the exact lambda, however the hessian is indefinite\n            //The idea is then to find an approximate solution increasing the lambda value by EPSILON\n            if (this.lambda.upperBound === this.lambda.lowerBound && !choleskyDecomposition.success) {\n                const EPSILON = 10e-6;\n                this.lambda.upperBound += EPSILON;\n                this.lambda.current += EPSILON;\n                hessianPlusLambda = this.hessian.addValueOnDiagonal(this.lambda.current);\n                choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n                this.range = lambdaRange.G;\n            }\n            // step 1a.\n            this.update_step_and_range(trustRegionRadius, choleskyDecomposition);\n            if (this.interiorConvergence()) {\n                break;\n            }\n            // step 2.\n            this.update_lower_and_upper_bounds();\n            // step 3.\n            this.update_lambda_lambdaPlus_lowerBound_and_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition);\n            // step 4.\n            if (this.check_for_termination_and_update_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition)) {\n                break;\n            }\n            // step 5.\n            this.update_lambda();\n            if (this.numberOfIterations > maxNumberOfIterations) {\n                console.log(\"gradient: \" + this.gradient);\n                console.log(\"hessian: \" + this.hessian.getData());\n                console.log(\"trust region radius: \" + trustRegionRadius);\n                throw new Error(\"Trust region subproblem maximum number of step exceeded\");\n            }\n        }\n        //console.log(this.numberOfIterations)\n        return {\n            step: this.step,\n            hitsBoundary: this.hitsBoundary,\n            hardCase: this.hardCase\n        };\n    }\n    /**\n     * An interior solution with a zero Lagrangian multiplier implies interior convergence\n     */\n    interiorConvergence() {\n        // A range G corresponds to a step smaller than the trust region radius\n        if (this.lambda.current === 0 && this.range === lambdaRange.G) {\n            this.hitsBoundary = false;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Updates the lambdaRange set. Updates the step if the factorization succeeded.\n     * @param trustRegionRadius Trust region radius\n     * @param choleskyDecomposition Cholesky decomposition\n     */\n    update_step_and_range(trustRegionRadius, choleskyDecomposition) {\n        if (choleskyDecomposition.success) {\n            this.step = choleskyDecomposition.solve((0, MathVectorBasicOperations_1.multiplyVectorByScalar)(this.gradient, -1));\n            this.stepSquaredNorm = (0, MathVectorBasicOperations_1.squaredNorm)(this.step);\n            this.stepNorm = Math.sqrt(this.stepSquaredNorm);\n            if (this.stepNorm < trustRegionRadius) {\n                this.range = lambdaRange.G;\n            }\n            else {\n                this.range = lambdaRange.L; // once a Newton iterate falls into L it stays there\n            }\n        }\n        else {\n            this.range = lambdaRange.N;\n        }\n    }\n    /**\n     * Update lambda.upperBound or lambda.lowerBound\n     */\n    update_lower_and_upper_bounds() {\n        if (this.range === lambdaRange.G) {\n            this.lambda.upperBound = this.lambda.current;\n        }\n        else {\n            this.lambda.lowerBound = this.lambda.current;\n        }\n    }\n    /**\n     * Update lambdaPlus, lambda.lowerBound, lambda.current and step\n     * @param trustRegionRadius Trust region radius\n     * @param hessianPlusLambda Hessian + lambda.current * I\n     * @param choleskyDecomposition The Cholesky Decomposition of Hessian + lambda.current * I\n     */\n    update_lambda_lambdaPlus_lowerBound_and_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition) {\n        // Step 3. If lambda in F\n        if (this.range === lambdaRange.L || this.range === lambdaRange.G) {\n            // Step 3a. Solve Lw = step and set lambdaPlus (algorithm 7.3.1)\n            let w = solveLowerTriangular(choleskyDecomposition.g, this.step);\n            let wSquaredNorm = (0, MathVectorBasicOperations_1.squaredNorm)(w);\n            this.lambdaPlus = this.lambda.current + (this.stepNorm / trustRegionRadius - 1) * (this.stepSquaredNorm / wSquaredNorm);\n            // Step 3b. If lambda in G\n            if (this.range === lambdaRange.G) {\n                // i. Use the LINPACK method to find a unit vector u to make <u, H(lambda), u> small.\n                let s_min = estimateSmallestSingularValue(choleskyDecomposition.g);\n                // ii. Replace lambda.lowerBound by max [lambda_lb, lambda - <u, H(lambda), u>].\n                this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambda.current - Math.pow(s_min.value, 2));\n                // iii. Find the root alpha of the equation || step + alpha u || = trustRegionRadius which makes\n                // the model q(step + alpha u) smallest and replace step by step + alpha u\n                let intersection = getBoundariesIntersections(this.step, s_min.vector, trustRegionRadius);\n                let t;\n                if (Math.abs(intersection.tmin) < Math.abs(intersection.tmax)) {\n                    t = intersection.tmin;\n                }\n                else {\n                    t = intersection.tmax;\n                }\n                (0, MathVectorBasicOperations_1.saxpy)(t, s_min.vector, this.step);\n                this.stepSquaredNorm = (0, MathVectorBasicOperations_1.squaredNorm)(this.step);\n                this.stepNorm = Math.sqrt(this.stepSquaredNorm);\n            }\n        }\n        else {\n            // Step 3c. Use the partial factorization to find delta and v such that (H(lambda) + delta e_k e_k^T) v = 0\n            let sls = singularLeadingSubmatrix(hessianPlusLambda, choleskyDecomposition.g, choleskyDecomposition.firstNonPositiveDefiniteLeadingSubmatrixSize);\n            // Step 3d. Replace lambda.lb by max [ lambda_lb, lambda_current + delta / || v ||^2 ]\n            let vSquaredNorm = (0, MathVectorBasicOperations_1.squaredNorm)(sls.vector);\n            this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambda.current + sls.delta / vSquaredNorm);\n        }\n    }\n    /**\n     * Check for termination\n     * @param trustRegionRadius Trust region radius\n     * @param hessianPlusLambda Hessian + lambda.current * I\n     * @param choleskyDecomposition The CholeskyDecomposition of Hessian + lambda.current * I\n     */\n    check_for_termination_and_update_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition) {\n        let terminate = false;\n        // Algorithm 7.3.5, Step 1. If lambda is in F and | ||s(lambda)|| - trustRegionRadius | <= k_easy * trustRegionRadius\n        if ((this.range === lambdaRange.L || this.range === lambdaRange.G) && Math.abs(this.stepNorm - trustRegionRadius) <= this.k_easy * trustRegionRadius) {\n            // Added test to make sure that the result is better than the Cauchy point\n            let evalResult = (0, MathVectorBasicOperations_1.dotProduct)(this.gradient, this.step) + 0.5 * this.hessian.quadraticForm(this.step);\n            let evalCauchy = (0, MathVectorBasicOperations_1.dotProduct)(this.gradient, this.cauchyPoint) + 0.5 * this.hessian.quadraticForm(this.cauchyPoint);\n            if (evalResult > evalCauchy) {\n                return false;\n            }\n            else {\n                // stop with s = s(lambda)\n                this.hitsBoundary = true;\n                terminate = true;\n            }\n        }\n        if (this.range === lambdaRange.G) {\n            // Algorithm 7.3.5, Step 2. If lambda = 0 in G\n            if (this.lambda.current === 0) {\n                this.hitsBoundary = false; // since the Lagrange Multiplier is zero\n                terminate = true;\n                return terminate;\n            }\n            // Algorithm 7.3.5, Step 3. If lambda is in G and the LINPACK method gives u and alpha such that\n            // alpha^2 <u, H(lambda), u> <= k_hard ( <s(lambda), H(lambda) * s(lambda) + lambda * trustRegionRadius^2 >)\n            let s_min = estimateSmallestSingularValue(choleskyDecomposition.g);\n            let intersection = getBoundariesIntersections(this.step, s_min.vector, trustRegionRadius);\n            let t_abs_max;\n            // To do : explain better why > instead of <\n            // relative_error is smaller for <\n            // it seems that we need the worst case to make sure the result is a better solution\n            // than the Cauchy point\n            if (Math.abs(intersection.tmin) > Math.abs(intersection.tmax)) {\n                t_abs_max = intersection.tmin;\n            }\n            else {\n                t_abs_max = intersection.tmax;\n            }\n            let quadraticTerm = hessianPlusLambda.quadraticForm(this.step);\n            let relative_error = Math.pow(t_abs_max * s_min.value, 2) / (quadraticTerm + this.lambda.current * Math.pow(trustRegionRadius, 2));\n            if (relative_error <= this.k_hard) {\n                //saxpy(t_abs_min, s_min.vector, this.step) done at step 3b iii.\n                this.hitsBoundary = true;\n                this.hardCase = true;\n                terminate = true;\n            }\n        }\n        return terminate;\n    }\n    /**\n     * Update lambda.current\n     */\n    update_lambda() {\n        //step 5.\n        if (this.range === lambdaRange.L && this.gNorm !== 0) {\n            this.lambda.current = this.lambdaPlus;\n        }\n        else if (this.range === lambdaRange.G) {\n            let hessianPlusLambda = this.hessian.clone();\n            hessianPlusLambda.addValueOnDiagonal(this.lambdaPlus);\n            let choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n            // If the factorization succeeds, then lambdaPlus is in L. Otherwise, lambdaPlus is in N\n            if (choleskyDecomposition.success) {\n                this.lambda.current = this.lambdaPlus;\n            }\n            else {\n                this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambdaPlus);\n                // Check lambda.lb for interior convergence ???\n                this.lambda.current = updateLambda_using_equation_7_3_14(this.lambda.lowerBound, this.lambda.upperBound);\n            }\n        }\n        else {\n            this.lambda.current = updateLambda_using_equation_7_3_14(this.lambda.lowerBound, this.lambda.upperBound);\n        }\n    }\n    /**\n     * Returns the minimizer along the steepest descent (-gradient) direction subject to trust-region bound.\n     * Note: If the gradient is a zero vector then the function returns a zero vector\n     * @param trustRegionRadius The trust region radius\n     * @return The minimizer vector deta x\n     */\n    computeCauchyPoint(trustRegionRadius) {\n        // Bibliographic referece: Numerical Optimizatoin, second edition, Nocedal and Wright, p. 71-72\n        const gHg = this.hessian.quadraticForm(this.gradient);\n        const gNorm = (0, MathVectorBasicOperations_1.norm)(this.gradient);\n        // return a zero step if the gradient is zero\n        if (gNorm === 0) {\n            return (0, MathVectorBasicOperations_1.zeroVector)(this.gradient.length);\n        }\n        let result = (0, MathVectorBasicOperations_1.multiplyVectorByScalar)(this.gradient, -trustRegionRadius / gNorm);\n        if (gHg <= 0) {\n            return result;\n        }\n        let tau = Math.pow(gNorm, 3) / trustRegionRadius / gHg;\n        if (tau < 1) {\n            return (0, MathVectorBasicOperations_1.multiplyVectorByScalar)(result, tau);\n        }\n        return result;\n    }\n    /**\n     * Return an initial value, an upper bound and a lower bound for lambda.\n     * @param trustRegionRadius The trust region radius\n     * @return .current (lambda intial value) .lb (lower bound) and .ub (upper bound)\n     */\n    initialLambdas(trustRegionRadius) {\n        // Bibliographic reference : Trust-Region Methods, Conn, Gould and Toint p. 192\n        let gershgorin = gershgorin_bounds(this.hessian);\n        let hessianFrobeniusNorm = frobeniusNorm(this.hessian);\n        let hessianInfiniteNorm = 0;\n        let minHessianDiagonal = this.hessian.get(0, 0);\n        for (let i = 0; i < this.hessian.shape[0]; i += 1) {\n            let tempInfiniteNorm = 0;\n            for (let j = 0; j < this.hessian.shape[0]; j += 1) {\n                tempInfiniteNorm += Math.abs(this.hessian.get(i, j));\n            }\n            hessianInfiniteNorm = Math.max(hessianInfiniteNorm, tempInfiniteNorm);\n            minHessianDiagonal = Math.min(minHessianDiagonal, this.hessian.get(i, i));\n        }\n        let lowerBound = Math.max(0, Math.max(-minHessianDiagonal, (0, MathVectorBasicOperations_1.norm)(this.gradient) / trustRegionRadius - Math.min(gershgorin.upperBound, Math.min(hessianFrobeniusNorm, hessianInfiniteNorm))));\n        let upperBound = Math.max(0, (0, MathVectorBasicOperations_1.norm)(this.gradient) / trustRegionRadius + Math.min(-gershgorin.lowerBound, Math.min(hessianFrobeniusNorm, hessianInfiniteNorm)));\n        let lambda_initial;\n        if (lowerBound === 0) {\n            lambda_initial = 0;\n        }\n        else {\n            lambda_initial = updateLambda_using_equation_7_3_14(lowerBound, upperBound);\n        }\n        return {\n            current: lambda_initial,\n            lowerBound: lowerBound,\n            upperBound: upperBound\n        };\n    }\n}\nexports.TrustRegionSubproblem = TrustRegionSubproblem;\n/**\n *\n * @param A\n * @param L\n * @param k\n * @return dela, vector\n * @throws If k < 0\n */\nfunction singularLeadingSubmatrix(A, L, k) {\n    if (k < 0) {\n        throw new Error('k should not be a negative value');\n    }\n    let delta = 0;\n    let l = new SquareMatrix_1.SquareMatrix(k);\n    let v = [];\n    let u = (0, MathVectorBasicOperations_1.zeroVector)(k);\n    for (let j = 0; j < k - 1; j += 1) {\n        delta += Math.pow(L.get(k - 1, j), 2);\n    }\n    delta -= A.get(k - 1, k - 1);\n    for (let i = 0; i < k - 1; i += 1) {\n        for (let j = 0; j <= i; j += 1) {\n            l.set(i, j, L.get(i, j));\n        }\n        u[i] = L.get(k - 1, i);\n    }\n    v = (0, MathVectorBasicOperations_1.zeroVector)(A.shape[0]);\n    v[k - 1] = 1;\n    if (k !== 1) {\n        let vtemp = solveLowerTriangular(l, u);\n        for (let i = 0; i < k - 1; i += 1) {\n            v[i] = vtemp[i];\n        }\n    }\n    return {\n        delta: delta,\n        vector: v\n    };\n}\n/**\n * Estimate the smallest singular value\n * @param lowerTriangular\n */\nfunction estimateSmallestSingularValue(lowerTriangular) {\n    // Bibliographic reference :  Golub, G. H., Van Loan, C. F. (2013), \"Matrix computations\". Forth Edition. JHU press. pp. 140-142.\n    // Web reference: https://github.com/scipy/scipy/blob/master/scipy/optimize/_trustregion_exact.py\n    const n = lowerTriangular.shape[0];\n    let p = (0, MathVectorBasicOperations_1.zeroVector)(n);\n    let y = (0, MathVectorBasicOperations_1.zeroVector)(n);\n    let p_plus = [];\n    let p_minus = [];\n    for (let k = 0; k < n; k += 1) {\n        let y_plus = (1 - p[k]) / lowerTriangular.get(k, k);\n        let y_minus = (-1 - p[k]) / lowerTriangular.get(k, k);\n        for (let i = k + 1; i < n; i += 1) {\n            p_plus.push(p[i] + lowerTriangular.get(i, k) * y_plus);\n            p_minus.push(p[i] + lowerTriangular.get(i, k) * y_minus);\n        }\n        if (Math.abs(y_plus) + (0, MathVectorBasicOperations_1.norm1)(p_plus) >= Math.abs(y_minus) + (0, MathVectorBasicOperations_1.norm1)(p_minus)) {\n            y[k] = y_plus;\n            for (let i = k + 1; i < n; i += 1) {\n                p[i] = p_plus[i - k - 1];\n            }\n        }\n        else {\n            y[k] = y_minus;\n            for (let i = k + 1; i < n; i += 1) {\n                p[i] = p_minus[i - k - 1];\n            }\n        }\n    }\n    let v = solveUpperTriangular(lowerTriangular, y);\n    let vNorm = (0, MathVectorBasicOperations_1.norm)(v);\n    let yNorm = (0, MathVectorBasicOperations_1.norm)(y);\n    if (vNorm === 0) {\n        throw new Error(\"divideVectorByScalar division by zero\");\n    }\n    return {\n        value: yNorm / vNorm,\n        vector: (0, MathVectorBasicOperations_1.divideVectorByScalar)(v, vNorm)\n    };\n}\n/**\n * Solve the linear problem upper triangular matrix UT x = y\n * @param lowerTriangular The transpose of the upper triangular matrix\n * @param y The vector y\n */\nfunction solveUpperTriangular(lowerTriangular, y) {\n    let x = y.slice();\n    const n = lowerTriangular.shape[0];\n    // LT x = y\n    for (let i = n - 1; i >= 0; i -= 1) {\n        let sum = x[i];\n        for (let k = i + 1; k < n; k += 1) {\n            sum -= lowerTriangular.get(k, i) * x[k];\n        }\n        x[i] = sum / lowerTriangular.get(i, i);\n    }\n    return x;\n}\n/**\n * Solve the linear problem lower triangular matrix LT x = b\n * @param lowerTriangular The lower triangular matrix\n * @param b The vector b\n */\nfunction solveLowerTriangular(lowerTriangular, b) {\n    if (lowerTriangular.shape[0] !== b.length) {\n        throw new Error('solveLowerTriangular: matrix and vector are not the same sizes');\n    }\n    let x = b.slice();\n    const n = lowerTriangular.shape[0];\n    // L x = b\n    for (let i = 0; i < n; i += 1) {\n        let sum = b[i];\n        for (let k = i - 1; k >= 0; k -= 1) {\n            sum -= lowerTriangular.get(i, k) * x[k];\n        }\n        x[i] = sum / lowerTriangular.get(i, i);\n    }\n    return x;\n}\n/**\n * The frobenius norm\n * @param matrix The matrix\n * @return The square root of the sum of every elements squared\n */\nfunction frobeniusNorm(matrix) {\n    let result = 0;\n    const m = matrix.shape[0];\n    const n = matrix.shape[1];\n    for (let i = 0; i < m; i += 1) {\n        for (let j = 0; j < n; j += 1) {\n            result += Math.pow(matrix.get(i, j), 2);\n        }\n    }\n    result = Math.sqrt(result);\n    return result;\n}\nexports.frobeniusNorm = frobeniusNorm;\n/**\n* Given a symmetric matrix, compute the Gershgorin upper and lower bounds for its eigenvalues\n* @param matrix Symmetric Matrix\n* @return .lb (lower bound) and .ub (upper bound)\n*/\nfunction gershgorin_bounds(matrix) {\n    // Bibliographic Reference : Trust-Region Methods, Conn, Gould and Toint p. 19\n    // Gershgorin Bounds : All eigenvalues of a matrix A lie in the complex plane within the intersection\n    // of n discs centered at a_(i, i) and of radii : sum of a_(i, j) for 1 ≤ i ≤ n and  j != i\n    // When the matrix is symmetric, the eigenvalues are real and the discs become intervals on the real\n    // line\n    const m = matrix.shape[0];\n    const n = matrix.shape[1];\n    let matrixRowSums = [];\n    for (let i = 0; i < m; i += 1) {\n        let rowSum = 0;\n        for (let j = 0; j < n; j += 1) {\n            rowSum += Math.abs(matrix.get(i, j));\n        }\n        matrixRowSums.push(rowSum);\n    }\n    let matrixDiagonal = [];\n    let matrixDiagonalAbsolute = [];\n    for (let i = 0; i < m; i += 1) {\n        matrixDiagonal.push(matrix.get(i, i));\n        matrixDiagonalAbsolute.push(Math.abs(matrix.get(i, i)));\n    }\n    let lb = [];\n    let ub = [];\n    for (let i = 0; i < m; i += 1) {\n        lb.push(matrixDiagonal[i] + matrixDiagonalAbsolute[i] - matrixRowSums[i]);\n        ub.push(matrixDiagonal[i] - matrixDiagonalAbsolute[i] + matrixRowSums[i]);\n    }\n    let lowerBound = Math.min.apply(null, lb);\n    let upperBound = Math.max.apply(null, ub);\n    return {\n        lowerBound: lowerBound,\n        upperBound: upperBound\n    };\n}\nexports.gershgorin_bounds = gershgorin_bounds;\n/**\n * Solve the scalar quadratic equation ||z + t d|| == trust_radius\n * This is like a line-sphere intersection\n * @param z Vector\n * @param d Vector\n * @param trustRegionRadius\n * @returns The two values of t, sorted from low to high\n */\nfunction getBoundariesIntersections(z, d, trustRegionRadius) {\n    if ((0, MathVectorBasicOperations_1.isZeroVector)(d)) {\n        throw new Error(\"In getBoundariesInstersections the d vector cannot be the zero vector\");\n    }\n    const a = (0, MathVectorBasicOperations_1.squaredNorm)(d);\n    const b = 2 * (0, MathVectorBasicOperations_1.dotProduct)(z, d);\n    const c = (0, MathVectorBasicOperations_1.squaredNorm)(z) - trustRegionRadius * trustRegionRadius;\n    const sqrtDiscriminant = Math.sqrt(b * b - 4 * a * c);\n    let sign_b = (0, MathVectorBasicOperations_1.sign)(b);\n    if (sign_b === 0) {\n        sign_b = 1;\n    }\n    const aux = b + sqrtDiscriminant * sign_b;\n    const ta = -aux / (2 * a);\n    const tb = -2 * c / aux;\n    return {\n        tmin: Math.min(ta, tb),\n        tmax: Math.max(ta, tb)\n    };\n}\nexports.getBoundariesIntersections = getBoundariesIntersections;\nfunction updateLambda_using_equation_7_3_14(lowerBound, upperBound, theta = 0.01) {\n    // Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 190\n    return Math.max(Math.sqrt(upperBound * lowerBound), lowerBound + theta * (upperBound - lowerBound));\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toUint16Array = exports.toFloat32Array = void 0;\nfunction toFloat32Array(v) {\n    let result = new Float32Array(v.length);\n    for (let i = 0; i < v.length; i += 1) {\n        result[i] = v[i];\n    }\n    return result;\n}\nexports.toFloat32Array = toFloat32Array;\nfunction toUint16Array(v) {\n    let result = new Uint16Array(v.length);\n    for (let i = 0; i < v.length; i += 1) {\n        result[i] = v[i];\n    }\n    return result;\n}\nexports.toUint16Array = toUint16Array;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseObject3dShadowView = void 0;\nconst mat4_1 = require(\"../webgl/mat4\");\nconst mat3_1 = require(\"../webgl/mat3\");\nconst quat_1 = require(\"../webgl/quat\");\nclass BaseObject3dShadowView {\n    constructor(object3dShadowShaders, lightDirection) {\n        this.object3dShadowShaders = object3dShadowShaders;\n        this.lightDirection = lightDirection;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint16Array([]);\n        this.orientation = new Float32Array([0, 0, 0, 1]);\n        this.orientation = (0, quat_1.setAxisAngle)(new Float32Array([1, 0, 0]), -Math.PI / 2);\n    }\n    renderFrame() {\n        let gl = this.object3dShadowShaders.gl, a_Position = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.object3dShadowShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        this.setUniforms();\n        this.object3dShadowShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    initVertexBuffers(gl) {\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Normal < 0) {\n            console.log('Failed to get the storage location of a_Normal');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    updateBuffers() {\n        const gl = this.object3dShadowShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    setUniforms() {\n        const gl = this.object3dShadowShaders.gl;\n        const translate1 = (0, mat4_1.translate)((0, mat4_1.identity_mat4)(), new Float32Array([0, 0, 0]));\n        //const translate2 = translate(identity_mat4(), new Float32Array([0, 0, 0]))\n        //const model = multiply(translate2, multiply(fromQuat(this.orientation), translate1))\n        const model = (0, mat4_1.multiply)((0, mat4_1.fromQuat)(this.orientation), translate1);\n        //const model = identity_mat4()\n        const view = this.viewMatrix();\n        const projection = this.projectionMatrix();\n        const mv = (0, mat4_1.multiply)(view, model);\n        const mvp = (0, mat4_1.multiply)(projection, mv);\n        const ambientLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"Ambient\");\n        const lightColorLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"LightColor\");\n        const modelViewProjectionMatrixLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"ModelViewProjectionMatrix\");\n        const normalMatrixLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"NormalMatrix\");\n        const lightDirectionLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"LightDirection\");\n        const halfVectorLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"LightDirection\");\n        const shininessLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"Shininess\");\n        const strengthLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"Strength\");\n        gl.uniformMatrix4fv(modelViewProjectionMatrixLoc, false, mvp);\n        gl.uniformMatrix3fv(normalMatrixLoc, false, (0, mat3_1.mat4_to_mat3)(mv));\n        gl.uniform3f(lightDirectionLoc, this.lightDirection[0], this.lightDirection[1], this.lightDirection[2]);\n        gl.uniform3f(lightColorLoc, 1, 1, 1);\n        gl.uniform3f(ambientLoc, 0.5, 0.5, 0.5);\n        const hvX = this.lightDirection[0];\n        const hvY = this.lightDirection[1];\n        const hvZ = this.lightDirection[2] + 1;\n        const norm = Math.sqrt(hvX * hvX + hvY * hvY + hvZ * hvZ);\n        gl.uniform3f(halfVectorLoc, hvX / norm, hvY / norm, hvZ / norm);\n        gl.uniform1f(shininessLoc, 50);\n        gl.uniform1f(strengthLoc, 20);\n    }\n    viewMatrix() {\n        const camera_position = new Float32Array([0, 0, 3.3]);\n        const look_at_origin = new Float32Array([0, -0.2, 0]);\n        const head_is_up = new Float32Array([0, 1, 0]);\n        return (0, mat4_1.lookAt)(camera_position, look_at_origin, head_is_up);\n    }\n    projectionMatrix() {\n        const fovy = 20 * Math.PI / 180;\n        const canvas = this.object3dShadowShaders.gl.canvas;\n        const rect = canvas.getBoundingClientRect();\n        return (0, mat4_1.perspective)(fovy, rect.width / rect.height, 0.01, 20);\n    }\n}\nexports.BaseObject3dShadowView = BaseObject3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseObject3dView = void 0;\nconst mat4_1 = require(\"../webgl/mat4\");\nconst mat3_1 = require(\"../webgl/mat3\");\nconst quat_1 = require(\"../webgl/quat\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst SquareMatrix_1 = require(\"../linearAlgebra/SquareMatrix\");\nclass BaseObject3dView {\n    constructor(object3dShaders, lightDirection) {\n        this.object3dShaders = object3dShaders;\n        this.lightDirection = lightDirection;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint16Array([]);\n        this.orientation = new Float32Array([0, 0, 0, 1]);\n        this.camera_position = new Float32Array([0, 0, 3.3]);\n        this.look_at_origin = new Float32Array([0, -0.2, 0]);\n        //private look_at_origin = new Float32Array([0, 0, 0])\n        this.head_is_up = new Float32Array([0, 1, 0]);\n        this.fovy = 20 * Math.PI / 180;\n        this.orientation = (0, quat_1.setAxisAngle)(new Float32Array([1, 0, 0]), -Math.PI / 2);\n        //this.orientation = setAxisAngle(new Float32Array([1, 0, 0]), 0)\n    }\n    renderFrame() {\n        let gl = this.object3dShaders.gl, a_Position = gl.getAttribLocation(this.object3dShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.object3dShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        this.setUniforms();\n        this.object3dShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    initVertexBuffers(gl) {\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.object3dShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Normal < 0) {\n            console.log('Failed to get the storage location of a_Normal');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    updateBuffers() {\n        const gl = this.object3dShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    getModelTransformationMatrix() {\n        const model = (0, mat4_1.fromQuat)(this.orientation);\n        const m = [model[0], model[4], model[8], model[1], model[5], model[9], model[2], model[6], model[10]];\n        return new SquareMatrix_1.SquareMatrix(3, m);\n    }\n    setUniforms() {\n        const gl = this.object3dShaders.gl;\n        const translate1 = (0, mat4_1.translate)((0, mat4_1.identity_mat4)(), new Float32Array([0, 0, 0]));\n        const model = (0, mat4_1.multiply)((0, mat4_1.fromQuat)(this.orientation), translate1);\n        const view = this.viewMatrix();\n        const projection = this.projectionMatrix();\n        const mv = (0, mat4_1.multiply)(view, model);\n        const mvp = (0, mat4_1.multiply)(projection, mv);\n        const ambientLoc = gl.getUniformLocation(this.object3dShaders.program, \"Ambient\");\n        const lightColorLoc = gl.getUniformLocation(this.object3dShaders.program, \"LightColor\");\n        const modelViewProjectionMatrixLoc = gl.getUniformLocation(this.object3dShaders.program, \"ModelViewProjectionMatrix\");\n        const normalMatrixLoc = gl.getUniformLocation(this.object3dShaders.program, \"NormalMatrix\");\n        const lightDirectionLoc = gl.getUniformLocation(this.object3dShaders.program, \"LightDirection\");\n        const halfVectorLoc = gl.getUniformLocation(this.object3dShaders.program, \"LightDirection\");\n        const shininessLoc = gl.getUniformLocation(this.object3dShaders.program, \"Shininess\");\n        const strengthLoc = gl.getUniformLocation(this.object3dShaders.program, \"Strength\");\n        gl.uniformMatrix4fv(modelViewProjectionMatrixLoc, false, mvp);\n        gl.uniformMatrix3fv(normalMatrixLoc, false, (0, mat3_1.mat4_to_mat3)(mv));\n        gl.uniform3f(lightDirectionLoc, this.lightDirection[0], this.lightDirection[1], this.lightDirection[2]);\n        gl.uniform3f(lightColorLoc, 1, 1, 1);\n        gl.uniform3f(ambientLoc, 0.1, 0.1, 0.1);\n        const hvX = this.lightDirection[0];\n        const hvY = this.lightDirection[1];\n        const hvZ = this.lightDirection[2] + 1;\n        const norm = Math.sqrt(hvX * hvX + hvY * hvY + hvZ * hvZ);\n        gl.uniform3f(halfVectorLoc, hvX / norm, hvY / norm, hvZ / norm);\n        gl.uniform1f(shininessLoc, 50);\n        gl.uniform1f(strengthLoc, 20);\n    }\n    viewMatrix() {\n        return (0, mat4_1.lookAt)(this.camera_position, this.look_at_origin, this.head_is_up);\n    }\n    projectionMatrix() {\n        const canvas = this.object3dShaders.gl.canvas;\n        const rect = canvas.getBoundingClientRect();\n        return (0, mat4_1.perspective)(this.fovy, rect.width / rect.height, 0.01, 20);\n    }\n    pickingLine(ndcX, ndcY) {\n        //https://jsantell.com/model-view-projection/\n        const canvas = this.object3dShaders.gl.canvas;\n        const rect = canvas.getBoundingClientRect();\n        const p1 = new Vector3d_1.Vector3d(this.camera_position[0], this.camera_position[1], this.camera_position[2]);\n        const pOrigin = new Vector3d_1.Vector3d(this.look_at_origin[0], this.look_at_origin[1], this.look_at_origin[2]);\n        const v1 = pOrigin.substract(p1);\n        const v2 = new Vector3d_1.Vector3d(this.head_is_up[0], this.head_is_up[1], this.head_is_up[2]);\n        const v3 = (v1).crossPoduct(v2);\n        const top = v1.axisAngleRotation(v3, this.fovy / 2);\n        const bottom = v1.axisAngleRotation(v3, -this.fovy / 2);\n        const center = top.add(bottom).multiply(0.5);\n        const right = v1.axisAngleRotation(v2, -this.fovy / 2);\n        const v4 = right.substract(center).multiply(ndcX * rect.width / rect.height);\n        const v5 = top.substract(center).multiply(ndcY);\n        const p2 = v4.add(v5).add(center).add(p1);\n        return { p1: p1, p2: p2 };\n    }\n    distanceToCamera(point) {\n        const p1 = this.getCameraPosition();\n        const pOrigin = new Vector3d_1.Vector3d(this.look_at_origin[0], this.look_at_origin[1], this.look_at_origin[2]);\n        const v1 = pOrigin.substract(p1);\n        // returns null if the point is behind the camera\n        if ((point.substract(p1)).dot(v1) < 0) {\n            return null;\n        }\n        return point.substract(p1).norm();\n    }\n    getCameraPosition() {\n        return new Vector3d_1.Vector3d(this.camera_position[0], this.camera_position[1], this.camera_position[2]);\n    }\n    getLookAtOrigin() {\n        return new Vector3d_1.Vector3d(this.look_at_origin[0], this.look_at_origin[1], this.look_at_origin[2]);\n    }\n}\nexports.BaseObject3dView = BaseObject3dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPoints2dView = void 0;\nclass ControlPoints2dView {\n    constructor(spline, controlPointsShaders, red, blue, green) {\n        this.controlPointsShaders = controlPointsShaders;\n        this.red = red;\n        this.blue = blue;\n        this.green = green;\n        this.z = 0;\n        this.selectedControlPoint = null;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.freeControlPoints;\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.controlPointsShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const size = 0.03;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (let i = 0; i < this.controlPoints.length; i += 1) {\n            let x = this.controlPoints[i].x;\n            let y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        let gl = this.controlPointsShaders.gl, a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.controlPointsShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        this.controlPointsShaders.renderFrame(this.indices.length, this.selectedControlPoint);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    controlPointSelection(x, y, deltaSquared = 0.01) {\n        let result = null;\n        for (let i = 0; i < this.controlPoints.length; i += 1) {\n            if (Math.pow(x - this.controlPoints[i].x, 2) + Math.pow(y - this.controlPoints[i].y, 2) < deltaSquared) {\n                return i;\n            }\n        }\n        return result;\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    updatePoints(points) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    updateBuffers() {\n        var gl = this.controlPointsShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    getSelectedControlPoint() {\n        return this.selectedControlPoint;\n    }\n    setSelected(controlPointIndex) {\n        this.selectedControlPoint = controlPointIndex;\n    }\n}\nexports.ControlPoints2dView = ControlPoints2dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPoints3dShadowView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst BaseObject3dShadowView_1 = require(\"./BaseObject3dShadowView\");\nconst ControlPoints3dView_1 = require(\"./ControlPoints3dView\");\nclass ControlPoints3dShadowView extends BaseObject3dShadowView_1.BaseObject3dShadowView {\n    constructor(spline, object3dShadowShaders, lightDirection) {\n        super(object3dShadowShaders, lightDirection);\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShadowShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.015;\n        const sectorCount = 50;\n        const stackCount = 50;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let cp of this.spline.controlPoints) {\n            let v = (0, ControlPoints3dView_1.verticesForOneSphere)(cp, radius, sectorCount, stackCount, { red: 0.5, green: 0.5, blue: 0.5 });\n            let i = (0, ControlPoints3dView_1.indicesForOneSphere)(startingIndex, sectorCount, stackCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...i];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.ControlPoints3dShadowView = ControlPoints3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indicesForOneSphere = exports.verticesForOneSphere = exports.ControlPoints3dView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst BaseObject3dView_1 = require(\"./BaseObject3dView\");\nconst LUSolve_1 = require(\"../linearAlgebra/LUSolve\");\nclass ControlPoints3dView extends BaseObject3dView_1.BaseObject3dView {\n    constructor(spline, object3dShaders, lightDirection) {\n        super(object3dShaders, lightDirection);\n        this.spline = spline;\n        this.selectedControlPoint = null;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.015;\n        const sectorCount = 50;\n        const stackCount = 50;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let i = 0; i < this.spline.controlPoints.length; i += 1) {\n            let v;\n            if (i === this.selectedControlPoint) {\n                v = verticesForOneSphere(this.spline.controlPoints[i], radius, sectorCount, stackCount, { red: 0.7, green: 0.7, blue: 0.7 });\n            }\n            else {\n                v = verticesForOneSphere(this.spline.controlPoints[i], radius, sectorCount, stackCount, { red: 0.5, green: 0.5, blue: 0.5 });\n            }\n            let ind = indicesForOneSphere(startingIndex, sectorCount, stackCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    updateVerticesIndicesAndBuffers() {\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    controlPointSelection(x, y, deltaSquared = 0.01) {\n        let result = null;\n        let previousDistance = null;\n        const l = this.pickingLine(x, y);\n        for (let i = 0; i < this.spline.controlPoints.length; i += 1) {\n            const m = this.getModelTransformationMatrix();\n            const cp = this.spline.controlPoints[i];\n            const v = m.multiplyByVector([cp.x, cp.y, cp.z]);\n            const p = new Vector3d_1.Vector3d(v[0], v[1], v[2]);\n            if ((0, Vector3d_1.pointLineDistance)(p, l.p1, l.p2) < deltaSquared) {\n                let d = this.distanceToCamera(p);\n                if (d !== null) {\n                    if (previousDistance === null || d < previousDistance) {\n                        result = i;\n                        previousDistance = d;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    getSelectedControlPoint() {\n        return this.selectedControlPoint;\n    }\n    setSelected(controlPointIndex) {\n        this.selectedControlPoint = controlPointIndex;\n    }\n    computeNewPosition(ndcX, ndcY) {\n        let result = null;\n        if (this.selectedControlPoint !== null) {\n            const m = this.getModelTransformationMatrix();\n            const cp = this.spline.controlPoints[this.selectedControlPoint];\n            const v = m.multiplyByVector([cp.x, cp.y, cp.z]);\n            const p = new Vector3d_1.Vector3d(v[0], v[1], v[2]);\n            const l = this.pickingLine(ndcX, ndcY);\n            let pp = (0, Vector3d_1.linePlaneIntersection)(l.p1, l.p2, this.getLookAtOrigin(), this.getCameraPosition(), p);\n            let point = (0, LUSolve_1.lusolve)(m, [pp.x, pp.y, pp.z]);\n            if (point !== undefined) {\n                result = new Vector3d_1.Vector3d(point[0], point[1], point[2]);\n            }\n        }\n        return result;\n    }\n}\nexports.ControlPoints3dView = ControlPoints3dView;\nfunction verticesForOneSphere(center, radius, sectorCount, stackCount, color) {\n    //http://www.songho.ca/opengl/gl_sphere.html\n    let x, y, z, xy; // vertex position\n    let nx, ny, nz; // vertex normal\n    let sectorAngle, stackAngle;\n    const lengthInv = 1 / radius;\n    const sectorStep = 2 * Math.PI / sectorCount;\n    const stackStep = Math.PI / stackCount;\n    let result = [];\n    for (let i = 0; i <= stackCount; i += 1) {\n        stackAngle = Math.PI / 2 - i * stackStep; // starting from pi/2 to -pi/2\n        xy = radius * Math.cos(stackAngle);\n        z = radius * Math.sin(stackAngle);\n        // add (sectorCout+1) vertices per stack\n        // the first and last vertices have the same position and normal\n        for (let j = 0; j <= sectorCount; j += 1) {\n            sectorAngle = j * sectorStep; // starting for 0 to 2pi\n            // vertex position (x, y, z)\n            x = xy * Math.cos(sectorAngle); // r * cos(u) * cos(v)\n            y = xy * Math.sin(sectorAngle); // r * cos(u) * sin(v)\n            result.push(x + center.x);\n            result.push(y + center.y);\n            result.push(z + center.z);\n            // normalized vertex normal (nx, ny, nz)\n            nx = x * lengthInv;\n            ny = y * lengthInv;\n            nz = z * lengthInv;\n            result.push(nx);\n            result.push(ny);\n            result.push(nz);\n            // Color\n            result.push(color.red);\n            result.push(color.green);\n            result.push(color.blue);\n        }\n    }\n    return result;\n}\nexports.verticesForOneSphere = verticesForOneSphere;\nfunction indicesForOneSphere(startingIndex, sectorCount, stackCount) {\n    let result = [];\n    for (let i = 0; i < stackCount; i += 1) {\n        let k1 = i * (sectorCount + 1); // beginning of current stack\n        let k2 = k1 + sectorCount + 1; // beginning of next stack\n        for (let j = 0; j < sectorCount; j += 1, k1 += 1, k2 += 1) {\n            if (i != 0) {\n                result.push(k1 + startingIndex);\n                result.push(k2 + startingIndex);\n                result.push(k1 + 1 + startingIndex);\n            }\n            if (i != (stackCount - 1)) {\n                result.push(k1 + 1 + startingIndex);\n                result.push(k2 + startingIndex);\n                result.push(k2 + 1 + startingIndex);\n            }\n        }\n    }\n    return result;\n}\nexports.indicesForOneSphere = indicesForOneSphere;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPointsShaders = void 0;\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass ControlPointsShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    v_Color = a_Color; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            '//uniform bool selected; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '     vec4 fColor = vec4(0.1, 0.1, 0.1, 0.0); \\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     vec4 color1 = vec4(v_Color, 0.35); \\n' +\n            '     vec4 color2 = vec4(v_Color, 0.9); \\n' +\n            '     float delta = 0.1; \\n' +\n            '     float alpha1 = smoothstep(0.35-delta, 0.35, dist); \\n' +\n            '     float alpha2 = smoothstep(0.65-delta, 0.65, dist); \\n' +\n            '     vec4 fColor1 = mix(color1, fColor, alpha1); \\n' +\n            '     vec4 fColor2 = mix(color2, fColor, alpha2); \\n' +\n            '     gl_FragColor = (fColor1+fColor2)/2.0; \\n' +\n            '}\\n';\n        this.program = (0, cuon_utils_1.createProgram)(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfElements, selectedControlPoint) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n            if (selectedControlPoint != -1 && selectedControlPoint !== null) {\n                this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_BYTE, selectedControlPoint * 6);\n            }\n        }\n    }\n}\nexports.ControlPointsShaders = ControlPointsShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPolygon2dShaders = void 0;\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass ControlPolygon2dShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec4 fColor; \\n' +\n            'void main() {\\n' +\n            '    gl_FragColor = fColor; \\n' +\n            '}\\n';\n        this.program = (0, cuon_utils_1.createProgram)(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfElements) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n    }\n}\nexports.ControlPolygon2dShaders = ControlPolygon2dShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPolygon2dView = void 0;\nclass ControlPolygon2dView {\n    constructor(spline, controlPolygonShaders, closed, red, green, blue, alpha) {\n        this.controlPolygonShaders = controlPolygonShaders;\n        this.closed = closed;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.controlPolygonShaders = controlPolygonShaders;\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.controlPolygonShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    set isClosed(bool) {\n        this.closed = bool;\n    }\n    updateVerticesAndIndices() {\n        const thickness = 0.003;\n        this.vertices = new Float32Array(this.controlPoints.length * 12);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (let i = 0; i < this.controlPoints.length - 1; i += 1) {\n            const normal = this.controlPoints[i + 1].subtract(this.controlPoints[i]).normalize().rotate90degrees();\n            this.vertices[12 * i] = this.controlPoints[i].x - thickness * normal.x;\n            this.vertices[12 * i + 1] = this.controlPoints[i].y - thickness * normal.y;\n            this.vertices[12 * i + 2] = this.z;\n            this.vertices[12 * i + 3] = this.controlPoints[i + 1].x - thickness * normal.x;\n            this.vertices[12 * i + 4] = this.controlPoints[i + 1].y - thickness * normal.y;\n            this.vertices[12 * i + 5] = this.z;\n            this.vertices[12 * i + 6] = this.controlPoints[i + 1].x + thickness * normal.x;\n            this.vertices[12 * i + 7] = this.controlPoints[i + 1].y + thickness * normal.y;\n            this.vertices[12 * i + 8] = this.z;\n            this.vertices[12 * i + 9] = this.controlPoints[i].x + thickness * normal.x;\n            this.vertices[12 * i + 10] = this.controlPoints[i].y + thickness * normal.y;\n            this.vertices[12 * i + 11] = this.z;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        const gl = this.controlPolygonShaders.gl;\n        const a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        const fColorLocation = gl.getUniformLocation(this.controlPolygonShaders.program, \"fColor\");\n        gl.useProgram(this.controlPolygonShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(a_Position);\n        gl.uniform4f(fColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.controlPolygonShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    update(message) {\n        this.controlPoints = message.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    updateBuffers() {\n        const gl = this.controlPolygonShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n}\nexports.ControlPolygon2dView = ControlPolygon2dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ControlPolygon3dShadowView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst BaseObject3dShadowView_1 = require(\"./BaseObject3dShadowView\");\nconst ControlPolygon3dView_1 = require(\"./ControlPolygon3dView\");\nclass ControlPolygon3dShadowView extends BaseObject3dShadowView_1.BaseObject3dShadowView {\n    constructor(spline, object3dShadowShaders, lightDirection, closed) {\n        super(object3dShadowShaders, lightDirection);\n        this.closed = closed;\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShadowShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.003;\n        const sectorCount = 20;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let i = 0; i < this.controlPoints.length - 1; i += 1) {\n            let v = (0, ControlPolygon3dView_1.verticesForOneCylinder)(this.controlPoints[i], this.controlPoints[i + 1], radius, sectorCount);\n            let ind = (0, ControlPolygon3dView_1.indicesForOneCylinder)(startingIndex, sectorCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.ControlPolygon3dShadowView = ControlPolygon3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indicesForOneCylinder = exports.orientedCircle = exports.verticesForOneCylinder = exports.ControlPolygon3dView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst RotationMatrix_1 = require(\"../mathVector/RotationMatrix\");\nconst BaseObject3dView_1 = require(\"./BaseObject3dView\");\nclass ControlPolygon3dView extends BaseObject3dView_1.BaseObject3dView {\n    constructor(spline, object3dShaders, lightDirection, closed) {\n        super(object3dShaders, lightDirection);\n        this.closed = closed;\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.003;\n        const sectorCount = 20;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let i = 0; i < this.controlPoints.length - 1; i += 1) {\n            let v = verticesForOneCylinder(this.controlPoints[i], this.controlPoints[i + 1], radius, sectorCount);\n            let ind = indicesForOneCylinder(startingIndex, sectorCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.ControlPolygon3dView = ControlPolygon3dView;\nfunction verticesForOneCylinder(centerTop, centerBottom, radius, sectorCount) {\n    let axisVector = centerTop.substract(centerBottom).normalize();\n    const circleTop = orientedCircle(centerTop, radius, axisVector, sectorCount);\n    const circleBottom = orientedCircle(centerBottom, radius, axisVector, sectorCount);\n    let result = [];\n    for (let i = 0; i < circleTop.vertices.length; i += 1) {\n        // vertex position (x, y, z)\n        result.push(circleTop.vertices[i].x);\n        result.push(circleTop.vertices[i].y);\n        result.push(circleTop.vertices[i].z);\n        // normalized vertex normal (nx, ny, nz)\n        result.push(circleTop.normals[i].x);\n        result.push(circleTop.normals[i].y);\n        result.push(circleTop.normals[i].z);\n        // Color\n        result.push(0.5);\n        result.push(0.5);\n        result.push(0.5);\n    }\n    for (let i = 0; i < circleBottom.vertices.length; i += 1) {\n        // vertex position (x, y, z)\n        result.push(circleBottom.vertices[i].x);\n        result.push(circleBottom.vertices[i].y);\n        result.push(circleBottom.vertices[i].z);\n        // normalized vertex normal (nx, ny, nz)\n        result.push(circleBottom.normals[i].x);\n        result.push(circleBottom.normals[i].y);\n        result.push(circleBottom.normals[i].z);\n        // Color\n        result.push(0.8);\n        result.push(0.8);\n        result.push(0.8);\n    }\n    return result;\n}\nexports.verticesForOneCylinder = verticesForOneCylinder;\nfunction orientedCircle(center, radius, axisVector, sectorCount) {\n    const n = axisVector.dot(new Vector3d_1.Vector3d(0, 0, 1));\n    const sectorStep = 2 * Math.PI / sectorCount;\n    let vertices = [];\n    let normals = [];\n    if (n > 0) {\n        const rotationMatrix = (0, RotationMatrix_1.rotationMatrixFromTwoVectors)(new Vector3d_1.Vector3d(0, 0, 1), axisVector);\n        for (let j = 0; j <= sectorCount; j += 1) {\n            let sectorAngle = j * sectorStep; // starting for 0 to 2pi\n            // cicle in the plane xy \n            let x = radius * Math.cos(sectorAngle);\n            let y = radius * Math.sin(sectorAngle);\n            let v = rotationMatrix.multiplyByVector([x, y, 0]);\n            vertices.push(new Vector3d_1.Vector3d(v[0] + center.x, v[1] + center.y, v[2] + center.z));\n            let nx = Math.cos(sectorAngle);\n            let ny = Math.sin(sectorAngle);\n            let nv = rotationMatrix.multiplyByVector([nx, ny, 0]);\n            normals.push(new Vector3d_1.Vector3d(nv[0], nv[1], nv[2]));\n        }\n    }\n    else {\n        const rotationMatrix = (0, RotationMatrix_1.rotationMatrixFromTwoVectors)(new Vector3d_1.Vector3d(0, 1, 0), axisVector);\n        for (let j = 0; j <= sectorCount; j += 1) {\n            let sectorAngle = j * sectorStep; // starting for 0 to 2pi\n            // cicle in the plane xz \n            let x = radius * Math.cos(sectorAngle);\n            let z = radius * Math.sin(sectorAngle);\n            let v = rotationMatrix.multiplyByVector([x, 0, z]);\n            vertices.push(new Vector3d_1.Vector3d(v[0] + center.x, v[1] + center.y, v[2] + center.z));\n            let nx = Math.cos(sectorAngle);\n            let nz = Math.sin(sectorAngle);\n            let nv = rotationMatrix.multiplyByVector([nx, 0, nz]);\n            normals.push(new Vector3d_1.Vector3d(nv[0], nv[1], nv[2]));\n        }\n    }\n    return { vertices: vertices, normals: normals };\n}\nexports.orientedCircle = orientedCircle;\nfunction indicesForOneCylinder(startingIndex, sectorCount) {\n    let result = [];\n    let k1 = 0; // beginning of current stack\n    let k2 = k1 + sectorCount + 1; // beginning of next stack\n    for (let j = 0; j < sectorCount; j += 1, k1 += 1, k2 += 1) {\n        result.push(k1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k2 + 1 + startingIndex);\n    }\n    return result;\n}\nexports.indicesForOneCylinder = indicesForOneCylinder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurvatureExtrema2dView = void 0;\nclass CurvatureExtrema2dView {\n    constructor(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.curvatureExtrema = [];\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    updateVerticesAndIndices() {\n        const size = 0.03;\n        this.vertices = new Float32Array(this.curvatureExtrema.length * 32);\n        this.indices = new Uint8Array(this.curvatureExtrema.length * 6);\n        for (let i = 0; i < this.curvatureExtrema.length; i += 1) {\n            let x = this.curvatureExtrema[i].x;\n            let y = this.curvatureExtrema[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        let gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    update(spline) {\n        const splineDP = spline.getDifferentialProperties();\n        this.curvatureExtrema = splineDP.curvatureExtrema();\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    updateBuffers() {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n}\nexports.CurvatureExtrema2dView = CurvatureExtrema2dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurvatureExtrema3dView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst BaseObject3dView_1 = require(\"./BaseObject3dView\");\nconst BSplineR1toR3DifferentialProperties_1 = require(\"../bsplines/R1toR3/BSplineR1toR3DifferentialProperties\");\nconst ControlPoints3dView_1 = require(\"./ControlPoints3dView\");\nclass CurvatureExtrema3dView extends BaseObject3dView_1.BaseObject3dView {\n    constructor(spline, object3dShaders, lightDirection) {\n        super(object3dShaders, lightDirection);\n        this.spline = spline;\n        const splineDP = new BSplineR1toR3DifferentialProperties_1.BSplineR1toR3DifferentialProperties(spline);\n        this.zeros = splineDP.curvatureDerivativeZeros();\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.012;\n        const sectorCount = 50;\n        const stackCount = 50;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let zero of this.zeros) {\n            let v = (0, ControlPoints3dView_1.verticesForOneSphere)(zero, radius, sectorCount, stackCount, { red: 1, green: 0.5, blue: 0.5 });\n            let ind = (0, ControlPoints3dView_1.indicesForOneSphere)(startingIndex, sectorCount, stackCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    updateVerticesIndicesAndBuffers() {\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    update(spline) {\n        this.spline = spline;\n        const splineDP = new BSplineR1toR3DifferentialProperties_1.BSplineR1toR3DifferentialProperties(spline);\n        this.zeros = splineDP.curvatureDerivativeZeros();\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.CurvatureExtrema3dView = CurvatureExtrema3dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurvatureExtremaShaders = void 0;\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass CurvatureExtremaShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            'uniform vec4 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     if (dist > 0.5) discard; \\n' +\n            '     gl_FragColor = a_Color; \\n' +\n            '}\\n';\n        this.program = (0, cuon_utils_1.createProgram)(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfElements) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n        }\n    }\n}\nexports.CurvatureExtremaShaders = CurvatureExtremaShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Curve2dShaders = void 0;\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass Curve2dShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec4 fColor; \\n' +\n            'void main() {\\n' +\n            '    gl_FragColor = fColor; \\n' +\n            '}\\n';\n        this.program = (0, cuon_utils_1.createProgram)(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfVertices) {\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, numberOfVertices);\n    }\n}\nexports.Curve2dShaders = Curve2dShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Curve2dView = void 0;\nclass Curve2dView {\n    constructor(spline, curveShaders, red, green, blue, alpha) {\n        this.spline = spline;\n        this.curveShaders = curveShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.POINT_SEQUENCE_SIZE = 1000;\n        this.pointSequenceOnSpline = [];\n        this.vertexBuffer = null;\n        this.vertices = new Float32Array(this.POINT_SEQUENCE_SIZE * 6);\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.curveShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updatePointSequenceOnSpline() {\n        const start = this.spline.knots[this.spline.degree];\n        const end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        this.pointSequenceOnSpline = [];\n        for (let i = 0; i < this.POINT_SEQUENCE_SIZE; i += 1) {\n            let point = this.spline.evaluate(i / (this.POINT_SEQUENCE_SIZE - 1) * (end - start) + start);\n            this.pointSequenceOnSpline.push(point);\n        }\n    }\n    updateVertices() {\n        const thickness = 0.005;\n        const maxLength = thickness * 3;\n        let tangent = ((this.pointSequenceOnSpline[1]).subtract(this.pointSequenceOnSpline[0])).normalize(), normal = tangent.rotate90degrees(), miter, length, result = [];\n        result.push(this.pointSequenceOnSpline[0].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[0].subtract(normal.multiply(thickness)));\n        for (let i = 1; i < this.pointSequenceOnSpline.length - 1; i += 1) {\n            normal = (this.pointSequenceOnSpline[i].subtract(this.pointSequenceOnSpline[i - 1])).normalize().rotate90degrees();\n            tangent = (this.pointSequenceOnSpline[i + 1].subtract(this.pointSequenceOnSpline[i - 1])).normalize();\n            miter = tangent.rotate90degrees();\n            length = thickness / (miter.dot(normal));\n            if (length > maxLength) {\n                length = maxLength;\n            }\n            result.push(this.pointSequenceOnSpline[i].add(miter.multiply(length)));\n            result.push(this.pointSequenceOnSpline[i].subtract(miter.multiply(length)));\n        }\n        tangent = this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].subtract(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 2]).normalize();\n        normal = tangent.rotate90degrees();\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].subtract(normal.multiply(thickness)));\n        for (let i = 0; i < result.length; i += 1) {\n            this.vertices[3 * i] = result[i].x;\n            this.vertices[3 * i + 1] = result[i].y;\n            this.vertices[3 * i + 2] = 0.0;\n        }\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        this.updateBuffers();\n    }\n    updateBuffers() {\n        const gl = this.curveShaders.gl;\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    renderFrame() {\n        const gl = this.curveShaders.gl;\n        const a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        const fColorLocation = gl.getUniformLocation(this.curveShaders.program, \"fColor\");\n        gl.useProgram(this.curveShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.uniform4f(fColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curveShaders.renderFrame(this.vertices.length / 3);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    initVertexBuffers(gl) {\n        const a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        return 1;\n    }\n}\nexports.Curve2dView = Curve2dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Curve3dShadowView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst BaseObject3dShadowView_1 = require(\"./BaseObject3dShadowView\");\nconst Curve3dView_1 = require(\"./Curve3dView\");\nclass Curve3dShadowView extends BaseObject3dShadowView_1.BaseObject3dShadowView {\n    constructor(spline, object3dShadowShaders, lightDirection, closed) {\n        super(object3dShadowShaders, lightDirection);\n        this.spline = spline;\n        this.closed = closed;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShadowShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.005;\n        const sectorCount = 20;\n        const stackCount = 200;\n        let indices = [];\n        let startingIndex = 0;\n        const vertices = this.computeVertices(radius, stackCount, sectorCount);\n        for (let i = 0; i < stackCount - 1; i += 1) {\n            let ind = (0, Curve3dView_1.indicesForOneCylinder)(startingIndex, sectorCount);\n            indices = [...indices, ...ind];\n            startingIndex += sectorCount + 1;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    frames(number) {\n        const start = this.spline.knots[this.spline.degree];\n        const end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        let pointSequenceOnSpline = [];\n        for (let i = 0; i < number; i += 1) {\n            let point = this.spline.evaluate(i / (number - 1) * (end - start) + start);\n            pointSequenceOnSpline.push(point);\n        }\n        const tangentSequenceOnSpline = (0, Curve3dView_1.computeApproximatedTangentsFromPointsSequence)(pointSequenceOnSpline);\n        const randomUpVector = (0, Curve3dView_1.computeRandomUpVector)(tangentSequenceOnSpline[0]);\n        const upVectorSequenceOnSpline = (0, Curve3dView_1.computeUpVectorSequence)(tangentSequenceOnSpline, randomUpVector);\n        return { pointSequence: pointSequenceOnSpline, tangentSequence: tangentSequenceOnSpline, upVectorSequence: upVectorSequenceOnSpline };\n    }\n    computeVertices(radius, stackCount, sectorCount) {\n        let frames = this.frames(stackCount);\n        let result = [];\n        for (let i = 0; i < frames.pointSequence.length; i += 1) {\n            let oe = (0, Curve3dView_1.orientedEllipse)(frames.pointSequence[i], frames.tangentSequence[i], frames.upVectorSequence[i], sectorCount, radius, radius);\n            for (let j = 0; j < oe.vertices.length; j += 1) {\n                // vertex position (x, y, z)\n                result.push(oe.vertices[j].x);\n                result.push(oe.vertices[j].y);\n                result.push(oe.vertices[j].z);\n                // normalized vertex normal (nx, ny, nz)\n                result.push(oe.normals[j].x);\n                result.push(oe.normals[j].y);\n                result.push(oe.normals[j].z);\n                // Color\n                result.push(1.0);\n                result.push(0.5);\n                result.push(0.5);\n            }\n        }\n        return result;\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.Curve3dShadowView = Curve3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeApproximatedTangentsFromPointsSequence = exports.orientedEllipse = exports.computeUpVectorSequence = exports.indicesForOneCylinder = exports.computeRandomUpVector = exports.Curve3dView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst RotationMatrix_1 = require(\"../mathVector/RotationMatrix\");\nconst BaseObject3dView_1 = require(\"./BaseObject3dView\");\nclass Curve3dView extends BaseObject3dView_1.BaseObject3dView {\n    //private controlPoints: Vector3d[]\n    constructor(spline, object3dShaders, lightDirection, closed) {\n        super(object3dShaders, lightDirection);\n        this.spline = spline;\n        this.closed = closed;\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.005;\n        const sectorCount = 20;\n        const stackCount = 200;\n        let indices = [];\n        let startingIndex = 0;\n        const vertices = this.computeVertices(radius, stackCount, sectorCount);\n        for (let i = 0; i < stackCount - 1; i += 1) {\n            let ind = indicesForOneCylinder(startingIndex, sectorCount);\n            indices = [...indices, ...ind];\n            startingIndex += sectorCount + 1;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    frames(number) {\n        const start = this.spline.knots[this.spline.degree];\n        const end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        let pointSequenceOnSpline = [];\n        for (let i = 0; i < number; i += 1) {\n            let point = this.spline.evaluate(i / (number - 1) * (end - start) + start);\n            pointSequenceOnSpline.push(point);\n        }\n        const tangentSequenceOnSpline = computeApproximatedTangentsFromPointsSequence(pointSequenceOnSpline);\n        const randomUpVector = computeRandomUpVector(tangentSequenceOnSpline[0]);\n        const upVectorSequenceOnSpline = computeUpVectorSequence(tangentSequenceOnSpline, randomUpVector);\n        return { pointSequence: pointSequenceOnSpline, tangentSequence: tangentSequenceOnSpline, upVectorSequence: upVectorSequenceOnSpline };\n    }\n    computeVertices(radius, stackCount, sectorCount) {\n        let frames = this.frames(stackCount);\n        let result = [];\n        for (let i = 0; i < frames.pointSequence.length; i += 1) {\n            let oe = orientedEllipse(frames.pointSequence[i], frames.tangentSequence[i], frames.upVectorSequence[i], sectorCount, radius, radius);\n            for (let j = 0; j < oe.vertices.length; j += 1) {\n                // vertex position (x, y, z)\n                result.push(oe.vertices[j].x);\n                result.push(oe.vertices[j].y);\n                result.push(oe.vertices[j].z);\n                // normalized vertex normal (nx, ny, nz)\n                result.push(oe.normals[j].x);\n                result.push(oe.normals[j].y);\n                result.push(oe.normals[j].z);\n                // Color\n                result.push(1.0);\n                result.push(0.5);\n                result.push(0.5);\n            }\n        }\n        return result;\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.Curve3dView = Curve3dView;\nfunction computeRandomUpVector(tangentVector) {\n    if (tangentVector.x > tangentVector.y) {\n        return tangentVector.crossPoduct(new Vector3d_1.Vector3d(0, 1, 0)).normalize();\n    }\n    else {\n        return tangentVector.crossPoduct(new Vector3d_1.Vector3d(1, 0, 0)).normalize();\n    }\n}\nexports.computeRandomUpVector = computeRandomUpVector;\nfunction indicesForOneCylinder(startingIndex, sectorCount) {\n    let result = [];\n    let k1 = 0; // beginning of current stack\n    let k2 = k1 + sectorCount + 1; // beginning of next stack\n    for (let j = 0; j < sectorCount; j += 1, k1 += 1, k2 += 1) {\n        result.push(k1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k2 + 1 + startingIndex);\n    }\n    return result;\n}\nexports.indicesForOneCylinder = indicesForOneCylinder;\nfunction computeUpVectorSequence(tangentSequence, firstUpVector) {\n    let result = [];\n    result.push(firstUpVector);\n    for (let i = 0; i < tangentSequence.length - 1; i += 1) {\n        let rotationMatrix = (0, RotationMatrix_1.rotationMatrixFromTwoVectors)(tangentSequence[i], tangentSequence[i + 1]);\n        let lastUpVector = result[result.length - 1];\n        let newUpVector = rotationMatrix.multiplyByVector([lastUpVector.x, lastUpVector.y, lastUpVector.z]);\n        result.push(new Vector3d_1.Vector3d(newUpVector[0], newUpVector[1], newUpVector[2]).normalize());\n    }\n    return result;\n}\nexports.computeUpVectorSequence = computeUpVectorSequence;\nfunction orientedEllipse(center, normal, up, sectorCount, semiMinorAxis, semiMajorAxis, miter = new Vector3d_1.Vector3d(1, 0, 0)) {\n    const sectorStep = 2 * Math.PI / sectorCount;\n    let vertices = [];\n    let normals = [];\n    let side = normal.crossPoduct(up).normalize();\n    for (let i = 0; i <= sectorCount; i += 1) {\n        let sectorAngle = i * sectorStep; // starting for 0 to 2pi\n        let v1 = up.multiply(Math.sin(sectorAngle) * semiMinorAxis);\n        let v2 = side.multiply(Math.cos(sectorAngle) * semiMajorAxis);\n        vertices.push(v1.add(v2).add(center));\n    }\n    for (let i = 0; i <= sectorCount; i += 1) {\n        let sectorAngle = i * sectorStep; // starting for 0 to 2pi\n        let v1 = up.multiply(Math.sin(sectorAngle) * semiMinorAxis);\n        let v2 = side.multiply(Math.cos(sectorAngle) * semiMajorAxis);\n        normals.push(v1.add(v2).normalize());\n    }\n    return { vertices: vertices, normals: normals };\n}\nexports.orientedEllipse = orientedEllipse;\nfunction computeMiterFromPointsSequence(points, radius) {\n    const tolerance = 10e-5;\n    const maxLength = radius * 3;\n    let miters = [];\n    let lengths = [];\n    let normal;\n    for (let i = 1; i < points.length - 1; i += 1) {\n        let tangent = points[i + 1].substract(points[i - 1]).normalize();\n        let v1 = points[i + 1].substract(points[i]);\n        let v2 = points[i + 2].substract(points[i + 1]);\n        let n = v1.crossPoduct(v2);\n        if (n.norm() > tolerance) {\n            normal = n.normalize();\n        }\n        else {\n            normal = computeRandomUpVector(tangent);\n        }\n        miters.push(normal);\n        let l = normal.crossPoduct(v1).norm();\n        if (l > maxLength) {\n            l = maxLength;\n        }\n        if (l > tolerance) {\n            lengths.push(radius / l);\n        }\n        else {\n            lengths.push(radius);\n        }\n    }\n    return { miters: miters, lengths: lengths };\n}\nfunction computeApproximatedTangentsFromPointsSequence(points) {\n    let result = [];\n    let tangent = (points[1].substract(points[0])).normalize();\n    result.push(tangent);\n    for (let i = 1; i < points.length - 1; i += 1) {\n        tangent = (points[i + 1].substract(points[i - 1])).normalize();\n        result.push(tangent);\n    }\n    tangent = (points[points.length - 1].substract(points[points.length - 2])).normalize();\n    result.push(tangent);\n    return result;\n}\nexports.computeApproximatedTangentsFromPointsSequence = computeApproximatedTangentsFromPointsSequence;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveScene3dView = void 0;\nconst quat_1 = require(\"../webgl/quat\");\nconst ControlPoints3dView_1 = require(\"./ControlPoints3dView\");\nconst ControlPoints3dShadowView_1 = require(\"./ControlPoints3dShadowView\");\nconst ControlPolygon3dView_1 = require(\"./ControlPolygon3dView\");\nconst ControlPolygon3dShadowView_1 = require(\"./ControlPolygon3dShadowView\");\nconst Object3dShaders_1 = require(\"./Object3dShaders\");\nconst Curve3dView_1 = require(\"./Curve3dView\");\nconst Curve3dShadowView_1 = require(\"./Curve3dShadowView\");\nconst Object3dShadowShaders_1 = require(\"./Object3dShadowShaders\");\nconst CurveScene3dController_1 = require(\"../controllers/CurveScene3dController\");\nconst TorsionZeros3dView_1 = require(\"./TorsionZeros3dView\");\nconst CurvatureExtrema3dView_1 = require(\"./CurvatureExtrema3dView\");\nvar STATE;\n(function (STATE) {\n    STATE[STATE[\"NONE\"] = 0] = \"NONE\";\n    STATE[STATE[\"ROTATE\"] = 1] = \"ROTATE\";\n})(STATE || (STATE = {}));\nclass CurveScene3dView {\n    constructor(canvas, gl, curve3dModel) {\n        this.canvas = canvas;\n        this.gl = gl;\n        this.selectedControlPoint = null;\n        this.dragging = false;\n        this.lightDirection = [0, 1, 1];\n        this.previousMousePosition = { x: 0, y: 0 };\n        this.state = STATE.NONE;\n        this.curve3dModel = curve3dModel;\n        this.object3dShaders = new Object3dShaders_1.Object3dShaders(this.gl);\n        this.object3dShadowShaders = new Object3dShadowShaders_1.Object3dShadowShaders(this.gl);\n        this.controlPoints3dView = new ControlPoints3dView_1.ControlPoints3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection);\n        this.controlPoints3dShadowView = new ControlPoints3dShadowView_1.ControlPoints3dShadowView(curve3dModel.spline, this.object3dShadowShaders, this.lightDirection);\n        this.controlPolygon3dView = new ControlPolygon3dView_1.ControlPolygon3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection, false);\n        this.controlPolygon3dShadowView = new ControlPolygon3dShadowView_1.ControlPolygon3dShadowView(curve3dModel.spline, this.object3dShadowShaders, this.lightDirection, false);\n        this.curve3dView = new Curve3dView_1.Curve3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection, false);\n        this.curve3dShadowView = new Curve3dShadowView_1.Curve3dShadowView(curve3dModel.spline, this.object3dShadowShaders, this.lightDirection, false);\n        this.torsionZerosView = new TorsionZeros3dView_1.TorsionZeros3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection);\n        this.curvatureExtrema3dView = new CurvatureExtrema3dView_1.CurvatureExtrema3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection);\n        this.curve3dModel.registerObserver(this.controlPoints3dView);\n        this.curve3dModel.registerObserver(this.controlPolygon3dView);\n        this.curve3dModel.registerObserver(this.curve3dView);\n        this.curve3dModel.registerObserver(this.controlPoints3dShadowView);\n        this.curve3dModel.registerObserver(this.controlPolygon3dShadowView);\n        this.curve3dModel.registerObserver(this.curve3dShadowView);\n        this.curve3dModel.registerObserver(this.torsionZerosView);\n        this.curve3dModel.registerObserver(this.curvatureExtrema3dView);\n        this.curveScene3dControler = new CurveScene3dController_1.CurveScene3dController(curve3dModel);\n    }\n    renderFrame() {\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.gl.clearColor(0.2, 0.2, 0.2, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.controlPoints3dView.renderFrame();\n        this.controlPoints3dShadowView.renderFrame();\n        this.controlPolygon3dView.renderFrame();\n        this.controlPolygon3dShadowView.renderFrame();\n        this.curve3dView.renderFrame();\n        this.curve3dShadowView.renderFrame();\n        this.torsionZerosView.renderFrame();\n        this.curvatureExtrema3dView.renderFrame();\n    }\n    mousedown(event, deltaSquared = 0.01) {\n        const ndc = this.mouse_get_NormalizedDeviceCoordinates(event);\n        this.selectedControlPoint = this.controlPoints3dView.controlPointSelection(ndc.x, ndc.y, deltaSquared);\n        this.controlPoints3dView.setSelected(this.selectedControlPoint);\n        this.previousMousePosition = ndc;\n        if (event.button === 0 && this.selectedControlPoint === null) {\n            this.state = STATE.ROTATE;\n        }\n        if (this.selectedControlPoint !== null) {\n            this.dragging = true;\n        }\n        this.controlPoints3dView.updateVerticesIndicesAndBuffers();\n    }\n    mousemove(event) {\n        if (this.state === STATE.ROTATE || this.dragging === true) {\n            const currentMousePosition = this.mouse_get_NormalizedDeviceCoordinates(event);\n            const deltaMove = {\n                x: currentMousePosition.x - this.previousMousePosition.x,\n                y: currentMousePosition.y - this.previousMousePosition.y\n            };\n            this.previousMousePosition = this.mouse_get_NormalizedDeviceCoordinates(event);\n            if (this.state === STATE.ROTATE) {\n                const deltaRotationQuaternion = (0, quat_1.fromEuler)(-deltaMove.y * 500, deltaMove.x * 500, 0);\n                this.controlPoints3dView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.controlPoints3dView.orientation);\n                this.controlPoints3dShadowView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.controlPoints3dShadowView.orientation);\n                this.controlPolygon3dView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.controlPolygon3dView.orientation);\n                this.controlPolygon3dShadowView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.controlPolygon3dShadowView.orientation);\n                this.curve3dView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.curve3dView.orientation);\n                this.curve3dShadowView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.curve3dShadowView.orientation);\n                this.torsionZerosView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.torsionZerosView.orientation);\n                this.curvatureExtrema3dView.orientation = (0, quat_1.multiply_quats)(deltaRotationQuaternion, this.curvatureExtrema3dView.orientation);\n            }\n            if (this.dragging === true) {\n                const selectedControlPoint = this.controlPoints3dView.getSelectedControlPoint();\n                if (selectedControlPoint != null && this.dragging === true) {\n                    const p = this.controlPoints3dView.computeNewPosition(currentMousePosition.x, currentMousePosition.y);\n                    if (p !== null && this.selectedControlPoint !== null) {\n                        this.curveScene3dControler.setControlPointPosition(this.selectedControlPoint, p.x, p.y, p.z);\n                    }\n                }\n            }\n        }\n    }\n    mouseup(event) {\n        this.state = STATE.NONE;\n        this.dragging = false;\n    }\n    mouse_get_NormalizedDeviceCoordinates(event) {\n        const rect = this.canvas.getBoundingClientRect();\n        const w = parseInt(this.canvas.style.width, 10);\n        const h = parseInt(this.canvas.style.height, 10);\n        const x = ((event.clientX - rect.left) - w / 2) / (w / 2);\n        const y = (h / 2 - (event.clientY - rect.top)) / (h / 2);\n        return { x: x, y: y };\n    }\n    toggleControlOfCurvatureExtrema() {\n        this.curve3dModel.toggleActiveControlOfCurvatureExtrema();\n    }\n    toggleControlOfTorsionZeros() {\n        this.curve3dModel.toggleActiveControlOfTorsionZeros();\n    }\n}\nexports.CurveScene3dView = CurveScene3dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Inflections2dView = void 0;\nclass Inflections2dView {\n    constructor(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.freeControlPoints;\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    updateVerticesAndIndices() {\n        const size = 0.025;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (let i = 0; i < this.controlPoints.length; i += 1) {\n            let x = this.controlPoints[i].x;\n            let y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        let gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    update(spline) {\n        const splineDP = spline.getDifferentialProperties();\n        this.controlPoints = splineDP.inflections();\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    updateBuffers() {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n}\nexports.Inflections2dView = Inflections2dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Object3dShaders = void 0;\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass Object3dShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec3 a_Normal; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'uniform mat4 ModelViewProjectionMatrix; \\n' +\n            'uniform mat3 NormalMatrix; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '    normal = normalize(NormalMatrix * a_Normal); \\n' +\n            '    color = vec4(a_Color, 1); \\n' +\n            '    gl_Position = ModelViewProjectionMatrix * vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec3 Ambient; \\n' +\n            'uniform vec3 LightColor; \\n' +\n            'uniform vec3 LightDirection; \\n' +\n            'uniform vec3 HalfVector; \\n' +\n            'uniform float Shininess; \\n' +\n            'uniform float Strength; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '   float diffuse = abs(dot(normal, LightDirection)); \\n' +\n            '   float specular = abs(dot(normal, HalfVector)); \\n' +\n            '   specular = pow(specular, Shininess); \\n' +\n            '   vec3 scatteredLight = Ambient + LightColor*diffuse; \\n' +\n            '   vec3 reflectedLight = LightColor*specular*Strength; \\n' +\n            '   vec3 rgb = min(color.rgb*scatteredLight + reflectedLight, vec3(1.0)); \\n' +\n            '   gl_FragColor = vec4(rgb, color.a); \\n' +\n            '}\\n';\n        this.program = (0, cuon_utils_1.createProgram)(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfIndices) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfIndices, this.gl.UNSIGNED_SHORT, 0);\n    }\n}\nexports.Object3dShaders = Object3dShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Object3dShadowShaders = void 0;\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass Object3dShadowShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec3 a_Normal; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'uniform mat4 ModelViewProjectionMatrix; \\n' +\n            'uniform mat3 NormalMatrix; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '    normal = normalize(NormalMatrix * a_Normal); \\n' +\n            '    color = vec4(a_Color, 1.0); \\n' +\n            '    vec4 position = ModelViewProjectionMatrix * vec4(a_Position, 1.0); \\n' +\n            '    gl_Position = vec4(position.x, position.y*0.0 - 1.5, position.z, position.w); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec3 Ambient; \\n' +\n            'uniform vec3 LightColor; \\n' +\n            'uniform vec3 LightDirection; \\n' +\n            'uniform vec3 HalfVector; \\n' +\n            'uniform float Shininess; \\n' +\n            'uniform float Strength; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '   float diffuse = abs(dot(normal, LightDirection)); \\n' +\n            '   float specular = abs(dot(normal, HalfVector)); \\n' +\n            '   specular = pow(specular, Shininess); \\n' +\n            '   vec3 scatteredLight = Ambient + LightColor*diffuse; \\n' +\n            '   vec3 reflectedLight = LightColor*specular*Strength; \\n' +\n            '   vec3 rgb = min(color.rgb*scatteredLight + reflectedLight, vec3(1.0)); \\n' +\n            '   gl_FragColor = vec4(rgb, color.a); \\n' +\n            '   gl_FragColor = vec4(0.1, 0.1, 0.1, 1); \\n' +\n            '}\\n';\n        this.program = (0, cuon_utils_1.createProgram)(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfIndices) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfIndices, this.gl.UNSIGNED_SHORT, 0);\n    }\n}\nexports.Object3dShadowShaders = Object3dShadowShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RationalCurveScene2dView = void 0;\nconst ControlPointsShaders_1 = require(\"./ControlPointsShaders\");\nconst ControlPoints2dView_1 = require(\"./ControlPoints2dView\");\nconst ControlPolygon2dShaders_1 = require(\"./ControlPolygon2dShaders\");\nconst ControlPolygon2dView_1 = require(\"./ControlPolygon2dView\");\nconst Curve2dShaders_1 = require(\"./Curve2dShaders\");\nconst Curve2dView_1 = require(\"./Curve2dView\");\nconst CurvatureExtremaShaders_1 = require(\"./CurvatureExtremaShaders\");\nconst CurvatureExtrema2dView_1 = require(\"./CurvatureExtrema2dView\");\nconst Inflections2dView_1 = require(\"./Inflections2dView\");\nconst RationalCurveModel2d_1 = require(\"../models/RationalCurveModel2d\");\nconst RationalCurveScene2dController_1 = require(\"../controllers/RationalCurveScene2dController\");\nclass RationalCurveScene2dView {\n    constructor(canvas, gl, curveModel) {\n        this.canvas = canvas;\n        this.gl = gl;\n        this.curveModel = curveModel;\n        this.selectedControlPoint = null;\n        this.dragging = false;\n        this.curveShaders = new Curve2dShaders_1.Curve2dShaders(this.gl);\n        this.curveView = new Curve2dView_1.Curve2dView(this.curveModel.getSplineAdapter(), this.curveShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.controlPointsShaders = new ControlPointsShaders_1.ControlPointsShaders(this.gl);\n        this.controlPointsView = new ControlPoints2dView_1.ControlPoints2dView(this.curveModel.getSplineAdapter(), this.controlPointsShaders, 1, 1, 1);\n        this.controlPolygonShaders = new ControlPolygon2dShaders_1.ControlPolygon2dShaders(this.gl);\n        this.controlPolygonView = new ControlPolygon2dView_1.ControlPolygon2dView(this.curveModel.getSplineAdapter(), this.controlPolygonShaders, this.curveModel.isClosed, 216.0 / 255.0, 216.0 / 255.0, 216.0 / 255.0, 0.05);\n        this.curvatureExtremaShaders = new CurvatureExtremaShaders_1.CurvatureExtremaShaders(this.gl);\n        this.curvatureExtremaView = new CurvatureExtrema2dView_1.CurvatureExtrema2dView(this.curveModel.getSplineAdapter(), this.curvatureExtremaShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.inflectionsView = new Inflections2dView_1.Inflections2dView(this.curveModel.getSplineAdapter(), this.curvatureExtremaShaders, 216 / 255, 120 / 255, 120 / 255, 1);\n        this.curveModel.registerObserver(this.controlPointsView);\n        this.curveModel.registerObserver(this.controlPolygonView);\n        this.curveModel.registerObserver(this.curveView);\n        this.curveModel.registerObserver(this.curvatureExtremaView);\n        this.curveModel.registerObserver(this.inflectionsView);\n        this.curveSceneControler = new RationalCurveScene2dController_1.RationalCurveScene2dController(curveModel);\n        this.renderFrame();\n    }\n    renderFrame() {\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clearColor(0.27, 0.27, 0.27, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.curveView.renderFrame();\n        this.curvatureExtremaView.renderFrame();\n        this.inflectionsView.renderFrame();\n        this.controlPolygonView.renderFrame();\n        this.controlPointsView.renderFrame();\n    }\n    leftMouseDown_event(ndcX, ndcY, deltaSquared = 0.01) {\n        this.selectedControlPoint = this.controlPointsView.controlPointSelection(ndcX, ndcY, deltaSquared);\n        this.controlPointsView.setSelected(this.selectedControlPoint);\n        if (this.selectedControlPoint !== null) {\n            this.dragging = true;\n        }\n    }\n    leftMouseDragged_event(ndcX, ndcY) {\n        let x = ndcX, y = ndcY, selectedControlPoint = this.controlPointsView.getSelectedControlPoint();\n        if (selectedControlPoint != null && this.dragging === true) {\n            this.curveSceneControler.setControlPointPosition(selectedControlPoint, x, y);\n        }\n    }\n    leftMouseUp_event() {\n        this.dragging = false;\n    }\n    upArrow_event() {\n        if (this.selectedControlPoint !== null) {\n            this.curveModel.increaseControlPointWeight(this.selectedControlPoint);\n        }\n    }\n    downArrow_event() {\n        if (this.selectedControlPoint !== null) {\n            this.curveModel.decreaseControlPointWeight(this.selectedControlPoint);\n        }\n    }\n    addControlPoint() {\n        const cp = this.selectedControlPoint;\n        this.selectedControlPoint = null;\n        this.controlPointsView.setSelected(this.selectedControlPoint);\n        this.curveModel.addControlPoint(cp);\n        this.renderFrame();\n    }\n    toggleControlOfCurvatureExtrema() {\n        this.curveModel.toggleActiveControlOfCurvatureExtrema();\n    }\n    toggleControlOfInflections() {\n        this.curveModel.toggleActiveControlOfInflections();\n    }\n    selectCurveCategory(s) {\n        switch (s) {\n            case \"0\":\n                this.updateCurveModel(new RationalCurveModel2d_1.RationalCurveModel2d());\n                //this.updateCurveModel(new CurveModelQuasiNewton())\n                break;\n            /*\n        case \"1\":\n            //this.updateCurveModel(new ClosedCurveModelQuasiNewton())\n            this.updateCurveModel(new ClosedCurveModel())\n            break\n        case \"2\":\n            this.updateCurveModel(new CurveModelAlternative01())\n            break\n        case \"3\":\n            this.updateCurveModel(new ClosedCurveModelAlternative01())\n            break\n            */\n        }\n        //let toggleButtonCurvatureExtrema = <HTMLInputElement> document.getElementById(\"toggleButtonCurvatureExtrema\")\n        //let toggleButtonInflection = <HTMLInputElement> document.getElementById(\"toggleButtonInflections\")\n        //toggleButtonCurvatureExtrema.checked = true\n        //toggleButtonInflection.checked = true\n    }\n    updateCurveModel(curveModel) {\n        this.curveModel = curveModel;\n        this.curveModel.registerObserver(this.controlPointsView);\n        this.curveModel.registerObserver(this.controlPolygonView);\n        this.curveModel.registerObserver(this.curveView);\n        this.curveModel.registerObserver(this.curvatureExtremaView);\n        this.curveModel.registerObserver(this.inflectionsView);\n        this.curveSceneControler = new RationalCurveScene2dController_1.RationalCurveScene2dController(curveModel);\n        this.controlPolygonView.isClosed = this.curveModel.isClosed;\n        this.curveModel.notifyObservers();\n        this.renderFrame();\n    }\n}\nexports.RationalCurveScene2dView = RationalCurveScene2dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TorsionZeros3dView = void 0;\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst BaseObject3dView_1 = require(\"./BaseObject3dView\");\nconst BSplineR1toR3DifferentialProperties_1 = require(\"../bsplines/R1toR3/BSplineR1toR3DifferentialProperties\");\nconst ControlPoints3dView_1 = require(\"./ControlPoints3dView\");\nclass TorsionZeros3dView extends BaseObject3dView_1.BaseObject3dView {\n    constructor(spline, object3dShaders, lightDirection) {\n        super(object3dShaders, lightDirection);\n        this.spline = spline;\n        const splineDP = new BSplineR1toR3DifferentialProperties_1.BSplineR1toR3DifferentialProperties(spline);\n        this.zeros = splineDP.torsionZeros();\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.012;\n        const sectorCount = 50;\n        const stackCount = 50;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let zero of this.zeros) {\n            let v = (0, ControlPoints3dView_1.verticesForOneSphere)(zero, radius, sectorCount, stackCount, { red: 1, green: 0.75, blue: 0.75 });\n            let ind = (0, ControlPoints3dView_1.indicesForOneSphere)(startingIndex, sectorCount, stackCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = (0, ArrayConversion_1.toFloat32Array)(vertices);\n        this.indices = (0, ArrayConversion_1.toUint16Array)(indices);\n    }\n    updateVerticesIndicesAndBuffers() {\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    update(spline) {\n        this.spline = spline;\n        const splineDP = new BSplineR1toR3DifferentialProperties_1.BSplineR1toR3DifferentialProperties(spline);\n        this.zeros = splineDP.torsionZeros();\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.TorsionZeros3dView = TorsionZeros3dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Wire2dEventListenerRationalCurve = void 0;\nfunction Wire2dEventListenerRationalCurve(canvas, curveSceneView) {\n    var _a;\n    hideContextMenu();\n    function mouse_get_NormalizedDeviceCoordinates(event) {\n        const rect = canvas.getBoundingClientRect();\n        const w = parseInt(canvas.style.width, 10);\n        const h = parseInt(canvas.style.height, 10);\n        const x = ((event.clientX - rect.left) - w / 2) / (w / 2);\n        const y = (h / 2 - (event.clientY - rect.top)) / (h / 2);\n        return [x, y];\n    }\n    function touch_get_NormalizedDeviceCoordinates(event) {\n        var x, y, rect = canvas.getBoundingClientRect(), ev;\n        ev = event.touches[0];\n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2);\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2);\n        return [x, y];\n    }\n    function mouse_click(ev) {\n        hideContextMenu();\n        let c = mouse_get_NormalizedDeviceCoordinates(ev);\n        const mousePrecision = 0.0005;\n        curveSceneView.leftMouseDown_event(c[0], c[1], mousePrecision);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function mouse_drag(ev) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev);\n        curveSceneView.leftMouseDragged_event(c[0], c[1]);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function mouse_stop_drag(ev) {\n        curveSceneView.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    function touch_click(ev) {\n        let c = touch_get_NormalizedDeviceCoordinates(ev);\n        curveSceneView.leftMouseDown_event(c[0], c[1]);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function touch_drag(ev) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev);\n        curveSceneView.leftMouseDragged_event(c[0], c[1]);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function touch_stop_drag(ev) {\n        curveSceneView.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    function keyDown(ev) {\n        switch (ev.key) {\n            case \"ArrowUp\":\n                curveSceneView.upArrow_event();\n                curveSceneView.renderFrame();\n                ev.preventDefault();\n                break;\n            case \"ArrowDown\":\n                curveSceneView.downArrow_event();\n                curveSceneView.renderFrame();\n                ev.preventDefault();\n                break;\n        }\n    }\n    canvas.addEventListener('mousedown', mouse_click, false);\n    canvas.addEventListener('mousemove', mouse_drag, false);\n    canvas.addEventListener('mouseup', mouse_stop_drag, false);\n    canvas.addEventListener('touchstart', touch_click, false);\n    canvas.addEventListener('touchmove', touch_drag, false);\n    canvas.addEventListener('touchend', touch_stop_drag, false);\n    window.addEventListener('keydown', keyDown, false);\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\"touchstart\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchend\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchmove\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    function hideContextMenu() {\n        const cm = document.getElementById(\"contextMenu\");\n        if (cm) {\n            cm.style.display = \"none\";\n        }\n    }\n    function rightClick(e) {\n        e.preventDefault();\n        const cm = document.getElementById(\"contextMenu\");\n        if (cm) {\n            //cm.style.display = \"block\"\n            cm.style.left = e.pageX + \"px\";\n            cm.style.top = e.pageY + \"px\";\n            cm.style.display = \"block\";\n        }\n    }\n    function addControlPoint() {\n        hideContextMenu();\n        curveSceneView.addControlPoint();\n    }\n    (_a = document.getElementById(\"addControlPoint\")) === null || _a === void 0 ? void 0 : _a.addEventListener('click', addControlPoint);\n    canvas.addEventListener('contextmenu', rightClick, false);\n    function toggleControlOfCurvatureExtrema() {\n        curveSceneView.toggleControlOfCurvatureExtrema();\n    }\n    function toggleControlOfInflections() {\n        curveSceneView.toggleControlOfInflections();\n    }\n    function selectCurveCategory(event) {\n        curveSceneView.selectCurveCategory(event.detail.category);\n    }\n    let app = document.getElementsByTagName(\"app-curves-and-surfaces\")[0];\n    app.addEventListener(\"changeCurveCategory\", selectCurveCategory);\n    app.addEventListener(\"toogleControlOverCurvatureExtrema\", toggleControlOfCurvatureExtrema);\n    app.addEventListener(\"toogleControlOverInflections\", toggleControlOfInflections);\n}\nexports.Wire2dEventListenerRationalCurve = Wire2dEventListenerRationalCurve;\n","\"use strict\";\n//import { CurveSceneView } from \"./CurveSceneView\"\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wire3dEventListener = void 0;\nfunction wire3dEventListener(canvas, curveScene3dView) {\n    /*\n    hideContextMenu()\n\n    function hideContextMenu() {\n        const cm = document.getElementById(\"contextMenu\")\n        if (cm) {\n            cm.style.display = \"none\"\n        }\n    }\n    */\n    canvas.addEventListener('mousedown', (event) => {\n        curveScene3dView.mousedown(event);\n        event.preventDefault();\n        curveScene3dView.renderFrame();\n    });\n    canvas.addEventListener('mousemove', (event) => {\n        curveScene3dView.mousemove(event);\n        event.preventDefault();\n        curveScene3dView.renderFrame();\n    });\n    canvas.addEventListener('mouseup', (event) => {\n        curveScene3dView.mouseup(event);\n        event.preventDefault();\n        curveScene3dView.renderFrame();\n    });\n    /*\n    \n    function mouse_get_NormalizedDeviceCoordinates(event: MouseEvent) {\n        var x, y,\n            rect  = canvas.getBoundingClientRect(),\n            ev\n\n        ev = event\n        \n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2)\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2)\n        return [x, y]\n    }\n\n    function touch_get_NormalizedDeviceCoordinates(event: TouchEvent) {\n        var x, y,\n            rect  = canvas.getBoundingClientRect(),\n            ev;\n \n        ev = event.touches[0]\n        \n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2)\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2)\n        return [x, y]\n    }\n\n\n    function mouse_click(ev: MouseEvent) {\n        hideContextMenu()\n        let c = mouse_get_NormalizedDeviceCoordinates(ev)\n        const mousePrecision =  0.0005\n        curveSceneView.leftMouseDown_event(c[0], c[1], mousePrecision)\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n    }\n\n    function mouse_drag(ev: MouseEvent) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev)\n        curveSceneView.leftMouseDragged_event(c[0], c[1])\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n\n    }\n\n    function mouse_stop_drag(ev: MouseEvent) {\n        curveSceneView.leftMouseUp_event()\n        ev.preventDefault()\n    }\n\n    function touch_click(ev: TouchEvent) {\n        let c = touch_get_NormalizedDeviceCoordinates(ev)\n        curveSceneView.leftMouseDown_event(c[0], c[1])\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n    }\n\n    function touch_drag(ev: TouchEvent) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev)\n        curveSceneView.leftMouseDragged_event(c[0], c[1])\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n    }\n\n    function touch_stop_drag(ev: TouchEvent) {\n        curveSceneView.leftMouseUp_event()\n        ev.preventDefault()\n    }\n\n    canvas.addEventListener('mousedown', mouse_click, false)\n    canvas.addEventListener('mousemove', mouse_drag, false)\n    canvas.addEventListener('mouseup', mouse_stop_drag, false)\n    canvas.addEventListener('touchstart', touch_click, false)\n    canvas.addEventListener('touchmove', touch_drag, false)\n    canvas.addEventListener('touchend', touch_stop_drag, false)\n\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\"touchstart\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault()\n        }\n    }, false)\n    document.body.addEventListener(\"touchend\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault()\n        }\n    }, false)\n    document.body.addEventListener(\"touchmove\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault()\n        }\n    }, false)\n\n\n\n    function rightClick(e: MouseEvent) {\n        e.preventDefault()\n\n        const cm = document.getElementById(\"contextMenu\")\n        if (cm) {\n                //cm.style.display = \"block\"\n                cm.style.left = e.pageX + \"px\"\n                cm.style.top = e.pageY + \"px\"\n                cm.style.display = \"block\"\n        }\n    }\n\n    function addControlPoint() {\n        hideContextMenu()\n        curveSceneView.addControlPoint()\n    }\n\n    document.getElementById(\"addControlPoint\")?.addEventListener('click', addControlPoint)\n\n    canvas.addEventListener('contextmenu', rightClick, false)\n\n\n    let toggleButtonCurvatureExtrema = <HTMLButtonElement> document.getElementById(\"toggleButtonCurvatureExtrema\")\n    let toggleButtonInflection = <HTMLButtonElement> document.getElementById(\"toggleButtonInflections\")\n    \n\n    function toggleControlOfCurvatureExtrema() {\n        curveSceneView.toggleControlOfCurvatureExtrema()\n    }\n\n    function toggleControlOfInflections() {\n        curveSceneView.toggleControlOfInflections()\n    }\n\n\n    function selectCurveCategory(event: any) {\n        curveSceneView.selectCurveCategory(event.detail.category)\n    }\n\n    toggleButtonCurvatureExtrema.addEventListener('click', toggleControlOfCurvatureExtrema)\n    toggleButtonInflection.addEventListener('click', toggleControlOfInflections)\n\n    let app = document.getElementsByTagName(\"app-curves-and-surfaces\")[0]\n    app.addEventListener(\"changeCurveCategory\", selectCurveCategory)\n    */\n    function toggleControlOfCurvatureExtrema3d() {\n        curveScene3dView.toggleControlOfCurvatureExtrema();\n    }\n    function toggleControlOfTorsionZeros() {\n        curveScene3dView.toggleControlOfTorsionZeros();\n    }\n    let app = document.getElementsByTagName(\"app-curve-3d\")[0];\n    //app.addEventListener(\"changeCurveCategory\", selectCurveCategory)\n    app.addEventListener(\"toogleControlOverCurvatureExtrema3d\", toggleControlOfCurvatureExtrema3d);\n    app.addEventListener(\"toogleControlOverTorsionZeros\", toggleControlOfTorsionZeros);\n}\nexports.wire3dEventListener = wire3dEventListener;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppCurves3d = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <rounded-switch-torsion-zeros></rounded-switch-torsion-zeros>\n    <rounded-switch-curvature-extrema-3d></rounded-switch-curvature-extrema-3d>\n`;\n//import { CurveCategory } from \"./CurveCategory\"\nconst RoundedSwitchCurvatureExtrema3d_1 = require(\"./RoundedSwitchCurvatureExtrema3d\");\nconst RoundedSwitchTorsionZeros_1 = require(\"./RoundedSwitchTorsionZeros\");\nclass AppCurves3d extends HTMLElement {\n    constructor() {\n        super();\n        window.customElements.define('rounded-switch-torsion-zeros', RoundedSwitchTorsionZeros_1.RoundedSwitchTorsionZeros);\n        window.customElements.define('rounded-switch-curvature-extrema-3d', RoundedSwitchCurvatureExtrema3d_1.RoundedSwitchCurvatureExtrema3d);\n        //window.customElements.define('curve-category', CurveCategory)       \n        //window.customElements.define('copyright-years', CopyrightYears)\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n}\nexports.AppCurves3d = AppCurves3d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppCurvesAndSurfaces = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <rounded-switch-inflections></rounded-switch-inflections>\n    <rounded-switch-curvature-extrema></rounded-switch-curvature-extrema>\n    <curve-category></curve-category>\n`;\n//import { CopyrightYears } from \"./CopyrightYears\"\nconst CurveCategory_1 = require(\"./CurveCategory\");\nconst RoundedSwitchCurvatureExtrema_1 = require(\"./RoundedSwitchCurvatureExtrema\");\nconst RoundedSwitchInflections_1 = require(\"./RoundedSwitchInflections\");\nclass AppCurvesAndSurfaces extends HTMLElement {\n    constructor() {\n        super();\n        window.customElements.define('rounded-switch-inflections', RoundedSwitchInflections_1.RoundedSwitchInflections);\n        window.customElements.define('rounded-switch-curvature-extrema', RoundedSwitchCurvatureExtrema_1.RoundedSwitchCurvatureExtrema);\n        window.customElements.define('curve-category', CurveCategory_1.CurveCategory);\n        //window.customElements.define('copyright-years', CopyrightYears)\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n}\nexports.AppCurvesAndSurfaces = AppCurvesAndSurfaces;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CopyrightYears = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    .text_center {\n        text-align: center;\n        margin-bottom: 1cm;\n        color:rgb(100, 100, 100);\n        font-size: 80%;\n    }\n    </style>\n    <div class=\"text_center\" id=\"copyright\"></div>\n`;\nclass CopyrightYears extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n        let currentYear = new Date().getFullYear();\n        // \\u00A9: copyright symbol\n        this.shadowRoot.getElementById('copyright').innerText = \"\\u00A9\" + \" 2018-\" + currentYear;\n    }\n}\nexports.CopyrightYears = CopyrightYears;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CurveCategory = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n    }\n    #container {\n        text-align: center;\n        margin-bottom: 1%;\n    }\n    </style>\n    <div id=\"container\">\n    <p class=\"text_control_button\"> Curve Category: </p>\n        <select id=\"curve-category-selector\">\n            <option id= \"option1\" value=\"0\" selected=\"selected\"> Open </option>\n            <option id= \"option2\" value=\"1\" > Closed </option>\n            <!--\n            <option id= \"option3\" value=\"2\" > Alternative open planar </option>\n            <option id= \"option4\" value=\"3\" > Alternative closed planar </option>\n            -->\n        </select>\n    </div>\n`;\nclass CurveCategory extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('curve-category-selector').\n            addEventListener('change', this.categorySelected);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('curve-category-selector').\n            removeEventListener('change', this.categorySelected);\n    }\n    categorySelected(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"changeCurveCategory\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.CurveCategory = CurveCategory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RoundedSwitchCurvatureExtrema = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    body {\n        margin: 0;\n        padding: 0;\n        font-family:  'Open Sans', sans-serif;\n        background-color: rgb(230, 230, 230);}\n\n\n    .switch {\n        position: relative;\n        display: inline-block;\n        width: 60px;\n        height: 30px;\n      }\n    \n      .switch input {\n        opacity: 0;\n        width: 0;\n        height: 0;\n      }\n      \n      .slider {\n        position: absolute;\n        cursor: pointer;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      .slider:before {\n        position: absolute;\n        content: \"\";\n        height: 23px;\n        width: 23px;\n        left: 4px;\n        bottom: 4px;\n        background-color: white;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      input:checked + .slider {\n        background-color: rgb(130, 194, 141);\n      }\n      \n      input:focus + .slider {\n        box-shadow: 0 0 1px rgb(145, 182, 145);\n      }\n      \n      input:checked + .slider:before {\n        -webkit-transform: translateX(26px);\n        -ms-transform: translateX(26px);\n        transform: translateX(26px);\n      }\n      \n      .slider.round {\n        border-radius: 34px;\n      }\n      \n      .slider.round:before {\n        border-radius: 50%;\n      }\n\n      .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n        }\n    </style>\n\n    <div id=\"container\">\n        <center>  <p class=\"text_control_button\"> Curvature extrema </p> \n            <label class=\"switch\">\n            <input type=\"checkbox\"  checked id=\"toggleButtonCurvatureExtrema\">\n            <span class=\"slider round\"></span>\n            </label>\n        </center>\n    </div>\n`;\nclass RoundedSwitchCurvatureExtrema extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonCurvatureExtrema').\n            addEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonCurvatureExtrema').\n            removeEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    toogleControlOverCurvatureExtrema(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"toogleControlOverCurvatureExtrema\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.RoundedSwitchCurvatureExtrema = RoundedSwitchCurvatureExtrema;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RoundedSwitchCurvatureExtrema3d = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    body {\n        margin: 0;\n        padding: 0;\n        font-family:  'Open Sans', sans-serif;\n        background-color: rgb(230, 230, 230);}\n\n\n    .switch {\n        position: relative;\n        display: inline-block;\n        width: 60px;\n        height: 30px;\n      }\n    \n      .switch input {\n        opacity: 0;\n        width: 0;\n        height: 0;\n      }\n      \n      .slider {\n        position: absolute;\n        cursor: pointer;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      .slider:before {\n        position: absolute;\n        content: \"\";\n        height: 23px;\n        width: 23px;\n        left: 4px;\n        bottom: 4px;\n        background-color: white;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      input:checked + .slider {\n        background-color: rgb(130, 194, 141);\n      }\n      \n      input:focus + .slider {\n        box-shadow: 0 0 1px rgb(145, 182, 145);\n      }\n      \n      input:checked + .slider:before {\n        -webkit-transform: translateX(26px);\n        -ms-transform: translateX(26px);\n        transform: translateX(26px);\n      }\n      \n      .slider.round {\n        border-radius: 34px;\n      }\n      \n      .slider.round:before {\n        border-radius: 50%;\n      }\n\n      .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n        }\n    </style>\n\n    <div id=\"container\">\n        <center>  <p class=\"text_control_button\"> Curvature extrema </p> \n            <label class=\"switch\">\n            <input type=\"checkbox\"  checked id=\"toggleButtonCurvatureExtrema3d\">\n            <span class=\"slider round\"></span>\n            </label>\n        </center>\n    </div>\n`;\nclass RoundedSwitchCurvatureExtrema3d extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonCurvatureExtrema3d').\n            addEventListener('change', this.toogleControlOverCurvatureExtrema3d);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonCurvatureExtrema3d').\n            removeEventListener('change', this.toogleControlOverCurvatureExtrema3d);\n    }\n    toogleControlOverCurvatureExtrema3d(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"toogleControlOverCurvatureExtrema3d\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.RoundedSwitchCurvatureExtrema3d = RoundedSwitchCurvatureExtrema3d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RoundedSwitchInflections = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n\n    body {\n        margin: 0;\n        padding: 0;\n        font-family:  'Open Sans', sans-serif;\n        background-color: rgb(230, 230, 230);}\n\n\n    .switch {\n        position: relative;\n        display: inline-block;\n        width: 60px;\n        height: 30px;\n      }\n    \n      .switch input {\n        opacity: 0;\n        width: 0;\n        height: 0;\n      }\n      \n      .slider {\n        position: absolute;\n        cursor: pointer;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      .slider:before {\n        position: absolute;\n        content: \"\";\n        height: 23px;\n        width: 23px;\n        left: 4px;\n        bottom: 4px;\n        background-color: white;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      input:checked + .slider {\n        background-color: rgb(130, 194, 141);\n      }\n      \n      input:focus + .slider {\n        box-shadow: 0 0 1px rgb(145, 182, 145);\n      }\n      \n      input:checked + .slider:before {\n        -webkit-transform: translateX(26px);\n        -ms-transform: translateX(26px);\n        transform: translateX(26px);\n      }\n      \n      .slider.round {\n        border-radius: 34px;\n      }\n      \n      .slider.round:before {\n        border-radius: 50%;\n      }\n\n      .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n        }\n    </style>\n\n    <div id=\"container\">\n        <center>  <p class=\"text_control_button\"> Inflections </p>\n            <label class=\"switch\">\n            <input type=\"checkbox\" checked id=\"toggleButtonInflections\">\n            <span class=\"slider round\"></span>\n            </label>\n        </center>\n    </div>\n`;\nclass RoundedSwitchInflections extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonInflections').\n            addEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonInflections').\n            removeEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    toogleControlOverCurvatureExtrema(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"toogleControlOverInflections\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.RoundedSwitchInflections = RoundedSwitchInflections;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RoundedSwitchTorsionZeros = void 0;\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n\n    body {\n        margin: 0;\n        padding: 0;\n        font-family:  'Open Sans', sans-serif;\n        background-color: rgb(230, 230, 230);}\n\n\n    .switch {\n        position: relative;\n        display: inline-block;\n        width: 60px;\n        height: 30px;\n      }\n    \n      .switch input {\n        opacity: 0;\n        width: 0;\n        height: 0;\n      }\n      \n      .slider {\n        position: absolute;\n        cursor: pointer;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      .slider:before {\n        position: absolute;\n        content: \"\";\n        height: 23px;\n        width: 23px;\n        left: 4px;\n        bottom: 4px;\n        background-color: white;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      input:checked + .slider {\n        background-color: rgb(130, 194, 141);\n      }\n      \n      input:focus + .slider {\n        box-shadow: 0 0 1px rgb(145, 182, 145);\n      }\n      \n      input:checked + .slider:before {\n        -webkit-transform: translateX(26px);\n        -ms-transform: translateX(26px);\n        transform: translateX(26px);\n      }\n      \n      .slider.round {\n        border-radius: 34px;\n      }\n      \n      .slider.round:before {\n        border-radius: 50%;\n      }\n\n      .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n        }\n    </style>\n\n    <div id=\"container\">\n        <center>  <p class=\"text_control_button\"> Torsion Zeros </p>\n            <label class=\"switch\">\n            <input type=\"checkbox\" checked id=\"toggleButtonTorsionZeros\">\n            <span class=\"slider round\"></span>\n            </label>\n        </center>\n    </div>\n`;\nclass RoundedSwitchTorsionZeros extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonTorsionZeros').\n            addEventListener('change', this.toogleControlOverTorsionZeros);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonTorsionZeros').\n            removeEventListener('change', this.toogleControlOverTorsionZeros);\n    }\n    toogleControlOverTorsionZeros(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"toogleControlOverTorsionZeros\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.RoundedSwitchTorsionZeros = RoundedSwitchTorsionZeros;\n","\"use strict\";\n// Reference: cuon-utils.js\n// cuon-utils.js (c) 2012 kanda and matsuda\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProgram = void 0;\n/**\n * Create the linked program object\n * @param gl GL context\n * @param vshader a vertex shader program (string)\n * @param fshader a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n */\nfunction createProgram(gl, vshader, fshader) {\n    // Create shader object\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n    if (!vertexShader || !fragmentShader) {\n        console.log(\"createProgram was unable to produce a vertex or fragment shader\");\n        return null;\n    }\n    // Create a program object\n    var program = gl.createProgram();\n    if (!program) {\n        console.log(\"createProgram was unable to produce a program\");\n        return null;\n    }\n    // Attach the shader objects\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    // Link the program object\n    gl.linkProgram(program);\n    // Check the result of linking\n    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        const error = gl.getProgramInfoLog(program);\n        console.log('Failed to link program: ' + error);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n        return null;\n    }\n    return program;\n}\nexports.createProgram = createProgram;\n/**\n * Create a shader object\n * @param gl GL context\n * @param type the type of the shader object to be created\n * @param source shader program (string)\n * @return created shader object, or null if the creation has failed.\n */\nfunction loadShader(gl, type, source) {\n    const shader = gl.createShader(type);\n    if (shader == null) {\n        console.log('unable to create shader');\n        return null;\n    }\n    // Set the shader program\n    gl.shaderSource(shader, source);\n    // Compile the shader\n    gl.compileShader(shader);\n    // Check the result of compilation\n    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n        const error = gl.getShaderInfoLog(shader);\n        console.log('Failed to compile shader: ' + error);\n        gl.deleteShader(shader);\n        return null;\n    }\n    return shader;\n}\n","\"use strict\";\n//http://glmatrix.net/docs/mat4.js.html\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mat4_to_mat3 = void 0;\n/**\n * Copies the upper-left 3x3 values into a mat3.\n *\n * @param a   the source 4x4 matrix\n * @returns  3x3 matrix\n */\nfunction mat4_to_mat3(a) {\n    let result = new Float32Array(9);\n    result[0] = a[0];\n    result[1] = a[1];\n    result[2] = a[2];\n    result[3] = a[4];\n    result[4] = a[5];\n    result[5] = a[6];\n    result[6] = a[8];\n    result[7] = a[9];\n    result[8] = a[10];\n    return result;\n}\nexports.mat4_to_mat3 = mat4_to_mat3;\n","\"use strict\";\n//http://glmatrix.net/docs/mat4.js.html\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mat4_times_vec2 = exports.ortho = exports.translate = exports.multiply = exports.perspective = exports.lookAt = exports.fromQuat = exports.identity_mat4 = void 0;\nfunction identity_mat4() {\n    let result = new Float32Array(16);\n    result[0] = 1;\n    result[5] = 1;\n    result[10] = 1;\n    result[15] = 1;\n    return result;\n}\nexports.identity_mat4 = identity_mat4;\nfunction fromQuat(quaternion) {\n    let result = new Float32Array(16);\n    let x = quaternion[0], y = quaternion[1], z = quaternion[2], w = quaternion[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    result[0] = 1 - yy - zz;\n    result[1] = yx + wz;\n    result[2] = zx - wy;\n    result[3] = 0;\n    result[4] = yx - wz;\n    result[5] = 1 - xx - zz;\n    result[6] = zy + wx;\n    result[7] = 0;\n    result[8] = zx + wy;\n    result[9] = zy - wx;\n    result[10] = 1 - xx - yy;\n    result[11] = 0;\n    result[12] = 0;\n    result[13] = 0;\n    result[14] = 0;\n    result[15] = 1;\n    return result;\n}\nexports.fromQuat = fromQuat;\nfunction hypot(...args) {\n    var y = 0, i = args.length;\n    while (i--)\n        y += args[i] * args[i];\n    return Math.sqrt(y);\n}\nfunction lookAt(eye, center, up) {\n    let result = new Float32Array(16);\n    const EPSILON = 0.000001;\n    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n    let eyex = eye[0];\n    let eyey = eye[1];\n    let eyez = eye[2];\n    let upx = up[0];\n    let upy = up[1];\n    let upz = up[2];\n    let centerx = center[0];\n    let centery = center[1];\n    let centerz = center[2];\n    if (Math.abs(eyex - centerx) < EPSILON &&\n        Math.abs(eyey - centery) < EPSILON &&\n        Math.abs(eyez - centerz) < EPSILON) {\n        return identity_mat4();\n    }\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n    len = 1 / hypot(z0, z1, z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = hypot(x0, x1, x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    }\n    else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n    len = hypot(y0, y1, y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    }\n    else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n    result[0] = x0;\n    result[1] = y0;\n    result[2] = z0;\n    result[3] = 0;\n    result[4] = x1;\n    result[5] = y1;\n    result[6] = z1;\n    result[7] = 0;\n    result[8] = x2;\n    result[9] = y2;\n    result[10] = z2;\n    result[11] = 0;\n    result[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    result[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    result[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    result[15] = 1;\n    return result;\n}\nexports.lookAt = lookAt;\n/**\n * Generates a perspective projection matrix with the given bounds.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param fovy Vertical field of view in radians\n * @param aspect Aspect ratio. typically viewport width/height\n * @param  near Near bound of the frustum\n * @param  far Far bound of the frustum, can be null or Infinity\n * @returns projection matrix\n */\nfunction perspective(fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2), nf;\n    let result = new Float32Array(16);\n    result[0] = f / aspect;\n    result[1] = 0;\n    result[2] = 0;\n    result[3] = 0;\n    result[4] = 0;\n    result[5] = f;\n    result[6] = 0;\n    result[7] = 0;\n    result[8] = 0;\n    result[9] = 0;\n    result[11] = -1;\n    result[12] = 0;\n    result[13] = 0;\n    result[15] = 0;\n    if (far != null && far !== Infinity) {\n        nf = 1 / (near - far);\n        result[10] = (far + near) * nf;\n        result[14] = (2 * far * near) * nf;\n    }\n    else {\n        result[10] = -1;\n        result[14] = -2 * near;\n    }\n    return result;\n}\nexports.perspective = perspective;\n/**\n* Multiplies two mat4s\n*\n* @param  a the first operand\n* @param  b the second operand\n* @returns matrix\n*/\nfunction multiply(a, b) {\n    let result = new Float32Array(16);\n    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    // Cache only the current line of the second matrix\n    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    result[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    result[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    result[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    result[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return result;\n}\nexports.multiply = multiply;\n/**\n * Translate a mat4 by the given vector\n *\n * @param a the matrix to translate\n * @param v vector to translate by\n * @returns matrix\n */\nfunction translate(a, v) {\n    let result = new Float32Array(16);\n    const x = v[0], y = v[1], z = v[2];\n    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    result[0] = a00;\n    result[1] = a01;\n    result[2] = a02;\n    result[3] = a03;\n    result[4] = a10;\n    result[5] = a11;\n    result[6] = a12;\n    result[7] = a13;\n    result[8] = a20;\n    result[9] = a21;\n    result[10] = a22;\n    result[11] = a23;\n    result[12] = a00 * x + a10 * y + a20 * z + a[12];\n    result[13] = a01 * x + a11 * y + a21 * z + a[13];\n    result[14] = a02 * x + a12 * y + a22 * z + a[14];\n    result[15] = a03 * x + a13 * y + a23 * z + a[15];\n    return result;\n}\nexports.translate = translate;\n/**\n* Generates a orthogonal projection matrix with the given bounds\n*\n* @param  left Left bound of the frustum\n* @param  right Right bound of the frustum\n* @param  bottom Bottom bound of the frustum\n* @param  top Top bound of the frustum\n* @param  near Near bound of the frustum\n* @param far Far bound of the frustum\n* @return result mat4 frustum matrix\n*/\nfunction ortho(left, right, bottom, top, near, far) {\n    let result = new Float32Array(16);\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    result[0] = -2 * lr;\n    result[1] = 0;\n    result[2] = 0;\n    result[3] = 0;\n    result[4] = 0;\n    result[5] = -2 * bt;\n    result[6] = 0;\n    result[7] = 0;\n    result[8] = 0;\n    result[9] = 0;\n    result[10] = 2 * nf;\n    result[11] = 0;\n    result[12] = (left + right) * lr;\n    result[13] = (top + bottom) * bt;\n    result[14] = (far + near) * nf;\n    result[15] = 1;\n    return result;\n}\nexports.ortho = ortho;\n/**\n* Transforms the vec2 with a mat4\n* 3rd vector component is implicitly '0'\n* 4th vector component is implicitly '1'\n*\n* @param x, y the vector to transform\n* @param  m matrix to transform with\n* @returns newX, newY\n*/\nfunction mat4_times_vec2(m, x, y) {\n    const newX = m[0] * x + m[4] * y + m[12];\n    const newY = m[1] * x + m[5] * y + m[13];\n    return { x: newX, y: newY };\n}\nexports.mat4_times_vec2 = mat4_times_vec2;\n","\"use strict\";\n//http://glmatrix.net/docs/quat.js.html\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromEuler = exports.multiply_quats = exports.setAxisAngle = exports.identity_quat = void 0;\nfunction identity_quat() {\n    let result = new Float32Array(4);\n    result[3] = 1;\n    return result;\n}\nexports.identity_quat = identity_quat;\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param  axis the axis around which to rotate\n * @param  rad the angle in radians\n * @returns  result\n **/\nfunction setAxisAngle(axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    let result = new Float32Array([0, 0, 0, 0]);\n    result[0] = s * axis[0];\n    result[1] = s * axis[1];\n    result[2] = s * axis[2];\n    result[3] = Math.cos(rad);\n    return result;\n}\nexports.setAxisAngle = setAxisAngle;\n/**\n * Multiplies two quaternions\n *\n * @param  a the first quaternion operand\n * @param  b the second quaternion operand\n * @returns the resulting quaternion\n */\nfunction multiply_quats(a, b) {\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n    let result = new Float32Array([0, 0, 0, 0]);\n    result[0] = ax * bw + aw * bx + ay * bz - az * by;\n    result[1] = ay * bw + aw * by + az * bx - ax * bz;\n    result[2] = az * bw + aw * bz + ax * by - ay * bx;\n    result[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return result;\n}\nexports.multiply_quats = multiply_quats;\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param Angle to rotate around X axis in degrees.\n * @param Angle to rotate around Y axis in degrees.\n * @param Angle to rotate around Z axis in degrees.\n */\nfunction fromEuler(x, y, z) {\n    let result = new Float32Array([0, 0, 0, 0]);\n    let halfToRad = 0.5 * Math.PI / 180.0;\n    x *= halfToRad;\n    y *= halfToRad;\n    z *= halfToRad;\n    let sx = Math.sin(x);\n    let cx = Math.cos(x);\n    let sy = Math.sin(y);\n    let cy = Math.cos(y);\n    let sz = Math.sin(z);\n    let cz = Math.cos(z);\n    result[0] = sx * cy * cz - cx * sy * sz;\n    result[1] = cx * sy * cz + sx * cy * sz;\n    result[2] = cx * cy * sz - sx * sy * cz;\n    result[3] = cx * cy * cz + sx * sy * sz;\n    return result;\n}\nexports.fromEuler = fromEuler;\n","\"use strict\";\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebGLUtils = void 0;\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\nfunction WebGLUtils() {\n    /**\n     * Creates the HTLM for a failure message\n     * @param {string} canvasContainerId id of container of th\n     *        canvas.\n     * @return {string} The html.\n     */\n    var makeFailHTML = function (msg) {\n        return '' +\n            '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n        return '' +\n            '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n            '<td align=\"center\">' +\n            '<div style=\"display: table-cell; vertical-align: middle;\">' +\n            '<div style=\"\">' + msg + '</div>' +\n            '</div>' +\n            '</td></tr></table>';\n    };\n    /**\n     * Mesasge for getting a webgl browser\n     * @type {string}\n     */\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n    /**\n     * Mesasge for need better hardware\n     * @type {string}\n     */\n    var OTHER_PROBLEM = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n    /**\n     * Creates a webgl context. If creation fails it will\n     * change the contents of the container of the <canvas>\n     * tag to an error message with the correct links for WebGL.\n     * @param {Element} canvas. The canvas element to create a\n     *     context from.\n     * @param {WebGLContextCreationAttirbutes} opt_attribs Any\n     *     creation attributes you want to pass in.\n     * @param {function:(msg)} opt_onError An function to call\n     *     if there is an error during creation.\n     * @return {WebGLRenderingContext} The created context.\n     */\n    var setupWebGL = function (canvas, opt_attribs, opt_onError) {\n        function handleCreationError(msg) {\n            var container = document.getElementsByTagName(\"body\")[0];\n            //var container = canvas.parentNode;\n            if (container) {\n                var str = window.WebGLRenderingContext ?\n                    OTHER_PROBLEM :\n                    GET_A_WEBGL_BROWSER;\n                if (msg) {\n                    str += \"<br/><br/>Status: \" + msg;\n                }\n                container.innerHTML = makeFailHTML(str);\n            }\n        }\n        ;\n        opt_onError = opt_onError || handleCreationError;\n        if (canvas.addEventListener) {\n            canvas.addEventListener(\"webglcontextcreationerror\", function (event) {\n                opt_onError(event.statusMessage);\n            }, false);\n        }\n        var context = create3DContext(canvas, opt_attribs);\n        if (!context) {\n            if (!window.WebGLRenderingContext) {\n                opt_onError(\"\");\n            }\n            else {\n                opt_onError(\"\");\n            }\n        }\n        return context;\n    };\n    /**\n     * Creates a webgl context.\n     * @param {!Canvas} canvas The canvas tag to get context\n     *     from. If one is not passed in one will be created.\n     * @return {!WebGLContext} The created context.\n     */\n    var create3DContext = function (canvas, opt_attribs) {\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n        var context = null;\n        for (var ii = 0; ii < names.length; ++ii) {\n            try {\n                context = canvas.getContext(names[ii], opt_attribs);\n            }\n            catch (e) { }\n            if (context) {\n                break;\n            }\n        }\n        return context;\n    };\n    return {\n        create3DContext: create3DContext,\n        setupWebGL: setupWebGL\n    };\n}\nexports.WebGLUtils = WebGLUtils;\n/**\n * Provides requestAnimationFrame in a cross browser\n * way.\n */\nif (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            //window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\n                window.setTimeout(callback, 1000 / 60);\n            };\n    })();\n}\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.\n *\n * Cancels an animation frame request.\n * Checks for cross-browser support, falls back to clearTimeout.\n * @param {number}  Animation frame request. */\nif (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\n        //window.webkitCancelAnimationFrame || \n        window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\n        window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\n        window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\n        window.clearTimeout);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.main = void 0;\nconst webgl_utils_1 = require(\"./webgl/webgl-utils\");\nconst Curve2dModel_1 = require(\"./models/Curve2dModel\");\nconst AppCurvesAndSurfaces_1 = require(\"./webComponents/AppCurvesAndSurfaces\");\nconst CurveScene3dView_1 = require(\"./views/CurveScene3dView\");\nconst Wire3dEventListener_1 = require(\"./views/Wire3dEventListener\");\nconst CopyrightYears_1 = require(\"./webComponents/CopyrightYears\");\nconst CurveModel3d_1 = require(\"./models/CurveModel3d\");\nconst RationalCurveModel2d_1 = require(\"./models/RationalCurveModel2d\");\nconst RationalCurveScene2dView_1 = require(\"./views/RationalCurveScene2dView\");\nconst Wire2dEventListenerRationalCurve_1 = require(\"./views/Wire2dEventListenerRationalCurve\");\nconst AppCurve3d_1 = require(\"./webComponents/AppCurve3d\");\nfunction main() {\n    let canvas2d = document.getElementById(\"webgl\");\n    let canvas3d = document.getElementById(\"webgl2\");\n    let gl = (0, webgl_utils_1.WebGLUtils)().setupWebGL(canvas2d);\n    if (!gl) {\n        console.log('Failed to get the rendering context for WebGL');\n        return;\n    }\n    let gl2 = (0, webgl_utils_1.WebGLUtils)().setupWebGL(canvas3d);\n    if (!gl2) {\n        console.log('Failed to get the rendering context for WebGL');\n        return;\n    }\n    gl2.enable(gl.DEPTH_TEST);\n    let curveModel = new Curve2dModel_1.Curve2dModel();\n    let nurbsModel2d = new RationalCurveModel2d_1.RationalCurveModel2d;\n    //let curveSceneView = new CurveSceneView(canvas2d, gl, curveModel)\n    let curveSceneView = new RationalCurveScene2dView_1.RationalCurveScene2dView(canvas2d, gl, nurbsModel2d);\n    let curveModel3d = new CurveModel3d_1.CurveModel3d();\n    let curve3dSceneView = new CurveScene3dView_1.CurveScene3dView(canvas3d, gl2, curveModel3d);\n    curve3dSceneView.renderFrame();\n    window.customElements.define('app-curves-and-surfaces', AppCurvesAndSurfaces_1.AppCurvesAndSurfaces);\n    window.customElements.define('app-curve-3d', AppCurve3d_1.AppCurves3d);\n    window.customElements.define('copy-right-years', CopyrightYears_1.CopyrightYears);\n    //wireEventListener(canvas2d, curveSceneView)\n    (0, Wire2dEventListenerRationalCurve_1.Wire2dEventListenerRationalCurve)(canvas2d, curveSceneView);\n    (0, Wire3dEventListener_1.wire3dEventListener)(canvas3d, curve3dSceneView);\n}\nexports.main = main;\nmain();\n"],"names":[],"sourceRoot":""}