{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtOa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACpLhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;;;;;;;;;;AChGtC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,4BAA4B,8BAA8B;AAC1D;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACrLhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,gCAAgC,mBAAO,CAAC,wEAAyB;AACjE,uCAAuC,mBAAO,CAAC,sFAAgC;AAC/E,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;AC5HR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,gCAAgC,mBAAO,CAAC,wEAAyB;AACjE,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD,uCAAuC,mBAAO,CAAC,sFAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;ACjKf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sDAAsD,mBAAO,CAAC,oHAA+C;AAC7G,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;;;;;;;;;;ACZ9B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,gCAAgC,mBAAO,CAAC,wEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AChEf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,mBAAO,CAAC,oEAAuB;AAC7D,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;AC9Id;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;;;;;;;;;;ACpCtB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,gCAAgC,mBAAO,CAAC,wEAAyB;AACjE,uCAAuC,mBAAO,CAAC,sFAAgC;AAC/E,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AC9ChB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,gCAAgC,mBAAO,CAAC,wEAAyB;AACjE,wBAAwB,mBAAO,CAAC,wDAAiB;AACjD,kCAAkC,mBAAO,CAAC,4EAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA,4BAA4B,+CAA+C;AAC3E;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;;;ACpJvB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sDAAsD,mBAAO,CAAC,oHAA+C;AAC7G,gCAAgC,mBAAO,CAAC,wEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;;;;;;;;;;AC7BtC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,0CAA0C;AAC1C,4BAA4B,QAAQ;AACpC;AACA,kCAAkC;AAClC,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,wDAAwD,oBAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;ACvJZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;;;;;;;;;;;ACvP1D;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,kEAA2B;AAC3D,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,mDAAmD,mBAAO,CAAC,kIAA4C;AACvG,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+CAA+C,mCAAmC;AAClF;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;;;;;;;;;;ACrN3B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,mBAAO,CAAC,8EAAiC;AAClE,mDAAmD,mBAAO,CAAC,kIAA4C;AACvG,2CAA2C,mBAAO,CAAC,kHAAoC;AACvF;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;;;;;;;;;;;AC5EhD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,gCAAgC,mBAAO,CAAC,kFAAmC;AAC3E,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,mDAAmD,mBAAO,CAAC,kIAA4C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+CAA+C,mCAAmC;AAClF;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA,kBAAkB,MAAM,oBAAoB,EAAE,KAAK,WAAW;AAC9D,4BAA4B,KAAK;AACjC,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,kBAAkB,MAAM,oBAAoB,EAAE,KAAK,WAAW;AAC9D,4BAA4B,KAAK;AACjC,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,kBAAkB,MAAM,oBAAoB,EAAE,KAAK,WAAW;AAC9D,4BAA4B,KAAK;AACjC,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;;;;;;;;;;;AC3VnC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,gCAAgC,mBAAO,CAAC,kFAAmC;AAC3E,sBAAsB,mBAAO,CAAC,wEAA8B;AAC5D,mDAAmD,mBAAO,CAAC,kIAA4C;AACvG,0BAA0B,mBAAO,CAAC,gFAAkC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,+CAA+C,mCAAmC;AAClF;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA,kBAAkB,MAAM,oBAAoB,EAAE,KAAK,WAAW;AAC9D,4BAA4B,KAAK;AACjC,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,kBAAkB,MAAM,oBAAoB,EAAE,KAAK,WAAW;AAC9D,4BAA4B,KAAK;AACjC,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,kBAAkB,MAAM,oBAAoB,EAAE,KAAK,WAAW;AAC9D,4BAA4B,KAAK;AACjC,iEAAiE,MAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAA0C;AAC5F;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;;;;;;;;;;;ACtb9C;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;;;;;;;;;;ACVjB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;ACVf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACnGhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;AC1GN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC1ET;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,yBAAyB;AACzB;AACA,mBAAmB;AACnB;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,qBAAqB;AACrB,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,cAAc;AACd;;;;;;;;;;;AClHa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,mBAAO,CAAC,2DAAgB;AAC/C,sBAAsB,mBAAO,CAAC,yDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC1PT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC5LP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,mBAAO,CAAC,2DAAgB;AAC/C,yBAAyB,mBAAO,CAAC,+DAAkB;AACnD,oCAAoC,mBAAO,CAAC,qFAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AC5MV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,mBAAO,CAAC,0EAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;;;;;;;;ACdvB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;;;;;;;;;;;ACpED;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AC3EhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,mDAAmD,mBAAO,CAAC,gKAA0E;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AChHb;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,mBAAO,CAAC,kFAAmC;AAC3E,mDAAmD,mBAAO,CAAC,gKAA0E;AACrI,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD,6BAA6B,mBAAO,CAAC,gEAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;ACjEX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD,mDAAmD,mBAAO,CAAC,gKAA0E;AACrI,6BAA6B,mBAAO,CAAC,gEAAsB;AAC3D,gCAAgC,mBAAO,CAAC,kFAAmC;AAC3E,8DAA8D,mBAAO,CAAC,sLAAqF;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;;;;;;;;;;;AClJxB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,kEAA2B;AAC3D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,2CAA2C,mBAAO,CAAC,gJAAkE;AACrH,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD,6BAA6B,mBAAO,CAAC,gEAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;AC5DL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,kEAA2B;AAC3D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACzCP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,kEAA2B;AAC3D,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,+DAA+D,mBAAO,CAAC,wLAAsF;AAC7J,oBAAoB,mBAAO,CAAC,8DAAyB;AACrD,mDAAmD,mBAAO,CAAC,gKAA0E;AACrI,6BAA6B,mBAAO,CAAC,gEAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;ACnIlB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,mBAAO,CAAC,0EAAyB;AACjE,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,0BAA0B,mBAAO,CAAC,gFAAkC;AACpE,gCAAgC,mBAAO,CAAC,4FAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,QAAQ;AACxC,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;AC1NJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,mBAAO,CAAC,0EAA+B;AAC9D,oCAAoC,mBAAO,CAAC,oGAA4C;AACxF,gCAAgC,mBAAO,CAAC,4FAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;;;;;;;;;;ACjiBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;;;;;;;;;;ACpIrB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC,eAAe,mBAAO,CAAC,0CAAe;AACtC,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,uBAAuB,mBAAO,CAAC,0EAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;AC5Kf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACjBR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,qCAAqC,mBAAO,CAAC,+EAA8B;AAC3E,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,iCAAiC;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;;;;;;;;;;ACvCpB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D,kBAAkB,mBAAO,CAAC,gEAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA,0GAA0G,iCAAiC;AAC3I;AACA;AACA,0GAA0G,iCAAiC;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAsC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC,kDAAkD;AAClD;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,0CAA0C;AAC1C;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,oBAAoB,gBAAgB;AACpC,wCAAwC;AACxC,uCAAuC;AACvC,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;AC1Jd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,uCAAuC;AACvC,qCAAqC;AACrC,qCAAqC;AACrC,mCAAmC;AACnC,0BAA0B;AAC1B,wCAAwC;AACxC,oCAAoC;AACpC,sDAAsD;AACtD,cAAc;AACd;AACA,sDAAsD;AACtD,sCAAsC;AACtC,qCAAqC;AACrC,mCAAmC;AACnC,0BAA0B;AAC1B,0DAA0D;AAC1D,oEAAoE;AACpE,qDAAqD;AACrD,oDAAoD;AACpD,qCAAqC;AACrC,qEAAqE;AACrE,qEAAqE;AACrE,8DAA8D;AAC9D,8DAA8D;AAC9D,wDAAwD;AACxD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;ACjDf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;ACtKZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,qCAAqC,mBAAO,CAAC,+EAA8B;AAC3E,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;;;;;;;;;;AC7CrB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,yBAAyB,mBAAO,CAAC,wEAA8B;AAC/D,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sBAAsB;AACtB;AACA;AACA,gBAAgB;AAChB,mCAAmC;AACnC,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACvIhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,0BAA0B;AAC1B,sDAAsD;AACtD,cAAc;AACd;AACA,wDAAwD;AACxD,kCAAkC;AAClC,0BAA0B;AAC1B,wCAAwC;AACxC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AC3BhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;ACzHb;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,uCAAuC;AACvC,qCAAqC;AACrC,0BAA0B;AAC1B,wCAAwC;AACxC,sDAAsD;AACtD,cAAc;AACd;AACA,sDAAsD;AACtD,mCAAmC;AACnC,qCAAqC;AACrC,0BAA0B;AAC1B,oEAAoE;AACpE,2CAA2C;AAC3C,0CAA0C;AAC1C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;ACnClB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sDAAsD,mBAAO,CAAC,8HAAyD;AACvH,gCAAgC,mBAAO,CAAC,kFAAmC;AAC3E,wBAAwB,mBAAO,CAAC,kEAA2B;AAC3D,8CAA8C,mBAAO,CAAC,8GAAiD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;ACpKf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,qCAAqC,mBAAO,CAAC,+EAA8B;AAC3E,sBAAsB,mBAAO,CAAC,iDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;AChFZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,mBAAmB,mBAAO,CAAC,4DAAwB;AACnD,yBAAyB,mBAAO,CAAC,wEAA8B;AAC/D,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,gBAAgB;AAChB,mCAAmC;AACnC,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;;;;;;;;;;AChLxC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,0CAAe;AACtC,8BAA8B,mBAAO,CAAC,iEAAuB;AAC7D,oCAAoC,mBAAO,CAAC,6EAA6B;AACzE,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D,qCAAqC,mBAAO,CAAC,+EAA8B;AAC3E,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD,sBAAsB,mBAAO,CAAC,iDAAe;AAC7C,4BAA4B,mBAAO,CAAC,6DAAqB;AACzD,gCAAgC,mBAAO,CAAC,qEAAyB;AACjE,iCAAiC,mBAAO,CAAC,0FAAuC;AAChF;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB;;;;;;;;;;;AC7GX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,mBAAO,CAAC,sFAAqC;AAC5E,+BAA+B,mBAAO,CAAC,0EAA+B;AACtE,4BAA4B,mBAAO,CAAC,oEAA4B;AAChE,gCAAgC,mBAAO,CAAC,4EAAgC;AACxE,6BAA6B,mBAAO,CAAC,sEAA6B;AAClE,uBAAuB,mBAAO,CAAC,0DAAuB;AACtD,oBAAoB,mBAAO,CAAC,oDAAoB;AAChD,kCAAkC,mBAAO,CAAC,yEAA2B;AACrE,+BAA+B,mBAAO,CAAC,mEAAwB;AAC/D,0BAA0B,mBAAO,CAAC,gEAA0B;AAC5D,qBAAqB,mBAAO,CAAC,wDAAsB;AACnD,2BAA2B,mBAAO,CAAC,oEAA4B;AAC/D,kCAAkC,mBAAO,CAAC,kFAAmC;AAC7E,wCAAwC,mBAAO,CAAC,8FAAyC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;ACpHT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,0BAA0B;AAC1B,sDAAsD;AACtD,cAAc;AACd;AACA,wDAAwD;AACxD,kCAAkC;AAClC,0BAA0B;AAC1B,wCAAwC;AACxC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;AC3BP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACjHJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sDAAsD,mBAAO,CAAC,8HAAyD;AACvH,gCAAgC,mBAAO,CAAC,kFAAmC;AAC3E,wBAAwB,mBAAO,CAAC,kEAA2B;AAC3D,8CAA8C,mBAAO,CAAC,8GAAiD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACpKV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,sCAAsC;AACtC,qCAAqC;AACrC,qDAAqD;AACrD,wCAAwC;AACxC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,8DAA8D;AAC9D,2CAA2C;AAC3C,kFAAkF;AAClF,cAAc;AACd;AACA,wDAAwD;AACxD,mCAAmC;AACnC,sCAAsC;AACtC,0CAA0C;AAC1C,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;AACrC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,kEAAkE;AAClE,+DAA+D;AAC/D,qDAAqD;AACrD,oEAAoE;AACpE,oEAAoE;AACpE,sFAAsF;AACtF,mDAAmD;AACnD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;AChDV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,sDAAqB;AAClD;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,sCAAsC;AACtC,qCAAqC;AACrC,qDAAqD;AACrD,wCAAwC;AACxC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,8DAA8D;AAC9D,6CAA6C;AAC7C,oFAAoF;AACpF,+FAA+F;AAC/F,cAAc;AACd;AACA,wDAAwD;AACxD,mCAAmC;AACnC,sCAAsC;AACtC,0CAA0C;AAC1C,sCAAsC;AACtC,sCAAsC;AACtC,qCAAqC;AACrC,kCAAkC;AAClC,iCAAiC;AACjC,0BAA0B;AAC1B,kEAAkE;AAClE,+DAA+D;AAC/D,qDAAqD;AACrD,oEAAoE;AACpE,oEAAoE;AACpE,sFAAsF;AACtF,mDAAmD;AACnD,uDAAuD;AACvD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;AClDhB;AACb,WAAW,iBAAiB;AAC5B,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;;;AAIL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACzKd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;AChHZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,wBAAwB,mBAAO,CAAC,6DAAiB;AACjD,wCAAwC,mBAAO,CAAC,6FAAiC;AACjF,mCAAmC,mBAAO,CAAC,mFAA4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,4BAA4B;;;;;;;;;;;ACxBf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;ACxBT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,qBAAqB;;;;;;;;;;;ACnDR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,qCAAqC;;;;;;;;;;;AC/GxB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,gCAAgC;;;;;;;;;;;AChHnB;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrEa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACtBP;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB;;;;;;;;;;;ACpSV;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACvEJ;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,uCAAuC,YAAY,cAAc,gBAAgB,kBAAkB;AACnG;AACA,mDAAmD,aAAa,aAAa;AAC7E;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,eAAe,gCAAgC;AAC/C;AACA,eAAe,gBAAgB;AAC/B;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC7LA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,mBAAO,CAAC,uDAAqB;AACnD,yBAAyB,mBAAO,CAAC,6DAAwB;AACzD,qBAAqB,mBAAO,CAAC,uDAAqB;AAClD,4BAA4B,mBAAO,CAAC,mEAA2B;AAC/D,+BAA+B,mBAAO,CAAC,yFAAsC;AAC7E,2BAA2B,mBAAO,CAAC,iEAA0B;AAC7D,8BAA8B,mBAAO,CAAC,uEAA6B;AACnE,yBAAyB,mBAAO,CAAC,6EAAgC;AACjE,uBAAuB,mBAAO,CAAC,2DAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ","sources":["webpack://closed-curve/./src/bsplines/AbstractBSplineR1toR1.ts","webpack://closed-curve/./src/bsplines/AbstractBSplineR1toR2.ts","webpack://closed-curve/./src/bsplines/AbstractBSplineR1toR2DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/AbstractBSplineR1toR3.ts","webpack://closed-curve/./src/bsplines/BSplineR1toR1.ts","webpack://closed-curve/./src/bsplines/BSplineR1toR2.ts","webpack://closed-curve/./src/bsplines/BSplineR1toR2DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/BSplineR1toR3.ts","webpack://closed-curve/./src/bsplines/BernsteinDecompositionR1toR1.ts","webpack://closed-curve/./src/bsplines/BinomialCoefficient.ts","webpack://closed-curve/./src/bsplines/PeriodicBSplineR1toR1.ts","webpack://closed-curve/./src/bsplines/PeriodicBSplineR1toR2.ts","webpack://closed-curve/./src/bsplines/PeriodicBSplineR1toR2DifferentialProperties.ts","webpack://closed-curve/./src/bsplines/Piegl_Tiller_NURBS_Book.ts","webpack://closed-curve/./src/bsplinesOptimizationProblems/AbstractOptimizationProblemBSplineR1toR2.ts","webpack://closed-curve/./src/bsplinesOptimizationProblems/OptimizationProblemBSplineR1toR2.ts","webpack://closed-curve/./src/bsplinesOptimizationProblems/OptimizationProblemBSplineR1toR2WithWeigthingFactors.ts","webpack://closed-curve/./src/bsplinesOptimizationProblems/OptimizationProblemPeriodicBSplineR1toR2.ts","webpack://closed-curve/./src/bsplinesOptimizationProblems/OptimizationProblemPeriodicBSplineR1toR2QuasiNewton.ts","webpack://closed-curve/./src/controllers/CurveScene3dController.ts","webpack://closed-curve/./src/controllers/CurveSceneController.ts","webpack://closed-curve/./src/linearAlgebra/CholeskyDecomposition.ts","webpack://closed-curve/./src/linearAlgebra/DenseMatrix.ts","webpack://closed-curve/./src/linearAlgebra/DiagonalMatrix.ts","webpack://closed-curve/./src/linearAlgebra/LUSolve.ts","webpack://closed-curve/./src/linearAlgebra/MathVectorBasicOperations.ts","webpack://closed-curve/./src/linearAlgebra/SquareMatrix.ts","webpack://closed-curve/./src/linearAlgebra/SymmetricMatrix.ts","webpack://closed-curve/./src/mathVector/RotationMatrix.ts","webpack://closed-curve/./src/mathVector/Vector2d.ts","webpack://closed-curve/./src/mathVector/Vector3d.ts","webpack://closed-curve/./src/models/AbstractCurveModel.ts","webpack://closed-curve/./src/models/ClosedCurveModel.ts","webpack://closed-curve/./src/models/ClosedCurveModelAlternative01.ts","webpack://closed-curve/./src/models/CurveModel.ts","webpack://closed-curve/./src/models/CurveModel3d.ts","webpack://closed-curve/./src/models/CurveModelAlternative01.ts","webpack://closed-curve/./src/optimizers/Optimizer.ts","webpack://closed-curve/./src/optimizers/TrustRegionSubproblem.ts","webpack://closed-curve/./src/views/AbstractObject3dShadowView.ts","webpack://closed-curve/./src/views/AbstractObject3dView.ts","webpack://closed-curve/./src/views/ArrayConversion.ts","webpack://closed-curve/./src/views/ControlPoints3dShadowView.ts","webpack://closed-curve/./src/views/ControlPoints3dView.ts","webpack://closed-curve/./src/views/ControlPointsShaders.ts","webpack://closed-curve/./src/views/ControlPointsView.ts","webpack://closed-curve/./src/views/ControlPolygon3dShadowView.ts","webpack://closed-curve/./src/views/ControlPolygon3dView.ts","webpack://closed-curve/./src/views/ControlPolygonShaders.ts","webpack://closed-curve/./src/views/ControlPolygonView.ts","webpack://closed-curve/./src/views/CurvatureExtremaShaders.ts","webpack://closed-curve/./src/views/CurvatureExtremaView.ts","webpack://closed-curve/./src/views/Curve3dShadowView.ts","webpack://closed-curve/./src/views/Curve3dView.ts","webpack://closed-curve/./src/views/CurveScene3dView.ts","webpack://closed-curve/./src/views/CurveSceneView.ts","webpack://closed-curve/./src/views/CurveShaders.ts","webpack://closed-curve/./src/views/CurveView.ts","webpack://closed-curve/./src/views/InflectionsView.ts","webpack://closed-curve/./src/views/Object3dShaders.ts","webpack://closed-curve/./src/views/Object3dShadowShaders.ts","webpack://closed-curve/./src/views/Wire3dEventListener.ts","webpack://closed-curve/./src/views/WireEventListener.ts","webpack://closed-curve/./src/webComponents/AppCurvesAndSurfaces.ts","webpack://closed-curve/./src/webComponents/CopyrightYears.ts","webpack://closed-curve/./src/webComponents/CurveCategory.ts","webpack://closed-curve/./src/webComponents/RoundedSwitchCurvatureExtrema.ts","webpack://closed-curve/./src/webComponents/RoundedSwitchInflections.ts","webpack://closed-curve/./src/webgl/cuon-utils.ts","webpack://closed-curve/./src/webgl/mat3.ts","webpack://closed-curve/./src/webgl/mat4.ts","webpack://closed-curve/./src/webgl/quat.ts","webpack://closed-curve/./src/webgl/webgl-utils.ts","webpack://closed-curve/webpack/bootstrap","webpack://closed-curve/./src/main.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\n/**\n * A B-Spline function from a one dimensional real space to a one dimensional real space\n */\nclass AbstractBSplineR1toR1 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [0], knots = [0, 1]) {\n        this._controlPoints = [];\n        this._knots = [];\n        this._degree = 0;\n        this._controlPoints = [...controlPoints];\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    computeDegree() {\n        let degree = this._knots.length - this._controlPoints.length - 1;\n        if (degree < 0) {\n            throw new Error(\"Negative degree BSplineR1toR1 are not supported\");\n        }\n        return degree;\n    }\n    get controlPoints() {\n        return [...this._controlPoints];\n    }\n    set controlPoints(controlPoints) {\n        this._controlPoints = [...controlPoints];\n        this._degree = this.computeDegree();\n    }\n    get knots() {\n        return [...this._knots];\n    }\n    set knots(knots) {\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    get degree() {\n        return this._degree;\n    }\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    evaluate(u) {\n        const span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        const basis = Piegl_Tiller_NURBS_Book_1.basisFunctions(span, u, this._knots, this._degree);\n        let result = 0;\n        for (let i = 0; i < this._degree + 1; i += 1) {\n            result += basis[i] * this._controlPoints[span - this._degree + i];\n        }\n        return result;\n    }\n    distinctKnots() {\n        let result = [this._knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this._knots.length; i += 1) {\n            if (this._knots[i] !== temp) {\n                result.push(this._knots[i]);\n                temp = this._knots[i];\n            }\n        }\n        return result;\n    }\n    zeros(tolerance = 10e-8) {\n        //see : chapter 11 : Computing Zeros of Splines by Tom Lyche and Knut Morken for u_star method\n        let spline = this.clone();\n        let greville = [];\n        let maxError = tolerance * 2;\n        let vertexIndex = [];\n        let it = 0;\n        while (maxError > tolerance && it < 10e8) {\n            it += 1;\n            let maximum = 0;\n            let newKnots = [];\n            vertexIndex = findControlPointsFollowingSignChanges(spline);\n            greville = spline.grevilleAbscissae();\n            for (let v of vertexIndex) {\n                let uLeft = greville[v - 1];\n                let uRight = greville[v];\n                if (uRight - uLeft > maximum) {\n                    maximum = uRight - uLeft;\n                }\n                if (uRight - uLeft > tolerance) {\n                    let lineZero = this.robustFindLineZero(uLeft, spline.controlPoints[v - 1], uRight, spline.controlPoints[v]);\n                    newKnots.push(0.05 * (uLeft + uRight) / 2 + 0.95 * lineZero);\n                }\n            }\n            for (let knot of newKnots) {\n                spline.insertKnot(knot);\n            }\n            maxError = maximum;\n        }\n        vertexIndex = findControlPointsFollowingSignChanges(spline);\n        let result = [];\n        for (let v of vertexIndex) {\n            result.push(greville[v]);\n        }\n        return result;\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this._degree + 1; j += 1) {\n                sum += this._knots[j];\n            }\n            result.push(sum / this._degree);\n        }\n        return result;\n    }\n    insertKnot(u, times = 1) {\n        if (times <= 0) {\n            return;\n        }\n        let index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        let multiplicity = 0;\n        let newControlPoints = [];\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = this._controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - this._knots[i]) / (this._knots[i + this._degree] - this._knots[i]);\n                newControlPoints[i] = this._controlPoints[i - 1] * (1 - alpha) + this._controlPoints[i] * alpha;\n            }\n            for (let i = index - multiplicity; i < this._controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this._controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n        }\n    }\n    knotMultiplicity(indexFromFindSpan) {\n        let result = 0;\n        let i = 0;\n        while (this._knots[indexFromFindSpan + i] === this._knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    clamp(u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        let index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this._knots, this._degree);\n        let newControlPoints = [];\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        const times = this._degree - multiplicity + 1;\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = this._controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - this._knots[i]) / (this._knots[i + this._degree] - this._knots[i]);\n                newControlPoints[i] = this._controlPoints[i - 1] * (1 - alpha) + this._controlPoints[i] * alpha;\n            }\n            for (let i = index - multiplicity; i < this._controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this._controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    }\n    controlPolygonNumberOfSignChanges() {\n        let result = 0;\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            if (Math.sign(this._controlPoints[i]) !== Math.sign(this._controlPoints[i + 1])) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    controlPolygonZeros() {\n        let result = [];\n        let greville = this.grevilleAbscissae();\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            if (Math.sign(this._controlPoints[i]) !== Math.sign(this._controlPoints[i + 1])) {\n                result.push(this.findLineZero(greville[i], this._controlPoints[i], greville[i + 1], this._controlPoints[i + 1]));\n            }\n        }\n        return result;\n    }\n    findLineZero(x1, y1, x2, y2) {\n        // find the zero of the line y = ax + b\n        let a = (y2 - y1) / (x2 - x1);\n        let b = y1 - a * x1;\n        return -b / a;\n    }\n    robustFindLineZero(x1, y1, x2, y2) {\n        let result = this.findLineZero(x1, y1, x2, y2);\n        if (isNaN(result)) {\n            return x1;\n        }\n        return result;\n    }\n}\nexports.AbstractBSplineR1toR1 = AbstractBSplineR1toR1;\nfunction findControlPointsFollowingSignChanges(spline) {\n    let cpLeft = spline.controlPoints[0];\n    let vertexIndex = [];\n    for (let index = 1; index < spline.controlPoints.length; index += 1) {\n        let cpRight = spline.controlPoints[index];\n        if (cpLeft <= 0 && cpRight > 0) {\n            vertexIndex.push(index);\n        }\n        if (cpLeft >= 0 && cpRight < 0) {\n            vertexIndex.push(index);\n        }\n        cpLeft = cpRight;\n    }\n    if (spline.controlPoints[spline.controlPoints.length - 1] == 0) {\n        vertexIndex.push(spline.controlPoints.length - 1);\n    }\n    return vertexIndex;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass AbstractBSplineR1toR2 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector2d_1.Vector2d(0, 0)], knots = [0, 1]) {\n        this._controlPoints = deepCopyControlPoints(controlPoints);\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    computeDegree() {\n        let degree = this._knots.length - this._controlPoints.length - 1;\n        if (degree < 0) {\n            throw new Error(\"Negative degree BSplineR1toR1 are not supported\");\n        }\n        return degree;\n    }\n    get controlPoints() {\n        return deepCopyControlPoints(this._controlPoints);\n    }\n    set controlPoints(controlPoints) {\n        this._controlPoints = deepCopyControlPoints(controlPoints);\n    }\n    get knots() {\n        return [...this._knots];\n    }\n    set knots(knots) {\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    get degree() {\n        return this._degree;\n    }\n    getControlPoint(index) {\n        return this._controlPoints[index].clone();\n    }\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    evaluate(u) {\n        const span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        const basis = Piegl_Tiller_NURBS_Book_1.basisFunctions(span, u, this._knots, this._degree);\n        let result = new Vector2d_1.Vector2d(0, 0);\n        for (let i = 0; i < this._degree + 1; i += 1) {\n            result.x += basis[i] * this._controlPoints[span - this._degree + i].x;\n            result.y += basis[i] * this._controlPoints[span - this._degree + i].y;\n        }\n        return result;\n    }\n    getControlPointsX() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.x);\n        }\n        return result;\n    }\n    getControlPointsY() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.y);\n        }\n        return result;\n    }\n    getDistinctKnots() {\n        let result = [this._knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this._knots.length; i += 1) {\n            if (this._knots[i] !== temp) {\n                result.push(this._knots[i]);\n                temp = this._knots[i];\n            }\n        }\n        return result;\n    }\n    moveControlPoint(i, deltaX, deltaY) {\n        if (i < 0 || i >= this._controlPoints.length - this._degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        this._controlPoints[i].x += deltaX;\n        this._controlPoints[i].y += deltaY;\n    }\n    setControlPointPosition(index, value) {\n        this._controlPoints[index] = value;\n    }\n    insertKnot(u, times = 1) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        if (times <= 0) {\n            return;\n        }\n        let index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (let t = 0; t < times; t += 1) {\n            let newControlPoints = [];\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = this._controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - this._knots[i]) / (this._knots[i + this._degree] - this._knots[i]);\n                newControlPoints[i] = (this._controlPoints[i - 1].multiply(1 - alpha)).add(this._controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < this._controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this._controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    }\n    knotMultiplicity(indexFromFindSpan) {\n        let result = 0;\n        let i = 0;\n        while (this._knots[indexFromFindSpan + i] === this._knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this._degree + 1; j += 1) {\n                sum += this._knots[j];\n            }\n            result.push(sum / this._degree);\n        }\n        return result;\n    }\n    clamp(u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        let index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this._knots, this._degree);\n        let newControlPoints = [];\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        const times = this._degree - multiplicity + 1;\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = this._controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - this._knots[i]) / (this._knots[i + this._degree] - this._knots[i]);\n                newControlPoints[i] = (this._controlPoints[i - 1].multiply(1 - alpha)).add(this._controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < this._controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this._controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    }\n}\nexports.AbstractBSplineR1toR2 = AbstractBSplineR1toR2;\nfunction deepCopyControlPoints(controlPoints) {\n    let result = [];\n    for (let cp of controlPoints) {\n        result.push(cp.clone());\n    }\n    return result;\n}\nexports.deepCopyControlPoints = deepCopyControlPoints;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BSplineR1toR1_1 = require(\"./BSplineR1toR1\");\nclass AbstractBSplineR1toR2DifferentialProperties {\n    constructor(spline) {\n        this._spline = spline.clone();\n    }\n    expensiveComputation(spline) {\n        const sx = this.bSplineR1toR1Factory(spline.getControlPointsX(), spline.knots);\n        const sy = this.bSplineR1toR1Factory(spline.getControlPointsY(), spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const bdsxu = sxu.bernsteinDecomposition();\n        const bdsyu = syu.bernsteinDecomposition();\n        const bdsxuu = sxuu.bernsteinDecomposition();\n        const bdsyuu = syuu.bernsteinDecomposition();\n        const bdsxuuu = sxuuu.bernsteinDecomposition();\n        const bdsyuuu = syuuu.bernsteinDecomposition();\n        const h1 = (bdsxu.multiply(bdsxu)).add((bdsyu.multiply(bdsyu)));\n        const h2 = (bdsxu.multiply(bdsyuuu)).subtract((bdsyu.multiply(bdsxuuu)));\n        const h3 = (bdsxu.multiply(bdsxuu)).add((bdsyu.multiply(bdsyuu)));\n        const h4 = (bdsxu.multiply(bdsyuu)).subtract((bdsyu.multiply(bdsxuu)));\n        return {\n            h1: h1,\n            h2: h2,\n            h3: h3,\n            h4: h4\n        };\n    }\n    curvatureNumerator() {\n        const e = this.expensiveComputation(this._spline);\n        const distinctKnots = this._spline.getDistinctKnots();\n        const controlPoints = e.h4.flattenControlPointsArray();\n        const curvatureNumeratorDegree = 2 * this._spline.degree - 3;\n        let knots = [];\n        for (let knot of distinctKnots) {\n            for (let j = 0; j < curvatureNumeratorDegree + 1; j += 1) {\n                knots.push(knot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    h1() {\n        const e = this.expensiveComputation(this._spline);\n        const distinctKnots = this._spline.getDistinctKnots();\n        const controlPoints = e.h1.flattenControlPointsArray();\n        const h1Degree = 2 * this._spline.degree - 2;\n        let knots = [];\n        for (let knot of distinctKnots) {\n            for (let j = 0; j < h1Degree + 1; j += 1) {\n                knots.push(knot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    inflections(curvatureNumerator) {\n        if (!curvatureNumerator) {\n            curvatureNumerator = this.curvatureNumerator();\n        }\n        const zeros = curvatureNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        return result;\n    }\n    curvatureDerivativeNumerator() {\n        const e = this.expensiveComputation(this._spline);\n        const bd_curvatureDerivativeNumerator = (e.h1.multiply(e.h2)).subtract(e.h3.multiply(e.h4).multiplyByScalar(3));\n        const distinctKnots = this._spline.getDistinctKnots();\n        const controlPoints = bd_curvatureDerivativeNumerator.flattenControlPointsArray();\n        const curvatureDerivativeNumeratorDegree = 4 * this._spline.degree - 6;\n        let knots = [];\n        for (let knot of distinctKnots) {\n            for (let j = 0; j < curvatureDerivativeNumeratorDegree + 1; j += 1) {\n                knots.push(knot);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    curvatureExtrema(_curvatureDerivativeNumerator) {\n        if (!_curvatureDerivativeNumerator) {\n            _curvatureDerivativeNumerator = this.curvatureDerivativeNumerator();\n        }\n        const zeros = _curvatureDerivativeNumerator.zeros();\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        return result;\n    }\n}\nexports.AbstractBSplineR1toR2DifferentialProperties = AbstractBSplineR1toR2DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass AbstractBSplineR1toR3 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector3d_1.Vector3d(0, 0, 0)], knots = [0, 1]) {\n        this._controlPoints = deepCopyControlPoints(controlPoints);\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    computeDegree() {\n        let degree = this._knots.length - this._controlPoints.length - 1;\n        if (degree < 0) {\n            throw new Error(\"Negative degree BSplineR1toR1 are not supported\");\n        }\n        return degree;\n    }\n    get controlPoints() {\n        return deepCopyControlPoints(this._controlPoints);\n    }\n    set controlPoints(controlPoints) {\n        this._controlPoints = deepCopyControlPoints(controlPoints);\n    }\n    get knots() {\n        return [...this._knots];\n    }\n    set knots(knots) {\n        this._knots = [...knots];\n        this._degree = this.computeDegree();\n    }\n    get degree() {\n        return this._degree;\n    }\n    getControlPoint(index) {\n        return this._controlPoints[index].clone();\n    }\n    /**\n     * B-Spline evaluation\n     * @param u The parameter\n     * @returns the value of the B-Spline at u\n     */\n    evaluate(u) {\n        const span = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        const basis = Piegl_Tiller_NURBS_Book_1.basisFunctions(span, u, this._knots, this._degree);\n        let result = new Vector3d_1.Vector3d(0, 0, 0);\n        for (let i = 0; i < this._degree + 1; i += 1) {\n            result.x += basis[i] * this._controlPoints[span - this._degree + i].x;\n            result.y += basis[i] * this._controlPoints[span - this._degree + i].y;\n            result.z += basis[i] * this._controlPoints[span - this._degree + i].z;\n        }\n        return result;\n    }\n    getControlPointsX() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.x);\n        }\n        return result;\n    }\n    getControlPointsY() {\n        let result = [];\n        for (let cp of this._controlPoints) {\n            result.push(cp.y);\n        }\n        return result;\n    }\n    getDistinctKnots() {\n        let result = [this._knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this._knots.length; i += 1) {\n            if (this._knots[i] !== temp) {\n                result.push(this._knots[i]);\n                temp = this._knots[i];\n            }\n        }\n        return result;\n    }\n    moveControlPoint(i, deltaX, deltaY) {\n        if (i < 0 || i >= this._controlPoints.length - this._degree) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        this._controlPoints[i].x += deltaX;\n        this._controlPoints[i].y += deltaY;\n    }\n    setControlPointPosition(index, value) {\n        this._controlPoints[index] = value;\n    }\n    insertKnot(u, times = 1) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        if (times <= 0) {\n            return;\n        }\n        let index = Piegl_Tiller_NURBS_Book_1.findSpan(u, this._knots, this._degree);\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        for (let t = 0; t < times; t += 1) {\n            let newControlPoints = [];\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = this._controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - this._knots[i]) / (this._knots[i + this._degree] - this._knots[i]);\n                newControlPoints[i] = (this._controlPoints[i - 1].multiply(1 - alpha)).add(this._controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < this._controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this._controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    }\n    knotMultiplicity(indexFromFindSpan) {\n        let result = 0;\n        let i = 0;\n        while (this._knots[indexFromFindSpan + i] === this._knots[indexFromFindSpan]) {\n            i -= 1;\n            result += 1;\n            if (indexFromFindSpan + i < 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    grevilleAbscissae() {\n        let result = [];\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            let sum = 0;\n            for (let j = i + 1; j < i + this._degree + 1; j += 1) {\n                sum += this._knots[j];\n            }\n            result.push(sum / this._degree);\n        }\n        return result;\n    }\n    clamp(u) {\n        // Piegl and Tiller, The NURBS book, p: 151\n        let index = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(u, this._knots, this._degree);\n        let newControlPoints = [];\n        let multiplicity = 0;\n        if (u === this._knots[index]) {\n            multiplicity = this.knotMultiplicity(index);\n        }\n        const times = this._degree - multiplicity + 1;\n        for (let t = 0; t < times; t += 1) {\n            for (let i = 0; i < index - this._degree + 1; i += 1) {\n                newControlPoints[i] = this._controlPoints[i];\n            }\n            for (let i = index - this._degree + 1; i <= index - multiplicity; i += 1) {\n                let alpha = (u - this._knots[i]) / (this._knots[i + this._degree] - this._knots[i]);\n                newControlPoints[i] = (this._controlPoints[i - 1].multiply(1 - alpha)).add(this._controlPoints[i].multiply(alpha));\n            }\n            for (let i = index - multiplicity; i < this._controlPoints.length; i += 1) {\n                newControlPoints[i + 1] = this._controlPoints[i];\n            }\n            this._knots.splice(index + 1, 0, u);\n            this._controlPoints = newControlPoints.slice();\n            multiplicity += 1;\n            index += 1;\n        }\n    }\n}\nexports.AbstractBSplineR1toR3 = AbstractBSplineR1toR3;\nfunction deepCopyControlPoints(controlPoints) {\n    let result = [];\n    for (let cp of controlPoints) {\n        result.push(cp.clone());\n    }\n    return result;\n}\nexports.deepCopyControlPoints = deepCopyControlPoints;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst AbstractBSplineR1toR1_1 = require(\"./AbstractBSplineR1toR1\");\nconst BernsteinDecompositionR1toR1_1 = require(\"./BernsteinDecompositionR1toR1\");\nconst BSplineR1toR2_1 = require(\"./BSplineR1toR2\");\n/**\n * A B-Spline function from a one dimensional real space to a one dimensional real space\n */\nclass BSplineR1toR1 extends AbstractBSplineR1toR1_1.AbstractBSplineR1toR1 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [0], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    bernsteinDecomposition() {\n        // Piegl_Tiller_NURBS_Book.ts\n        return new BernsteinDecompositionR1toR1_1.BernsteinDecompositionR1toR1(Piegl_Tiller_NURBS_Book_1.decomposeFunction(this));\n    }\n    clone() {\n        return new BSplineR1toR1(this._controlPoints.slice(), this._knots.slice());\n    }\n    derivative() {\n        let newControlPoints = [];\n        let newKnots = [];\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            newControlPoints[i] = (this._controlPoints[i + 1] - (this._controlPoints[i])) * (this._degree / (this._knots[i + this._degree + 1] - this._knots[i + 1]));\n        }\n        newKnots = this._knots.slice(1, this._knots.length - 1);\n        return new BSplineR1toR1(newControlPoints, newKnots);\n    }\n    elevateDegree(times = 1) {\n        const bds = this.bernsteinDecomposition();\n        bds.elevateDegree();\n        const knots = this.distinctKnots();\n        const newSpline = BernsteinDecompositionR1toR1_1.splineRecomposition(bds, knots);\n        for (let i = 0; i < knots.length; i += 1) {\n            let m = this.knotMultiplicity(Piegl_Tiller_NURBS_Book_1.findSpan(knots[i], this.knots, this.degree));\n            for (let j = 0; j < newSpline.degree - m - 1; j += 1) {\n                newSpline.removeKnot(Piegl_Tiller_NURBS_Book_1.findSpan(newSpline.knots[i], newSpline.knots, newSpline.degree));\n            }\n        }\n        this.controlPoints = newSpline.controlPoints;\n        this.knots = newSpline.knots;\n        this._degree = newSpline.degree;\n    }\n    removeKnot(indexFromFindSpan, tolerance = 10e-5) {\n        //Piegl and Tiller, The NURBS book, p : 185\n        const index = indexFromFindSpan;\n        // end knots are not removed\n        if (index > this._degree && index < this.knots.length - this._degree - 1) {\n            throw new Error(\"index out of range\");\n        }\n        //const double tolerance = 1;\n        const multiplicity = this.knotMultiplicity(index);\n        const last = index - multiplicity;\n        const first = index - this.degree;\n        const offset = first - 1;\n        //std::vector<vectorType> local(2*degree+1);\n        let local = [];\n        local[0] = this.controlPoints[offset];\n        local[last + 1 - offset] = this.controlPoints[last + 1];\n        let i = first;\n        let j = last;\n        let ii = 1;\n        let jj = last - offset;\n        let removable = false;\n        // Compute new control point for one removal step\n        while (j > i) {\n            let alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i + this.degree + 1] - this.knots[i]);\n            let alpha_j = (this.knots[index] - this.knots[j]) / (this.knots[j + this.degree + 1] - this.knots[j]);\n            local[ii] = (this.controlPoints[i] - (local[ii - 1] * (1.0 - alpha_i))) / alpha_i;\n            local[jj] = (this.controlPoints[j] - (local[jj + 1] * (alpha_j))) / (1.0 - alpha_j);\n            ++i;\n            ++ii;\n            --j;\n            --jj;\n        }\n        if (j < i) {\n            if ((local[ii - 1] - (local[jj + 1])) <= tolerance) {\n                removable = true;\n            }\n        }\n        else {\n            const alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i + this.degree + 1] - this.knots[i]);\n            if (((this.controlPoints[i] - ((local[ii + 1] * (alpha_i)))) + (local[ii - 1] * (1.0 - alpha_i))) <= tolerance) {\n                removable = true;\n            }\n        }\n        if (removable == false)\n            return;\n        else {\n            let i = first;\n            let j = last;\n            while (j > i) {\n                this.controlPoints[i] = local[i - offset];\n                this.controlPoints[j] = local[j - offset];\n                ++i;\n                --j;\n            }\n        }\n        this.knots.splice(index, 1);\n        const fout = (2 * index - multiplicity - this.degree) / 2;\n        this._controlPoints.splice(fout, 1);\n    }\n    moveControlPoint(i, delta) {\n        if (i < 0 || i >= this.controlPoints.length) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        this.controlPoints[i] += delta;\n    }\n    curve() {\n        let x = this.grevilleAbscissae();\n        let cp = [];\n        for (let i = 0; i < x.length; i += 1) {\n            cp.push(new Vector2d_1.Vector2d(x[i], this._controlPoints[i]));\n        }\n        return new BSplineR1toR2_1.BSplineR1toR2(cp, this._knots.slice());\n    }\n}\nexports.BSplineR1toR1 = BSplineR1toR1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst AbstractBSplineR1toR2_1 = require(\"./AbstractBSplineR1toR2\");\nconst BSplineR1toR1_1 = require(\"./BSplineR1toR1\");\nconst BernsteinDecompositionR1toR1_1 = require(\"./BernsteinDecompositionR1toR1\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass BSplineR1toR2 extends AbstractBSplineR1toR2_1.AbstractBSplineR1toR2 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector2d_1.Vector2d(0, 0)], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    get freeControlPoints() {\n        return this.controlPoints;\n    }\n    /**\n     * Return a deep copy of this b-spline\n     */\n    clone() {\n        let cloneControlPoints = AbstractBSplineR1toR2_1.deepCopyControlPoints(this._controlPoints);\n        return new BSplineR1toR2(cloneControlPoints, this._knots.slice());\n    }\n    optimizerStep(step) {\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            this._controlPoints[i].x += step[i];\n            this._controlPoints[i].y += step[i + this._controlPoints.length];\n        }\n    }\n    /**\n     *\n     * @param fromU Parametric position where the section start\n     * @param toU Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    extract(fromU, toU) {\n        let spline = this.clone();\n        spline.clamp(fromU);\n        spline.clamp(toU);\n        const newFromSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(fromU, spline._knots, spline._degree);\n        const newToSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(toU, spline._knots, spline._degree);\n        let newKnots = [];\n        let newControlPoints = [];\n        for (let i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (let i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector2d_1.Vector2d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSplineR1toR2(newControlPoints, newKnots);\n    }\n    elevateDegree(times = 1) {\n        const sx = new BSplineR1toR1_1.BSplineR1toR1(this.getControlPointsX(), this.knots);\n        const sy = new BSplineR1toR1_1.BSplineR1toR1(this.getControlPointsY(), this.knots);\n        const bdsx = sx.bernsteinDecomposition();\n        const bdsy = sy.bernsteinDecomposition();\n        bdsx.elevateDegree();\n        bdsy.elevateDegree();\n        const knots = this.distinctKnots();\n        const sxNew = BernsteinDecompositionR1toR1_1.splineRecomposition(bdsx, knots);\n        const syNew = BernsteinDecompositionR1toR1_1.splineRecomposition(bdsy, knots);\n        let newcp = [];\n        for (let i = 0; i < sxNew.controlPoints.length; i += 1) {\n            newcp.push(new Vector2d_1.Vector2d(sxNew.controlPoints[i], syNew.controlPoints[i]));\n        }\n        let newSpline = new BSplineR1toR2(newcp, sxNew.knots);\n        for (let i = 0; i < knots.length; i += 1) {\n            let m = this.knotMultiplicity(Piegl_Tiller_NURBS_Book_1.findSpan(knots[i], this.knots, this.degree));\n            for (let j = 0; j < newSpline.degree - m - 1; j += 1) {\n                newSpline.removeKnot(Piegl_Tiller_NURBS_Book_1.findSpan(newSpline.knots[i], newSpline.knots, newSpline.degree));\n            }\n        }\n        this.controlPoints = newSpline.controlPoints;\n        this.knots = newSpline.knots;\n        this._degree = newSpline.degree;\n    }\n    removeKnot(indexFromFindSpan, tolerance = 10e-5) {\n        //Piegl and Tiller, The NURBS book, p : 185\n        const index = indexFromFindSpan;\n        // end knots are not removed\n        if (index > this._degree && index < this.knots.length - this._degree - 1) {\n            throw new Error(\"index out of range\");\n        }\n        //const double tolerance = 1;\n        const multiplicity = this.knotMultiplicity(index);\n        const last = index - multiplicity;\n        const first = index - this.degree;\n        const offset = first - 1;\n        //std::vector<vectorType> local(2*degree+1);\n        let local = [];\n        local[0] = this.controlPoints[offset];\n        local[last + 1 - offset] = this.controlPoints[last + 1];\n        let i = first;\n        let j = last;\n        let ii = 1;\n        let jj = last - offset;\n        let removable = false;\n        // Compute new control point for one removal step\n        while (j > i) {\n            let alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i + this.degree + 1] - this.knots[i]);\n            let alpha_j = (this.knots[index] - this.knots[j]) / (this.knots[j + this.degree + 1] - this.knots[j]);\n            local[ii] = (this.controlPoints[i].substract(local[ii - 1].multiply(1.0 - alpha_i))).multiply(1 / alpha_i);\n            local[jj] = (this.controlPoints[j].substract(local[jj + 1].multiply(alpha_j))).multiply(1 / (1.0 - alpha_j));\n            ++i;\n            ++ii;\n            --j;\n            --jj;\n        }\n        if (j < i) {\n            if ((local[ii - 1].substract(local[jj + 1])).norm() <= tolerance) {\n                removable = true;\n            }\n        }\n        else {\n            const alpha_i = (this.knots[index] - this.knots[i]) / (this.knots[i + this.degree + 1] - this.knots[i]);\n            if (((this.controlPoints[i].substract((local[ii + 1].multiply(alpha_i)))).add(local[ii - 1].multiply(1.0 - alpha_i))).norm() <= tolerance) {\n                removable = true;\n            }\n        }\n        if (removable == false)\n            return;\n        else {\n            let i = first;\n            let j = last;\n            while (j > i) {\n                this.controlPoints[i] = local[i - offset];\n                this.controlPoints[j] = local[j - offset];\n                ++i;\n                --j;\n            }\n        }\n        this.knots.splice(index, 1);\n        const fout = (2 * index - multiplicity - this.degree) / 2;\n        this._controlPoints.splice(fout, 1);\n    }\n    distinctKnots() {\n        let result = [this.knots[0]];\n        let temp = result[0];\n        for (let i = 1; i < this.knots.length; i += 1) {\n            if (this.knots[i] !== temp) {\n                result.push(this.knots[i]);\n                temp = this.knots[i];\n            }\n        }\n        return result;\n    }\n}\nexports.BSplineR1toR2 = BSplineR1toR2;\nfunction create_BSplineR1toR2(controlPoints, knots) {\n    let newControlPoints = [];\n    for (let cp of controlPoints) {\n        newControlPoints.push(new Vector2d_1.Vector2d(cp[0], cp[1]));\n    }\n    return new BSplineR1toR2(newControlPoints, knots);\n}\nexports.create_BSplineR1toR2 = create_BSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbstractBSplineR1toR2DifferentialProperties_1 = require(\"./AbstractBSplineR1toR2DifferentialProperties\");\nconst BSplineR1toR1_1 = require(\"./BSplineR1toR1\");\nclass BSplineR1toR2DifferentialProperties extends AbstractBSplineR1toR2DifferentialProperties_1.AbstractBSplineR1toR2DifferentialProperties {\n    constructor(spline) {\n        super(spline);\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n}\nexports.BSplineR1toR2DifferentialProperties = BSplineR1toR2DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst AbstractBSplineR1toR3_1 = require(\"./AbstractBSplineR1toR3\");\n/**\n * A B-Spline function from a one dimensional real space to a two dimensional real space\n */\nclass BSplineR1toR3 extends AbstractBSplineR1toR3_1.AbstractBSplineR1toR3 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector3d_1.Vector3d(0, 0, 0)], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    get freeControlPoints() {\n        return this.controlPoints;\n    }\n    /**\n     * Return a deep copy of this b-spline\n     */\n    clone() {\n        let cloneControlPoints = AbstractBSplineR1toR3_1.deepCopyControlPoints(this._controlPoints);\n        return new BSplineR1toR3(cloneControlPoints, this._knots.slice());\n    }\n    optimizerStep(step) {\n        for (let i = 0; i < this._controlPoints.length; i += 1) {\n            this._controlPoints[i].x += step[i];\n            this._controlPoints[i].y += step[i + this._controlPoints.length];\n        }\n    }\n    /**\n     *\n     * @param fromU Parametric position where the section start\n     * @param toU Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    extract(fromU, toU) {\n        let spline = this.clone();\n        spline.clamp(fromU);\n        spline.clamp(toU);\n        const newFromSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(fromU, spline._knots, spline._degree);\n        const newToSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(toU, spline._knots, spline._degree);\n        let newKnots = [];\n        let newControlPoints = [];\n        for (let i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (let i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector3d_1.Vector3d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSplineR1toR3(newControlPoints, newKnots);\n    }\n}\nexports.BSplineR1toR3 = BSplineR1toR3;\nfunction create_BSplineR1toR3(controlPoints, knots) {\n    let newControlPoints = [];\n    for (let cp of controlPoints) {\n        newControlPoints.push(new Vector3d_1.Vector3d(cp[0], cp[1], cp[2]));\n    }\n    return new BSplineR1toR3(newControlPoints, knots);\n}\nexports.create_BSplineR1toR3 = create_BSplineR1toR3;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BinomialCoefficient_1 = require(\"./BinomialCoefficient\");\nconst BSplineR1toR1_1 = require(\"./BSplineR1toR1\");\n/**\n* A Bernstein decomposition of a B-Spline function from a one dimensional real space to a one dimensional real space\n*/\nclass BernsteinDecompositionR1toR1 {\n    /**\n     *\n     * @param controlPointsArray An array of array of control points\n     */\n    constructor(controlPointsArray = []) {\n        this.controlPointsArray = controlPointsArray;\n    }\n    add(bd) {\n        let result = [];\n        for (let i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] + bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    subtract(bd) {\n        let result = [];\n        for (let i = 0; i < bd.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < bd.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] - bd.controlPointsArray[i][j];\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    multiply(bd) {\n        return new BernsteinDecompositionR1toR1(this.bernsteinMultiplicationArray(this.controlPointsArray, bd.controlPointsArray));\n    }\n    /**\n     *\n     * @param bd: BernsteinDecomposition_R1_to_R1\n     * @param index: Index of the basis function\n     */\n    multiplyRange(bd, start, lessThan) {\n        let result = [];\n        for (let i = start; i < lessThan; i += 1) {\n            result[i - start] = this.bernsteinMultiplication(this.controlPointsArray[i], bd.controlPointsArray[i]);\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    bernsteinMultiplicationArray(f, g) {\n        let result = [];\n        for (let i = 0; i < f.length; i += 1) {\n            result[i] = this.bernsteinMultiplication(f[i], g[i]);\n        }\n        return result;\n    }\n    bernsteinMultiplication(f, g) {\n        const f_degree = f.length - 1;\n        const g_degree = g.length - 1;\n        let result = [];\n        for (let k = 0; k < f_degree + g_degree + 1; k += 1) {\n            let cp = 0;\n            for (let i = Math.max(0, k - g_degree); i < Math.min(f_degree, k) + 1; i += 1) {\n                let bfu = BernsteinDecompositionR1toR1.binomial(f_degree, i);\n                let bgu = BernsteinDecompositionR1toR1.binomial(g_degree, k - i);\n                let bfugu = BernsteinDecompositionR1toR1.binomial(f_degree + g_degree, k);\n                cp += bfu * bgu / bfugu * f[i] * g[k - i];\n            }\n            result[k] = cp;\n        }\n        return result;\n    }\n    multiplyByScalar(value) {\n        let result = [];\n        for (let i = 0; i < this.controlPointsArray.length; i += 1) {\n            result[i] = [];\n            for (let j = 0; j < this.controlPointsArray[0].length; j += 1) {\n                result[i][j] = this.controlPointsArray[i][j] * value;\n            }\n        }\n        return new BernsteinDecompositionR1toR1(result);\n    }\n    flattenControlPointsArray() {\n        return this.controlPointsArray.reduce(function (acc, val) {\n            return acc.concat(val);\n        }, []);\n    }\n    subset(start, lessThan) {\n        return new BernsteinDecompositionR1toR1(this.controlPointsArray.slice(start, lessThan));\n    }\n    elevateDegree(times = 1) {\n        let newControlPointsArray = [];\n        for (let i = 0; i < this.controlPointsArray.length; i += 1) {\n            newControlPointsArray.push(this.elevateDegreeB(this.controlPointsArray[i], times));\n        }\n        this.controlPointsArray = newControlPointsArray;\n    }\n    elevateDegreeB(controlPoints, times = 1) {\n        const degree = controlPoints.length - 1;\n        let result = [];\n        for (let i = 0; i < controlPoints.length + times; i += 1) {\n            let cp = 0;\n            for (let j = Math.max(0, i - times); j <= Math.min(degree, i); j += 1) {\n                const bc0 = BinomialCoefficient_1.binomialCoefficient(times, i - j);\n                const bc1 = BinomialCoefficient_1.binomialCoefficient(degree, j);\n                const bc2 = BinomialCoefficient_1.binomialCoefficient(degree + times, i);\n                cp += bc0 * bc1 / bc2 * controlPoints[j];\n            }\n            result.push(cp);\n        }\n        return result;\n    }\n    splineRecomposition(distinctKnots) {\n        const cp = this.flattenControlPointsArray();\n        const degree = this.getDegree();\n        let knots = [];\n        for (let i = 0; i < distinctKnots.length; i += 1) {\n            for (let j = 0; j < degree + 1; j += 1) {\n                knots.push(distinctKnots[i]);\n            }\n        }\n        return new BSplineR1toR1_1.BSplineR1toR1(cp, knots);\n    }\n    getDegree() {\n        return this.controlPointsArray[0].length - 1;\n    }\n}\nexports.BernsteinDecompositionR1toR1 = BernsteinDecompositionR1toR1;\nBernsteinDecompositionR1toR1.binomial = BinomialCoefficient_1.memoizedBinomialCoefficient();\nBernsteinDecompositionR1toR1.flopsCounter = 0;\nfunction splineRecomposition(bernsteinDecomposiiton, distinctKnots) {\n    const cp = bernsteinDecomposiiton.flattenControlPointsArray();\n    const degree = bernsteinDecomposiiton.getDegree();\n    let knots = [];\n    for (let i = 0; i < distinctKnots.length; i += 1) {\n        for (let j = 0; j < degree + 1; j += 1) {\n            knots.push(distinctKnots[i]);\n        }\n    }\n    return new BSplineR1toR1_1.BSplineR1toR1(cp, knots);\n}\nexports.splineRecomposition = splineRecomposition;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction binomialCoefficient(n, k) {\n    let result = 1;\n    if (n < k || k < 0) {\n        return 0;\n    }\n    // take advantage of symmetry\n    if (k > n - k) {\n        k = n - k;\n    }\n    for (let x = n - k + 1; x <= n; x += 1) {\n        result *= x;\n    }\n    for (let x = 1; x <= k; x += 1) {\n        result /= x;\n    }\n    return result;\n}\nexports.binomialCoefficient = binomialCoefficient;\nfunction memoizedBinomialCoefficient() {\n    let cache = [];\n    return (n, k) => {\n        if (cache[n] !== undefined && cache[n][k] !== undefined) {\n            return cache[n][k];\n        }\n        else {\n            if (cache[n] === undefined) {\n                cache[n] = [];\n            }\n            const result = binomialCoefficient(n, k);\n            cache[n][k] = result;\n            return result;\n        }\n    };\n}\nexports.memoizedBinomialCoefficient = memoizedBinomialCoefficient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst AbstractBSplineR1toR1_1 = require(\"./AbstractBSplineR1toR1\");\nconst BernsteinDecompositionR1toR1_1 = require(\"./BernsteinDecompositionR1toR1\");\nconst BSplineR1toR1_1 = require(\"./BSplineR1toR1\");\nconst BSplineR1toR2_1 = require(\"./BSplineR1toR2\");\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\n/**\n * A B-Spline function from a one dimensional real periodic space to a one dimensional real space\n */\nclass PeriodicBSplineR1toR1 extends AbstractBSplineR1toR1_1.AbstractBSplineR1toR1 {\n    constructor(controlPoints = [0], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    bernsteinDecomposition() {\n        const s = this.clone();\n        const degree = this._degree;\n        s.clamp(s.knots[degree]);\n        s.clamp(s.knots[s.knots.length - degree - 1]);\n        const newControlPoints = s.controlPoints.slice(degree, s.controlPoints.length - degree);\n        const newKnots = s.knots.slice(degree, s.knots.length - degree);\n        //return decomposeFunction(new BSplineR1toR1(newControlPoints, newKnots))\n        return new BernsteinDecompositionR1toR1_1.BernsteinDecompositionR1toR1(Piegl_Tiller_NURBS_Book_1.decomposeFunction(new BSplineR1toR1_1.BSplineR1toR1(newControlPoints, newKnots)));\n    }\n    clone() {\n        return new PeriodicBSplineR1toR1(this._controlPoints.slice(), this._knots.slice());\n    }\n    derivative() {\n        let newControlPoints = [];\n        let newKnots = [];\n        for (let i = 0; i < this._controlPoints.length - 1; i += 1) {\n            newControlPoints[i] = (this._controlPoints[i + 1] - (this._controlPoints[i])) * (this._degree / (this._knots[i + this._degree + 1] - this._knots[i + 1]));\n        }\n        newKnots = this._knots.slice(1, this._knots.length - 1);\n        return new PeriodicBSplineR1toR1(newControlPoints, newKnots);\n    }\n    curve() {\n        let x = this.grevilleAbscissae();\n        let cp = [];\n        for (let i = 0; i < x.length; i += 1) {\n            cp.push(new Vector2d_1.Vector2d(x[i], this._controlPoints[i]));\n        }\n        return new BSplineR1toR2_1.BSplineR1toR2(cp, this._knots.slice());\n    }\n}\nexports.PeriodicBSplineR1toR1 = PeriodicBSplineR1toR1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst AbstractBSplineR1toR2_1 = require(\"./AbstractBSplineR1toR2\");\nconst BSplineR1toR2_1 = require(\"./BSplineR1toR2\");\nconst Piegl_Tiller_NURBS_Book_1 = require(\"./Piegl_Tiller_NURBS_Book\");\n/**\n * A B-Spline function from a one dimensional real periodic space to a two dimensional real space\n */\nclass PeriodicBSplineR1toR2 extends AbstractBSplineR1toR2_1.AbstractBSplineR1toR2 {\n    /**\n     * Create a B-Spline\n     * @param controlPoints The control points array\n     * @param knots The knot vector\n     */\n    constructor(controlPoints = [new Vector2d_1.Vector2d(0, 0)], knots = [0, 1]) {\n        super(controlPoints, knots);\n    }\n    get periodicControlPointsLength() {\n        return this._controlPoints.length - this._degree;\n    }\n    get freeControlPoints() {\n        let periodicControlPoints = [];\n        for (let i = 0; i < this.periodicControlPointsLength; i += 1) {\n            periodicControlPoints.push(this._controlPoints[i].clone());\n        }\n        return periodicControlPoints;\n    }\n    getClampSpline() {\n        const s = this.clone();\n        const degree = this._degree;\n        s.clamp(s.knots[degree]);\n        s.clamp(s.knots[s.knots.length - degree - 1]);\n        const newControlPoints = s.controlPoints.slice(degree, s.controlPoints.length - degree);\n        const newKnots = s.knots.slice(degree, s.knots.length - degree);\n        return new BSplineR1toR2_1.BSplineR1toR2(newControlPoints, newKnots);\n    }\n    /**\n     * Return a deep copy of this b-spline\n     */\n    clone() {\n        let cloneControlPoints = AbstractBSplineR1toR2_1.deepCopyControlPoints(this._controlPoints);\n        return new PeriodicBSplineR1toR2(cloneControlPoints, this._knots.slice());\n    }\n    optimizerStep(step) {\n        const n = this.periodicControlPointsLength;\n        for (let i = 0; i < n; i += 1) {\n            this.moveControlPoint(i, step[i], step[i + n]);\n        }\n    }\n    moveControlPoint(i, deltaX, deltaY) {\n        if (i < 0 || i >= this.periodicControlPointsLength) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        super.moveControlPoint(i, deltaX, deltaY);\n        let n = this.periodicControlPointsLength;\n        if (i < this.degree) {\n            super.setControlPointPosition(n + i, this.getControlPoint(i));\n        }\n    }\n    /**\n     *\n     * @param fromU Parametric position where the section start\n     * @param toU Parametric position where the section end\n     * @retrun the BSpline_R1_to_R2 section\n     */\n    extract(fromU, toU) {\n        let spline = this.clone();\n        spline.clamp(fromU);\n        spline.clamp(toU);\n        const newFromSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(fromU, spline._knots, spline._degree);\n        const newToSpan = Piegl_Tiller_NURBS_Book_1.clampingFindSpan(toU, spline._knots, spline._degree);\n        let newKnots = [];\n        let newControlPoints = [];\n        for (let i = newFromSpan - spline._degree; i < newToSpan + 1; i += 1) {\n            newKnots.push(spline._knots[i]);\n        }\n        for (let i = newFromSpan - spline._degree; i < newToSpan - spline._degree; i += 1) {\n            newControlPoints.push(new Vector2d_1.Vector2d(spline._controlPoints[i].x, spline._controlPoints[i].y));\n        }\n        return new BSplineR1toR2_1.BSplineR1toR2(newControlPoints, newKnots);\n    }\n    getDistinctKnots() {\n        const result = super.getDistinctKnots();\n        return result.slice(this.degree, result.length - this.degree);\n    }\n    setControlPointPosition(i, value) {\n        if (i < 0 || i >= this.periodicControlPointsLength) {\n            throw new Error(\"Control point indentifier is out of range\");\n        }\n        super.setControlPointPosition(i, value.clone());\n        if (i < this._degree) {\n            const j = this.periodicControlPointsLength + i;\n            super.setControlPointPosition(j, value.clone());\n        }\n    }\n    insertKnot(u) {\n        super.insertKnot(u, 1);\n        if (u < this._knots[2 * this._degree]) {\n            let newKnots = [];\n            let newControlPoints = [];\n            for (let i = 0; i < this._knots.length - 2 * this._degree; i += 1) {\n                newKnots.push(this._knots[i]);\n            }\n            const ui = newKnots[newKnots.length - 1];\n            for (let i = 1; i < 2 * this._degree + 1; i += 1) {\n                newKnots.push(ui + (this._knots[i] - this._knots[0]));\n            }\n            for (let i = 0; i < this._controlPoints.length - this._degree; i += 1) {\n                newControlPoints.push(new Vector2d_1.Vector2d(this._controlPoints[i].x, this._controlPoints[i].y));\n            }\n            for (let i = 0; i < this._degree; i += 1) {\n                newControlPoints.push(new Vector2d_1.Vector2d(this._controlPoints[i].x, this._controlPoints[i].y));\n            }\n            this._controlPoints = newControlPoints;\n            this._knots = newKnots;\n        }\n        if (u > this._knots[this._knots.length - 1 - 2 * this._degree]) {\n            let newKnots = [];\n            let newControlPoints = [];\n            const periodicIndex = this._knots.length - 1 - 2 * this._degree;\n            const ui = this._knots[periodicIndex];\n            for (let i = 0; i < 2 * this._degree; i += 1) {\n                newKnots.push(this._knots[1] + (this._knots[i + periodicIndex] - ui));\n            }\n            for (let i = 2 * this._degree; i < this._knots.length; i += 1) {\n                newKnots.push(this._knots[i]);\n            }\n            const cpi = this._controlPoints.length - this._degree;\n            for (let i = 0; i < this._degree; i += 1) {\n                newControlPoints.push(new Vector2d_1.Vector2d(this._controlPoints[cpi + i].x, this._controlPoints[cpi + i].y));\n            }\n            for (let i = this._degree; i < this._controlPoints.length; i += 1) {\n                newControlPoints.push(new Vector2d_1.Vector2d(this._controlPoints[i].x, this._controlPoints[i].y));\n            }\n            this._controlPoints = newControlPoints;\n            this._knots = newKnots;\n        }\n    }\n}\nexports.PeriodicBSplineR1toR2 = PeriodicBSplineR1toR2;\nfunction create_PeriodicBSplineR1toR2(controlPoints, knots) {\n    let newControlPoints = [];\n    for (let cp of controlPoints) {\n        newControlPoints.push(new Vector2d_1.Vector2d(cp[0], cp[1]));\n    }\n    return new PeriodicBSplineR1toR2(newControlPoints, knots);\n}\nexports.create_PeriodicBSplineR1toR2 = create_PeriodicBSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbstractBSplineR1toR2DifferentialProperties_1 = require(\"./AbstractBSplineR1toR2DifferentialProperties\");\nconst PeriodicBSplineR1toR1_1 = require(\"./PeriodicBSplineR1toR1\");\nclass PeriodicBSplineR1toR2DifferentialProperties extends AbstractBSplineR1toR2DifferentialProperties_1.AbstractBSplineR1toR2DifferentialProperties {\n    constructor(spline) {\n        super(spline);\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new PeriodicBSplineR1toR1_1.PeriodicBSplineR1toR1(controlPoints, knots);\n    }\n    curvatureExtrema(curvatureDerivativeNumerator) {\n        if (!curvatureDerivativeNumerator) {\n            curvatureDerivativeNumerator = this.curvatureDerivativeNumerator();\n        }\n        const zeros = curvatureDerivativeNumerator.zeros(10e-3);\n        let result = [];\n        for (let z of zeros) {\n            result.push(this._spline.evaluate(z));\n        }\n        const a = curvatureDerivativeNumerator.controlPoints[0];\n        const b = curvatureDerivativeNumerator.controlPoints[curvatureDerivativeNumerator.controlPoints.length - 1];\n        if (a * b < 0) { // a and b have different sign\n            const u = curvatureDerivativeNumerator.knots[curvatureDerivativeNumerator.knots.length - 1];\n            result.push(this._spline.evaluate(u));\n        }\n        return result;\n    }\n}\nexports.PeriodicBSplineR1toR2DifferentialProperties = PeriodicBSplineR1toR2DifferentialProperties;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i]  u < knots[i+1]\n */\nfunction findSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        console.log(\"u: \" + u);\n        console.log(\"knots: \" + knots);\n        console.log(\"degree: \" + degree);\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 2;\n    }\n    // Do binary search\n    let low = degree;\n    let high = knots.length - 1 - degree;\n    let i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.findSpan = findSpan;\n/**\n * Returns the span index used for clamping a periodic B-Spline\n * Note: The only difference with findSpan is the special case u = knots[-degree - 1]\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns span index i for which knots[i]  u < knots[i+1]\n */\nfunction clampingFindSpan(u, knots, degree) {\n    // Bibliographic reference : Piegl and Tiller, The NURBS book, p: 68\n    if (u < knots[degree] || u > knots[knots.length - degree - 1]) {\n        throw new Error(\"Error: parameter u is outside valid span\");\n    }\n    // Special case\n    if (u === knots[knots.length - degree - 1]) {\n        return knots.length - degree - 1;\n    }\n    // Do binary search\n    let low = degree;\n    let high = knots.length - 1 - degree;\n    let i = Math.floor((low + high) / 2);\n    while (!(knots[i] <= u && u < knots[i + 1])) {\n        if (u < knots[i]) {\n            high = i;\n        }\n        else {\n            low = i;\n        }\n        i = Math.floor((low + high) / 2);\n    }\n    return i;\n}\nexports.clampingFindSpan = clampingFindSpan;\n/**\n * Returns the basis functions values\n * @param span span index\n * @param u parameter\n * @param knots knot vector\n * @param degree degree\n * @returns the array of values evaluated at u\n */\nfunction basisFunctions(span, u, knots, degree) {\n    // Bibliographic reference : The NURBS BOOK, p.70\n    let result = [1];\n    let left = [];\n    let right = [];\n    for (let j = 1; j <= degree; j += 1) {\n        left[j] = u - knots[span + 1 - j];\n        right[j] = knots[span + j] - u;\n        let saved = 0.0;\n        for (let r = 0; r < j; r += 1) {\n            let temp = result[r] / (right[r + 1] + left[j - r]);\n            result[r] = saved + right[r + 1] * temp;\n            saved = left[j - r] * temp;\n        }\n        result[j] = saved;\n    }\n    return result;\n}\nexports.basisFunctions = basisFunctions;\n/**\n * Decompose a BSpline function into Bzier segments\n */\nfunction decomposeFunction(spline) {\n    //Piegl and Tiller, The NURBS book, p.173\n    let result = [];\n    const number_of_bezier_segments = spline.distinctKnots().length - 1;\n    for (let i = 0; i < number_of_bezier_segments; i += 1) {\n        result.push([]);\n    }\n    for (let i = 0; i <= spline.degree; i += 1) {\n        result[0][i] = spline.controlPoints[i];\n    }\n    let a = spline.degree;\n    let b = spline.degree + 1;\n    let bezier_segment = 0;\n    let alphas = [];\n    while (b < spline.knots.length - 1) {\n        let i = b;\n        while (b < spline.knots.length - 1 && spline.knots[b + 1] === spline.knots[b]) {\n            b += 1;\n        }\n        let mult = b - i + 1;\n        if (mult < spline.degree) {\n            let numer = spline.knots[b] - spline.knots[a]; // Numerator of alpha\n            // Compute and store alphas\n            for (let j = spline.degree; j > mult; j -= 1) {\n                alphas[j - mult - 1] = numer / (spline.knots[a + j] - spline.knots[a]);\n            }\n            let r = spline.degree - mult; // insert knot r times\n            for (let j = 1; j <= r; j += 1) {\n                let save = r - j;\n                let s = mult + j; // this many new controlPoints\n                for (let k = spline.degree; k >= s; k -= 1) {\n                    let alpha = alphas[k - s];\n                    result[bezier_segment][k] = (result[bezier_segment][k] * alpha) + (result[bezier_segment][k - 1] * (1 - alpha));\n                }\n                if (b < spline.knots.length) {\n                    result[bezier_segment + 1][save] = result[bezier_segment][spline.degree]; // next segment\n                }\n            }\n        }\n        bezier_segment += 1; // Bezier segment completed\n        if (b < spline.knots.length - 1) {\n            //initialize next bezier_segment\n            for (i = Math.max(0, spline.degree - mult); i <= spline.degree; i += 1) {\n                result[bezier_segment][i] = spline.controlPoints[b - spline.degree + i];\n            }\n            a = b;\n            b += 1;\n        }\n    }\n    return result;\n}\nexports.decomposeFunction = decomposeFunction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst DiagonalMatrix_1 = require(\"../linearAlgebra/DiagonalMatrix\");\nclass AbstractOptimizationProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = ActiveControl.curvatureExtrema) {\n        this.activeControl = activeControl;\n        this._hessian_f = undefined;\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        this.inflectionConstraintsSign = [];\n        this._inflectionInactiveConstraints = [];\n        this.curvatureExtremaConstraintsSign = [];\n        this._curvatureExtremaInactiveConstraints = [];\n        this._spline = initial.clone();\n        this._target = target.clone();\n        this.computeBasisFunctionsDerivatives();\n        this._numberOfIndependentVariables = this._spline.freeControlPoints.length * 2;\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        this._hessian_f0 = DiagonalMatrix_1.identityMatrix(this._numberOfIndependentVariables);\n        const e = this.expensiveComputation(this._spline);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        //this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g)\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        //this._inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator)\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        if (this._f.length !== this._gradient_f.shape[0]) {\n            throw new Error(\"Problem about f length and gradient_f shape in the optimization problem construtor\");\n        }\n    }\n    get inflectionInactiveConstraints() {\n        return this._inflectionInactiveConstraints;\n    }\n    get curvatureExtremaInactiveConstraints() {\n        return this._curvatureExtremaInactiveConstraints;\n    }\n    get numberOfIndependentVariables() {\n        return this._numberOfIndependentVariables;\n    }\n    get f0() {\n        return this._f0;\n    }\n    get gradient_f0() {\n        return this._gradient_f0;\n    }\n    get hessian_f0() {\n        return this._hessian_f0;\n    }\n    get numberOfConstraints() {\n        switch (this.activeControl) {\n            case ActiveControl.both: {\n                return this.inflectionConstraintsSign.length - this._inflectionInactiveConstraints.length + this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case ActiveControl.curvatureExtrema: {\n                return this.curvatureExtremaConstraintsSign.length - this._curvatureExtremaInactiveConstraints.length;\n            }\n            case ActiveControl.inflections: {\n                return this.inflectionConstraintsSign.length - this._inflectionInactiveConstraints.length;\n            }\n        }\n    }\n    get f() {\n        return this._f;\n    }\n    get gradient_f() {\n        return this._gradient_f;\n    }\n    get hessian_f() {\n        return this._hessian_f;\n    }\n    step(deltaX) {\n        this.spline.optimizerStep(deltaX);\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        const e = this.expensiveComputation(this._spline);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        //this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(this.curvatureExtremaConstraintsSign, g)\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        //this._inflectionInactiveConstraints = this.computeInactiveConstraints(this.inflectionConstraintsSign, curvatureNumerator)\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    fStep(step) {\n        let splineTemp = this.spline.clone();\n        splineTemp.optimizerStep(step);\n        let e = this.expensiveComputation(splineTemp);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        return this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n    }\n    f0Step(step) {\n        let splineTemp = this.spline.clone();\n        splineTemp.optimizerStep(step);\n        return this.compute_f0(this.compute_gradient_f0(splineTemp));\n    }\n    expensiveComputation(spline) {\n        const sx = this.bSplineR1toR1Factory(spline.getControlPointsX(), spline.knots);\n        const sy = this.bSplineR1toR1Factory(spline.getControlPointsY(), spline.knots);\n        const sxu = sx.derivative();\n        const syu = sy.derivative();\n        const sxuu = sxu.derivative();\n        const syuu = syu.derivative();\n        const sxuuu = sxuu.derivative();\n        const syuuu = syuu.derivative();\n        const bdsxu = sxu.bernsteinDecomposition();\n        const bdsyu = syu.bernsteinDecomposition();\n        const bdsxuu = sxuu.bernsteinDecomposition();\n        const bdsyuu = syuu.bernsteinDecomposition();\n        const bdsxuuu = sxuuu.bernsteinDecomposition();\n        const bdsyuuu = syuuu.bernsteinDecomposition();\n        const h1 = (bdsxu.multiply(bdsxu)).add(bdsyu.multiply(bdsyu));\n        const h2 = (bdsxu.multiply(bdsyuuu)).subtract(bdsyu.multiply(bdsxuuu));\n        const h3 = (bdsxu.multiply(bdsxuu)).add(bdsyu.multiply(bdsyuu));\n        const h4 = (bdsxu.multiply(bdsyuu)).subtract(bdsyu.multiply(bdsxuu));\n        return {\n            bdsxu: bdsxu,\n            bdsyu: bdsyu,\n            bdsxuu: bdsxuu,\n            bdsyuu: bdsyuu,\n            bdsxuuu: bdsxuuu,\n            bdsyuuu: bdsyuuu,\n            h1: h1,\n            h2: h2,\n            h3: h3,\n            h4: h4\n        };\n    }\n    compute_gradient_f0(spline) {\n        let result = [];\n        const n = spline.freeControlPoints.length;\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].x - this._target.freeControlPoints[i].x);\n        }\n        for (let i = 0; i < n; i += 1) {\n            result.push(spline.freeControlPoints[i].y - this._target.freeControlPoints[i].y);\n        }\n        return result;\n    }\n    compute_f0(gradient_f0) {\n        let result = 0;\n        const n = gradient_f0.length;\n        for (let i = 0; i < n; i += 1) {\n            result += Math.pow(gradient_f0[i], 2);\n        }\n        return 0.5 * result;\n    }\n    compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureDerivativeNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints(curvatureNumerator, constraintsSign, inactiveConstraints) {\n        let result = [];\n        for (let i = 0, j = 0, n = constraintsSign.length; i < n; i += 1) {\n            if (i === inactiveConstraints[j]) {\n                j += 1;\n            }\n            else {\n                result.push(curvatureNumerator[i] * constraintsSign[i]);\n            }\n        }\n        return result;\n    }\n    curvatureNumerator(h4) {\n        return h4.flattenControlPointsArray();\n    }\n    curvatureDerivativeNumerator(h1, h2, h3, h4) {\n        const g = (h1.multiply(h2)).subtract(h3.multiply(h4).multiplyByScalar(3));\n        return g.flattenControlPointsArray();\n    }\n    computeConstraintsSign(controlPoints) {\n        let result = [];\n        for (let i = 0, n = controlPoints.length; i < n; i += 1) {\n            if (controlPoints[i] > 0) {\n                result.push(-1);\n            }\n            else {\n                result.push(1);\n            }\n        }\n        return result;\n    }\n    compute_f(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            const r1 = this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const r2 = this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n            return r1.concat(r2);\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints(curvatureDerivativeNumerator, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints(curvatureNumerator, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n    compute_gradient_f(e, inflectionConstraintsSign, inflectionInactiveConstraints, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints) {\n        if (this.activeControl === ActiveControl.both) {\n            const m1 = this.compute_curvatureExtremaConstraints_gradient(e, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n            const m2 = this.compute_inflectionConstraints_gradient(e, inflectionConstraintsSign, inflectionInactiveConstraints);\n            const [row_m1, n] = m1.shape;\n            const [row_m2,] = m2.shape;\n            const m = row_m1 + row_m2;\n            let result = new DenseMatrix_1.DenseMatrix(m, n);\n            for (let i = 0; i < row_m1; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(i, j, m1.get(i, j));\n                }\n            }\n            for (let i = 0; i < row_m2; i += 1) {\n                for (let j = 0; j < n; j += 1) {\n                    result.set(row_m1 + i, j, m2.get(i, j));\n                }\n            }\n            return result;\n        }\n        else if (this.activeControl === ActiveControl.curvatureExtrema) {\n            return this.compute_curvatureExtremaConstraints_gradient(e, curvatureExtremaConstraintsSign, curvatureExtremaInactiveConstraints);\n        }\n        else {\n            return this.compute_inflectionConstraints_gradient(e, inflectionConstraintsSign, inflectionInactiveConstraints);\n        }\n    }\n}\nexports.AbstractOptimizationProblemBSplineR1toR2 = AbstractOptimizationProblemBSplineR1toR2;\nvar ActiveControl;\n(function (ActiveControl) {\n    ActiveControl[ActiveControl[\"curvatureExtrema\"] = 0] = \"curvatureExtrema\";\n    ActiveControl[ActiveControl[\"inflections\"] = 1] = \"inflections\";\n    ActiveControl[ActiveControl[\"both\"] = 2] = \"both\";\n})(ActiveControl = exports.ActiveControl || (exports.ActiveControl = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BSplineR1toR1_1 = require(\"../bsplines/BSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"./AbstractOptimizationProblemBSplineR1toR2\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nclass OptimizationProblemBSplineR1toR2 extends AbstractOptimizationProblemBSplineR1toR2_1.AbstractOptimizationProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial, activeControl);\n        this.activeControl = activeControl;\n    }\n    get spline() {\n        return this._spline;\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new BSplineR1toR1_1.BSplineR1toR1(controlPoints, knots);\n    }\n    setTargetSpline(spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n    }\n    /**\n     * Some contraints are set inactive to allowed the point of inflection or curvature extrema\n     * to slide along the curve.\n     **/\n    computeInactiveConstraints(controlPoints) {\n        let controlPointsSequences = this.extractChangingSignControlPointsSequences(controlPoints);\n        return this.extractControlPointsClosestToZero(controlPointsSequences);\n    }\n    extractChangingSignControlPointsSequences(controlPoints) {\n        let result = [];\n        let successiveControlPoints = [];\n        let i = 1;\n        while (i < controlPoints.length) {\n            successiveControlPoints = [];\n            if (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                successiveControlPoints.push({ index: i - 1, value: controlPoints[i - 1] });\n                successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                i += 1;\n                while (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                    successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                    i += 1;\n                }\n                result.push(successiveControlPoints);\n            }\n            i += 1;\n        }\n        return result;\n    }\n    extractControlPointsClosestToZero(polygonSegments) {\n        let result = [];\n        for (let polygonSegment of polygonSegments) {\n            let s = this.removeBiggest(polygonSegment);\n            for (let iv of s) {\n                result.push(iv.index);\n            }\n        }\n        return result;\n    }\n    removeBiggest(controlPointsSequence) {\n        let result = controlPointsSequence.slice();\n        let maxIndex = 0;\n        for (let i = 1; i < controlPointsSequence.length; i += 1) {\n            if (Math.pow(controlPointsSequence[i].value, 2) > Math.pow(controlPointsSequence[maxIndex].value, 2)) {\n                maxIndex = i;\n            }\n        }\n        result.splice(maxIndex, 1);\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const sxuuu = e.bdsxuuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        const syuuu = e.bdsyuuu;\n        const h1 = e.h1;\n        const h2 = e.h2;\n        const h3 = e.h3;\n        const h4 = e.h4;\n        let dgx = [];\n        let dgy = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const totalNumberOfConstraints = constraintsSign.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(sxu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(syuuu, start, lessThan);\n            let h7 = syu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan).multiplyByScalar(-1);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan);\n            let h9 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(syu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            let h7 = sxu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h9 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (4 * degree - 5);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (4 * degree - 5);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        let dgx = [];\n        let dgy = [];\n        const controlPointsLength = this.spline.controlPoints.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        const totalNumberOfConstraints = this.inflectionConstraintsSign.length;\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * controlPointsLength);\n        for (let i = 0; i < controlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (2 * degree - 2);\n            let lessThan = Math.min(controlPointsLength - degree, i + 1) * (2 * degree - 2);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, controlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    computeBasisFunctionsDerivatives() {\n        const n = this._spline.controlPoints.length;\n        this._numberOfIndependentVariables = n * 2;\n        let diracControlPoints = MathVectorBasicOperations_1.zeroVector(n);\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        for (let i = 0; i < n; i += 1) {\n            diracControlPoints[i] = 1;\n            let basisFunction = this.bSplineR1toR1Factory(diracControlPoints.slice(), this._spline.knots.slice());\n            let dBasisFunction_du = basisFunction.derivative();\n            let d2BasisFunction_du2 = dBasisFunction_du.derivative();\n            let d3BasisFunction_du3 = d2BasisFunction_du2.derivative();\n            this.dBasisFunctions_du.push(dBasisFunction_du.bernsteinDecomposition());\n            this.d2BasisFunctions_du2.push(d2BasisFunction_du2.bernsteinDecomposition());\n            this.d3BasisFunctions_du3.push(d3BasisFunction_du3.bernsteinDecomposition());\n            diracControlPoints[i] = 0;\n        }\n    }\n}\nexports.OptimizationProblemBSplineR1toR2 = OptimizationProblemBSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DiagonalMatrix_1 = require(\"../linearAlgebra/DiagonalMatrix\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"./AbstractOptimizationProblemBSplineR1toR2\");\nconst OptimizationProblemBSplineR1toR2_1 = require(\"./OptimizationProblemBSplineR1toR2\");\nclass OptimizationProblemBSplineR1toR2WithWeigthingFactors extends OptimizationProblemBSplineR1toR2_1.OptimizationProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial);\n        this.activeControl = activeControl;\n        this.weigthingFactors = [];\n        for (let i = 0; i < this.spline.freeControlPoints.length * 2; i += 1) {\n            this.weigthingFactors.push(1);\n        }\n        this.weigthingFactors[0] = 1000;\n        this.weigthingFactors[this.spline.freeControlPoints.length - 1] = 1000;\n        this.weigthingFactors[this.spline.freeControlPoints.length] = 1000;\n        this.weigthingFactors[this.weigthingFactors.length - 1] = 1000;\n    }\n    get f0() {\n        let result = 0;\n        const n = this._gradient_f0.length;\n        for (let i = 0; i < n; i += 1) {\n            result += Math.pow(this._gradient_f0[i], 2) * this.weigthingFactors[i];\n        }\n        return 0.5 * result;\n    }\n    get gradient_f0() {\n        let result = [];\n        const n = this._gradient_f0.length;\n        for (let i = 0; i < n; i += 1) {\n            result.push(this._gradient_f0[i] * this.weigthingFactors[i]);\n        }\n        return result;\n    }\n    get hessian_f0() {\n        const n = this._gradient_f0.length;\n        let result = new DiagonalMatrix_1.DiagonalMatrix(n);\n        for (let i = 0; i < n; i += 1) {\n            result.set(i, i, this.weigthingFactors[i]);\n        }\n        return result;\n    }\n    /**\n     * The objective function value: f0(x + step)\n     */\n    f0Step(step) {\n        let splineTemp = this.spline.clone();\n        splineTemp.optimizerStep(step);\n        const gradient = this.compute_gradient_f0(splineTemp);\n        const n = gradient.length;\n        let result = 0;\n        for (let i = 0; i < n; i += 1) {\n            result += Math.pow(gradient[i], 2) * this.weigthingFactors[i];\n        }\n        return 0.5 * result;\n    }\n}\nexports.OptimizationProblemBSplineR1toR2WithWeigthingFactors = OptimizationProblemBSplineR1toR2WithWeigthingFactors;\nclass OptimizationProblemBSplineR1toR2WithWeigthingFactorsNoInactiveConstraints extends OptimizationProblemBSplineR1toR2WithWeigthingFactors {\n    constructor(target, initial, activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial);\n        this.activeControl = activeControl;\n    }\n    computeInactiveConstraints(curvatureDerivativeNumerator) {\n        return [];\n    }\n}\nexports.OptimizationProblemBSplineR1toR2WithWeigthingFactorsNoInactiveConstraints = OptimizationProblemBSplineR1toR2WithWeigthingFactorsNoInactiveConstraints;\nclass OptimizationProblemBSplineR1toR2NoInactiveConstraints extends OptimizationProblemBSplineR1toR2_1.OptimizationProblemBSplineR1toR2 {\n    constructor(target, initial) {\n        super(target, initial);\n    }\n    computeInactiveConstraints(curvatureDerivativeNumerator) {\n        return [];\n    }\n}\nexports.OptimizationProblemBSplineR1toR2NoInactiveConstraints = OptimizationProblemBSplineR1toR2NoInactiveConstraints;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst PeriodicBSplineR1toR1_1 = require(\"../bsplines/PeriodicBSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"./AbstractOptimizationProblemBSplineR1toR2\");\nclass OptimizationProblemPeriodicBSplineR1toR2 extends AbstractOptimizationProblemBSplineR1toR2_1.AbstractOptimizationProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial, activeControl);\n        this.activeControl = activeControl;\n    }\n    get spline() {\n        return this._spline;\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new PeriodicBSplineR1toR1_1.PeriodicBSplineR1toR1(controlPoints, knots);\n    }\n    setTargetSpline(spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n    }\n    /**\n     * Some contraints are set inactive to allowed the point of inflection or curvature extrema\n     * to slide along the curve.\n     **/\n    computeInactiveConstraints(controlPoints) {\n        let controlPointsSequences = this.extractChangingSignControlPointsSequences(controlPoints);\n        let result = this.extractControlPointsClosestToZero(controlPointsSequences);\n        const firstCP = controlPoints[0];\n        const lastCP = controlPoints[controlPoints.length - 1];\n        if (firstCP * lastCP <= 0) {\n            if (Math.pow(firstCP, 2) <= Math.pow(lastCP, 2)) {\n                if (result[0] != 0) {\n                    result = [0].concat(result);\n                }\n            }\n            else {\n                if (result[result.length - 1] != controlPoints.length - 1) {\n                    result.push(controlPoints.length - 1);\n                }\n            }\n        }\n        return result;\n    }\n    extractChangingSignControlPointsSequences(controlPoints) {\n        let result = [];\n        let successiveControlPoints = [];\n        let i = 1;\n        while (i < controlPoints.length) {\n            successiveControlPoints = [];\n            if (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                successiveControlPoints.push({ index: i - 1, value: controlPoints[i - 1] });\n                successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                i += 1;\n                while (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                    successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                    i += 1;\n                }\n                result.push(successiveControlPoints);\n            }\n            i += 1;\n        }\n        return result;\n    }\n    extractControlPointsClosestToZero(polygonSegments) {\n        let result = [];\n        for (let polygonSegment of polygonSegments) {\n            let s = this.removeBiggest(polygonSegment);\n            for (let iv of s) {\n                result.push(iv.index);\n            }\n        }\n        return result;\n    }\n    removeBiggest(controlPointsSequence) {\n        let result = controlPointsSequence.slice();\n        let maxIndex = 0;\n        for (let i = 1; i < controlPointsSequence.length; i += 1) {\n            if (Math.pow(controlPointsSequence[i].value, 2) > Math.pow(controlPointsSequence[maxIndex].value, 2)) {\n                maxIndex = i;\n            }\n        }\n        result.splice(maxIndex, 1);\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const sxuuu = e.bdsxuuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        const syuuu = e.bdsyuuu;\n        const h1 = e.h1;\n        const h2 = e.h2;\n        const h3 = e.h3;\n        const h4 = e.h4;\n        let dgx = [];\n        let dgy = [];\n        const periodicControlPointsLength = this.spline.freeControlPoints.length;\n        const totalNumberOfConstraints = constraintsSign.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            // moved control point : i\n            // periodicControlPointsLength = n - degree (it is necessery to add degree cyclic control points, if we do not count them we have n - degree control points)\n            // Bernstein Decomposition index : [max(0, i - degree), min(n - degree, i + 1)]\n            // N_{j, d} is zero outside [u_{j}, u_{j + d + 1} )\n            // Dsu[j] = (N_{j, d})_u\n            // in terms of the set of Bernstein Decomposition N_{j, d} = 0 outside [max(0, i - d), min(n - d, i + 1)]\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(sxu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(syuuu, start, lessThan);\n            let h7 = syu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan).multiplyByScalar(-1);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan);\n            let h9 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(syu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            let h7 = sxu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h9 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * periodicControlPointsLength);\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (4 * degree - 5);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1) * (4 * degree - 5);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, periodicControlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        //Adding periodic term inside the Matrix\n        // The effect of the first control points over the constraints at the end\n        for (let i = 0; i < degree; i += 1) {\n            // moved control point : i\n            // Bernstein Decomposition index : [max(0, i - degree), min(n - degree, i + 1)]\n            // N_{j, d} is zero outside [u_{j}, u_{j + d + 1} )\n            // Dsu[j] = (N_{j, d})_u\n            // in terms of the set of Bernstein Decomposition N_{j, d} = 0 outside [max(0, i - d), min(n - d, i + 1)]\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(sxu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(syuuu, start, lessThan);\n            let h7 = syu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan).multiplyByScalar(-1);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan);\n            let h9 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = 0; i < degree; i += 1) {\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(syu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            let h7 = sxu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h9 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = periodicControlPointsLength; i < periodicControlPointsLength + degree; i += 1) {\n            // index i : moved control point + periodicControlPointsLength\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = (i - degree) * (4 * degree - 5);\n            let lessThan = (periodicControlPointsLength) * (4 * degree - 5);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i - periodicControlPointsLength, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        let dgx = [];\n        let dgy = [];\n        const periodicControlPointsLength = this.spline.freeControlPoints.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        const totalNumberOfConstraints = this.inflectionConstraintsSign.length;\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints - inactiveConstraints.length, 2 * periodicControlPointsLength);\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (2 * degree - 2);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1) * (2 * degree - 2);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, periodicControlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        //Adding periodic term inside the Matrix\n        // The effect of the first control points over the constraints at the end\n        for (let i = 0; i < degree; i += 1) {\n            // moved control point : i\n            // Bernstein Decomposition index : [max(0, i - degree), min(n - degree, i + 1)]\n            // N_{j, d} is zero outside [u_{j}, u_{j + d + 1} )\n            // Dsu[j] = (N_{j, d})_u\n            // in terms of the set of Bernstein Decomposition N_{j, d} = 0 outside [max(0, i - d), min(n - d, i + 1)]\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (let i = 0; i < degree; i += 1) {\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        for (let i = periodicControlPointsLength; i < periodicControlPointsLength + degree; i += 1) {\n            // index i : moved control point + periodicControlPointsLength\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (2 * degree - 2);\n            let lessThan = (periodicControlPointsLength) * (2 * degree - 2);\n            let deltaj = 0;\n            for (let inactiveConstraint of inactiveConstraints) {\n                if (inactiveConstraint >= start) {\n                    break;\n                }\n                deltaj += 1;\n            }\n            for (let j = start; j < lessThan; j += 1) {\n                if (j === inactiveConstraints[deltaj]) {\n                    deltaj += 1;\n                }\n                else {\n                    result.set(j - deltaj, i - periodicControlPointsLength, cpx[j - start] * constraintsSign[j]);\n                    result.set(j - deltaj, i, cpy[j - start] * constraintsSign[j]);\n                }\n            }\n        }\n        return result;\n    }\n    computeBasisFunctionsDerivatives() {\n        const n = this.spline.controlPoints.length;\n        const m = this.spline.freeControlPoints.length;\n        this._numberOfIndependentVariables = m * 2;\n        let diracControlPoints = MathVectorBasicOperations_1.zeroVector(n);\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        for (let i = 0; i < m; i += 1) {\n            diracControlPoints[i] = 1;\n            if (i < this.spline.degree) {\n                diracControlPoints[m + i] = 1;\n            }\n            let basisFunction = this.bSplineR1toR1Factory(diracControlPoints.slice(), this.spline.knots.slice());\n            let dBasisFunction_du = basisFunction.derivative();\n            let d2BasisFunction_du2 = dBasisFunction_du.derivative();\n            let d3BasisFunction_du3 = d2BasisFunction_du2.derivative();\n            this.dBasisFunctions_du.push(dBasisFunction_du.bernsteinDecomposition());\n            this.d2BasisFunctions_du2.push(d2BasisFunction_du2.bernsteinDecomposition());\n            this.d3BasisFunctions_du3.push(d3BasisFunction_du3.bernsteinDecomposition());\n            diracControlPoints[i] = 0;\n            if (i < this.spline.degree) {\n                diracControlPoints[m + i] = 0;\n            }\n        }\n    }\n}\nexports.OptimizationProblemPeriodicBSplineR1toR2 = OptimizationProblemPeriodicBSplineR1toR2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst PeriodicBSplineR1toR1_1 = require(\"../bsplines/PeriodicBSplineR1toR1\");\nconst DenseMatrix_1 = require(\"../linearAlgebra/DenseMatrix\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"./AbstractOptimizationProblemBSplineR1toR2\");\nconst SymmetricMatrix_1 = require(\"../linearAlgebra/SymmetricMatrix\");\nclass OptimizationProblemPeriodicBSplineR1toR2QuasiNewton extends AbstractOptimizationProblemBSplineR1toR2_1.AbstractOptimizationProblemBSplineR1toR2 {\n    constructor(target, initial, activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n        super(target, initial, activeControl);\n        this.activeControl = activeControl;\n        this.barrierHessianApproximation = [];\n        this.curvatureExtremaConstraintsHessians = [];\n        this.inflectionConstraintsHessians = [];\n        const totalNumberOfCurvatureExtremaConstraints = this.curvatureExtremaConstraintsSign.length;\n        const totalNumberOfInflectionConstraints = this.inflectionConstraintsSign.length;\n        const totalPossibleNumberOfConstraints = this.curvatureExtremaConstraintsSign.length + this.inflectionConstraintsSign.length;\n        const totalNumberOfActiveConstraints = totalPossibleNumberOfConstraints - this._inflectionInactiveConstraints.length - this._curvatureExtremaInactiveConstraints.length;\n        //this.previousGradient_f = new DenseMatrix(totalPossibleNumberOfConstraints, this.numberOfIndependentVariables)\n        this.previousCurvatureExtremaConstraintsGradient = new DenseMatrix_1.DenseMatrix(this.curvatureExtremaConstraintsSign.length, this.numberOfIndependentVariables);\n        this.currentCurvatureExtremaConstraintsGradient = this.previousCurvatureExtremaConstraintsGradient;\n        this.previousInflectionConstraintsGradient = new DenseMatrix_1.DenseMatrix(this.inflectionConstraintsSign.length, this.numberOfIndependentVariables);\n        this.currentInflectionConstraintsGradient = this.previousInflectionConstraintsGradient;\n        for (let i = 0; i < totalNumberOfActiveConstraints; i += 1) {\n            this.barrierHessianApproximation.push(new SymmetricMatrix_1.SymmetricMatrix(this.gradient_f.shape[1]));\n        }\n        for (let i = 0; i < totalNumberOfCurvatureExtremaConstraints; i += 1) {\n            this.curvatureExtremaConstraintsHessians.push(new SymmetricMatrix_1.SymmetricMatrix(this.gradient_f.shape[1]));\n        }\n        for (let i = 0; i < totalNumberOfInflectionConstraints; i += 1) {\n            this.inflectionConstraintsHessians.push(new SymmetricMatrix_1.SymmetricMatrix(this.gradient_f.shape[1]));\n        }\n    }\n    get spline() {\n        return this._spline;\n    }\n    get hessian_f() {\n        //return undefined\n        return this.barrierHessianApproximation.slice(0, this._f.length);\n    }\n    bSplineR1toR1Factory(controlPoints, knots) {\n        return new PeriodicBSplineR1toR1_1.PeriodicBSplineR1toR1(controlPoints, knots);\n    }\n    setTargetSpline(spline) {\n        this._target = spline.clone();\n        this._gradient_f0 = this.compute_gradient_f0(this.spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n    }\n    /**\n     * Some contraints are set inactive to allowed the point of inflection or curvature extrema\n     * to slide along the curve.\n     **/\n    computeInactiveConstraints(controlPoints) {\n        //return [] \n        let controlPointsSequences = this.extractChangingSignControlPointsSequences(controlPoints);\n        let result = this.extractControlPointsClosestToZero(controlPointsSequences);\n        const firstCP = controlPoints[0];\n        const lastCP = controlPoints[controlPoints.length - 1];\n        if (firstCP * lastCP <= 0) {\n            if (Math.pow(firstCP, 2) <= Math.pow(lastCP, 2)) {\n                if (result[0] != 0) {\n                    result = [0].concat(result);\n                }\n            }\n            else {\n                if (result[result.length - 1] != controlPoints.length - 1) {\n                    result.push(controlPoints.length - 1);\n                }\n            }\n        }\n        return result;\n    }\n    extractChangingSignControlPointsSequences(controlPoints) {\n        let result = [];\n        let successiveControlPoints = [];\n        let i = 1;\n        while (i < controlPoints.length) {\n            successiveControlPoints = [];\n            if (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                successiveControlPoints.push({ index: i - 1, value: controlPoints[i - 1] });\n                successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                i += 1;\n                while (controlPoints[i - 1] * controlPoints[i] <= 0) {\n                    successiveControlPoints.push({ index: i, value: controlPoints[i] });\n                    i += 1;\n                }\n                result.push(successiveControlPoints);\n            }\n            i += 1;\n        }\n        return result;\n    }\n    extractControlPointsClosestToZero(polygonSegments) {\n        let result = [];\n        for (let polygonSegment of polygonSegments) {\n            let s = this.removeBiggest(polygonSegment);\n            for (let iv of s) {\n                result.push(iv.index);\n            }\n        }\n        return result;\n    }\n    removeBiggest(controlPointsSequence) {\n        let result = controlPointsSequence.slice();\n        let maxIndex = 0;\n        for (let i = 1; i < controlPointsSequence.length; i += 1) {\n            if (Math.pow(controlPointsSequence[i].value, 2) > Math.pow(controlPointsSequence[maxIndex].value, 2)) {\n                maxIndex = i;\n            }\n        }\n        result.splice(maxIndex, 1);\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient_full(e, constraintsSign) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const sxuuu = e.bdsxuuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        const syuuu = e.bdsyuuu;\n        const h1 = e.h1;\n        const h2 = e.h2;\n        const h3 = e.h3;\n        const h4 = e.h4;\n        let dgx = [];\n        let dgy = [];\n        const periodicControlPointsLength = this.spline.freeControlPoints.length;\n        const totalNumberOfConstraints = constraintsSign.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            // moved control point : i\n            // periodicControlPointsLength = n - degree (it is necessery to add degree cyclic control points, if we do not count them we have n - degree control points)\n            // Bernstein Decomposition index : [max(0, i - degree), min(n - degree, i + 1)]\n            // N_{j, d} is zero outside [u_{j}, u_{j + d + 1} )\n            // Dsu[j] = (N_{j, d})_u\n            // in terms of the set of Bernstein Decomposition N_{j, d} = 0 outside [max(0, i - d), min(n - d, i + 1)]\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(sxu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(syuuu, start, lessThan);\n            let h7 = syu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan).multiplyByScalar(-1);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan);\n            let h9 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(syu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            let h7 = sxu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h9 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints, 2 * periodicControlPointsLength);\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (4 * degree - 5);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1) * (4 * degree - 5);\n            for (let j = start; j < lessThan; j += 1) {\n                result.set(j, i, cpx[j - start] * constraintsSign[j]);\n                result.set(j, periodicControlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n            }\n        }\n        //Adding periodic term inside the Matrix\n        // The effect of the first control points over the constraints at the end\n        for (let i = 0; i < degree; i += 1) {\n            // moved control point : i\n            // Bernstein Decomposition index : [max(0, i - degree), min(n - degree, i + 1)]\n            // N_{j, d} is zero outside [u_{j}, u_{j + d + 1} )\n            // Dsu[j] = (N_{j, d})_u\n            // in terms of the set of Bernstein Decomposition N_{j, d} = 0 outside [max(0, i - d), min(n - d, i + 1)]\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(sxu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(syuuu, start, lessThan);\n            let h7 = syu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan).multiplyByScalar(-1);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan);\n            let h9 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = 0; i < degree; i += 1) {\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h1_subset = h1.subset(start, lessThan);\n            let h2_subset = h2.subset(start, lessThan);\n            let h3_subset = h3.subset(start, lessThan);\n            let h4_subset = h4.subset(start, lessThan);\n            let h5 = this.dBasisFunctions_du[i].multiplyRange(syu, start, lessThan);\n            let h6 = this.dBasisFunctions_du[i].multiplyRange(sxuuu, start, lessThan).multiplyByScalar(-1);\n            let h7 = sxu.multiplyRange(this.d3BasisFunctions_du3[i], start, lessThan);\n            let h8 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h9 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push((h5.multiply(h2_subset).multiplyByScalar(2)).add(h1_subset.multiply(h6.add(h7))).add((((h8.add(h9)).multiply(h4_subset)).add((h10.add(h11)).multiply(h3_subset))).multiplyByScalar(-3)));\n        }\n        for (let i = periodicControlPointsLength; i < periodicControlPointsLength + degree; i += 1) {\n            // index i : moved control point + periodicControlPointsLength\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = (i - degree) * (4 * degree - 5);\n            let lessThan = (periodicControlPointsLength) * (4 * degree - 5);\n            for (let j = start; j < lessThan; j += 1) {\n                result.set(j, i - periodicControlPointsLength, cpx[j - start] * constraintsSign[j]);\n                result.set(j, i, cpy[j - start] * constraintsSign[j]);\n            }\n        }\n        return result;\n    }\n    compute_curvatureExtremaConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        let result = this.compute_curvatureExtremaConstraints_gradient_full(e, constraintsSign);\n        this.currentCurvatureExtremaConstraintsGradient = result;\n        return result.removeRows(inactiveConstraints);\n    }\n    compute_inflectionConstraints_gradient_full(e, constraintsSign) {\n        const sxu = e.bdsxu;\n        const sxuu = e.bdsxuu;\n        const syu = e.bdsyu;\n        const syuu = e.bdsyuu;\n        let dgx = [];\n        let dgy = [];\n        const periodicControlPointsLength = this.spline.freeControlPoints.length;\n        const degree = this.spline.degree;\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let start = Math.max(0, i - degree);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1);\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        const totalNumberOfConstraints = this.inflectionConstraintsSign.length;\n        let result = new DenseMatrix_1.DenseMatrix(totalNumberOfConstraints, 2 * periodicControlPointsLength);\n        for (let i = 0; i < periodicControlPointsLength; i += 1) {\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (2 * degree - 2);\n            let lessThan = Math.min(periodicControlPointsLength, i + 1) * (2 * degree - 2);\n            for (let j = start; j < lessThan; j += 1) {\n                result.set(j, i, cpx[j - start] * constraintsSign[j]);\n                result.set(j, periodicControlPointsLength + i, cpy[j - start] * constraintsSign[j]);\n            }\n        }\n        //Adding periodic term inside the Matrix\n        // The effect of the first control points over the constraints at the end\n        for (let i = 0; i < degree; i += 1) {\n            // moved control point : i\n            // Bernstein Decomposition index : [max(0, i - degree), min(n - degree, i + 1)]\n            // N_{j, d} is zero outside [u_{j}, u_{j + d + 1} )\n            // Dsu[j] = (N_{j, d})_u\n            // in terms of the set of Bernstein Decomposition N_{j, d} = 0 outside [max(0, i - d), min(n - d, i + 1)]\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(syuu, start, lessThan);\n            let h11 = syu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan).multiplyByScalar(-1);\n            dgx.push((h10.add(h11)));\n        }\n        for (let i = 0; i < degree; i += 1) {\n            let start = i - degree + periodicControlPointsLength;\n            let lessThan = periodicControlPointsLength;\n            let h10 = this.dBasisFunctions_du[i].multiplyRange(sxuu, start, lessThan).multiplyByScalar(-1);\n            let h11 = sxu.multiplyRange(this.d2BasisFunctions_du2[i], start, lessThan);\n            dgy.push(h10.add(h11));\n        }\n        for (let i = periodicControlPointsLength; i < periodicControlPointsLength + degree; i += 1) {\n            // index i : moved control point + periodicControlPointsLength\n            let cpx = dgx[i].flattenControlPointsArray();\n            let cpy = dgy[i].flattenControlPointsArray();\n            let start = Math.max(0, i - degree) * (2 * degree - 2);\n            let lessThan = (periodicControlPointsLength) * (2 * degree - 2);\n            for (let j = start; j < lessThan; j += 1) {\n                result.set(j, i - periodicControlPointsLength, cpx[j - start] * constraintsSign[j]);\n                result.set(j, i, cpy[j - start] * constraintsSign[j]);\n            }\n        }\n        return result;\n    }\n    compute_inflectionConstraints_gradient(e, constraintsSign, inactiveConstraints) {\n        let result = this.compute_inflectionConstraints_gradient_full(e, constraintsSign);\n        this.currentInflectionConstraintsGradient = result;\n        return result.removeRows(inactiveConstraints);\n    }\n    computeBasisFunctionsDerivatives() {\n        const n = this._spline.controlPoints.length;\n        const m = this._spline.freeControlPoints.length;\n        this._numberOfIndependentVariables = m * 2;\n        let diracControlPoints = MathVectorBasicOperations_1.zeroVector(n);\n        this.dBasisFunctions_du = [];\n        this.d2BasisFunctions_du2 = [];\n        this.d3BasisFunctions_du3 = [];\n        for (let i = 0; i < m; i += 1) {\n            diracControlPoints[i] = 1;\n            if (i < this.spline.degree) {\n                diracControlPoints[m + i] = 1;\n            }\n            let basisFunction = this.bSplineR1toR1Factory(diracControlPoints.slice(), this.spline.knots.slice());\n            let dBasisFunction_du = basisFunction.derivative();\n            let d2BasisFunction_du2 = dBasisFunction_du.derivative();\n            let d3BasisFunction_du3 = d2BasisFunction_du2.derivative();\n            this.dBasisFunctions_du.push(dBasisFunction_du.bernsteinDecomposition());\n            this.d2BasisFunctions_du2.push(d2BasisFunction_du2.bernsteinDecomposition());\n            this.d3BasisFunctions_du3.push(d3BasisFunction_du3.bernsteinDecomposition());\n            diracControlPoints[i] = 0;\n            if (i < this.spline.degree) {\n                diracControlPoints[m + i] = 0;\n            }\n        }\n    }\n    step(deltaX) {\n        this.spline.optimizerStep(deltaX);\n        this._gradient_f0 = this.compute_gradient_f0(this._spline);\n        this._f0 = this.compute_f0(this._gradient_f0);\n        const e = this.expensiveComputation(this._spline);\n        const g = this.curvatureDerivativeNumerator(e.h1, e.h2, e.h3, e.h4);\n        this.curvatureExtremaConstraintsSign = this.computeConstraintsSign(g);\n        this._curvatureExtremaInactiveConstraints = this.computeInactiveConstraints(g);\n        const curvatureNumerator = this.curvatureNumerator(e.h4);\n        this.inflectionConstraintsSign = this.computeConstraintsSign(curvatureNumerator);\n        this._inflectionInactiveConstraints = this.computeInactiveConstraints(curvatureNumerator);\n        this._f = this.compute_f(curvatureNumerator, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, g, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this._gradient_f = this.compute_gradient_f(e, this.inflectionConstraintsSign, this._inflectionInactiveConstraints, this.curvatureExtremaConstraintsSign, this._curvatureExtremaInactiveConstraints);\n        this.curvatureExtremaConstraintsHessians = this.computeSymmetricRank1Update(deltaX, this.currentCurvatureExtremaConstraintsGradient, this.previousCurvatureExtremaConstraintsGradient, this.curvatureExtremaConstraintsHessians);\n        this.previousCurvatureExtremaConstraintsGradient = this.currentCurvatureExtremaConstraintsGradient;\n        this.inflectionConstraintsHessians = this.computeSymmetricRank1Update(deltaX, this.currentInflectionConstraintsGradient, this.previousInflectionConstraintsGradient, this.inflectionConstraintsHessians);\n        this.previousInflectionConstraintsGradient = this.currentInflectionConstraintsGradient;\n        //this.updateSymmetricRank1(deltaX, this._gradient_f)\n        this.barrierHessianApproximation = MathVectorBasicOperations_1.removeElements(this.inflectionConstraintsHessians, this.inflectionInactiveConstraints).concat(MathVectorBasicOperations_1.removeElements(this.curvatureExtremaConstraintsHessians, this.curvatureExtremaInactiveConstraints));\n    }\n    /**\n     * Update the symmetric matrix hessian with an improvement of rank 1\n     * See: Jorge Nocedal and Stephen J. Wright,\n     * Numerical Optimization, Second Edition, p. 144 (The SR1 Method)\n     */\n    /*\n     updateSymmetricRank1(step: number[], f: number[], gradient_f: MatrixInterface) {\n        let m = gradient_f.shape[0] // number of constraints\n        let n = gradient_f.shape[1] // number of free variables\n        let deltaGradient: number[][] = []\n        for (let i = 0; i < m; i += 1) {\n            deltaGradient.push([])\n            for (let j = 0; j < n; j += 1) {\n                deltaGradient[i].push(gradient_f.get(i, j) - this.previousGradient_f.get(i, j))\n            }\n        }\n        for (let i = 0; i < m ; i += 1) {\n            const hessian = this.computeSR1(step, deltaGradient[i], this.barrierHessianApproximation[i])\n            if (hessian) {\n                this.barrierHessianApproximation[i] = hessian\n            }\n            else {\n                //console.log(\"approximation hessian not defined\")\n                this.barrierHessianApproximation[i] = new SymmetricMatrix(n)\n            }\n        }\n        for (let i = 0; i < gradient_f.shape[0]; i += 1) {\n            for (let j = 0; j< gradient_f.shape[1]; j += 1) {\n                this.previousGradient_f.set(i, j, gradient_f.get(i, j))\n            }\n        }\n    }\n    */\n    computeSymmetricRank1Update(step, gradients, previousGradients, previousHessians) {\n        let m = gradients.shape[0]; // number of constraints\n        let n = gradients.shape[1]; // number of free variables\n        let deltaGradient = [];\n        let result = [];\n        for (let i = 0; i < m; i += 1) {\n            deltaGradient.push([]);\n            for (let j = 0; j < n; j += 1) {\n                deltaGradient[i].push(gradients.get(i, j) - previousGradients.get(i, j));\n            }\n        }\n        for (let i = 0; i < m; i += 1) {\n            const hessian = this.computeSR1(step, deltaGradient[i], previousHessians[i]);\n            if (hessian) {\n                result.push(hessian);\n            }\n            else {\n                //console.log(\"approximation hessian not defined\")\n                result.push(new SymmetricMatrix_1.SymmetricMatrix(n));\n            }\n        }\n        return result;\n    }\n    computeSR1(step, deltaGradient, previousHessian, r = 10e-8) {\n        let m = step.length;\n        let result = new SymmetricMatrix_1.SymmetricMatrix(m);\n        let v = [];\n        for (let i = 0; i < m; i += 1) {\n            let c = 0;\n            for (let j = 0; j < m; j += 1) {\n                c += previousHessian.get(i, j) * step[j];\n            }\n            v.push(deltaGradient[i] - c);\n        }\n        const vTs = MathVectorBasicOperations_1.dotProduct(step, v);\n        if (vTs <= r * MathVectorBasicOperations_1.norm(step) * MathVectorBasicOperations_1.norm(v)) {\n            //console.log(vTs)\n            return undefined;\n        }\n        for (let i = 0; i < m; i += 1) {\n            for (let j = 0; j <= i; j += 1) {\n                let h = previousHessian.get(i, j);\n                let vvT = v[i] * v[j];\n                result.set(i, j, h + vvT / vTs);\n                //result.set(i, j, 0)\n            }\n        }\n        return result;\n    }\n}\nexports.OptimizationProblemPeriodicBSplineR1toR2QuasiNewton = OptimizationProblemPeriodicBSplineR1toR2QuasiNewton;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CurveScene3dController {\n    constructor(curveModel3d) {\n        this.curveModel3d = curveModel3d;\n    }\n    setControlPointPosition(selectedControlPoint, x, y, z) {\n        this.curveModel3d.setControlPointPosition(selectedControlPoint, x, y, z);\n    }\n}\nexports.CurveScene3dController = CurveScene3dController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CurveSceneController {\n    constructor(curveModel) {\n        this.curveModel = curveModel;\n    }\n    setControlPointPosition(selectedControlPoint, x, y) {\n        this.curveModel.setControlPointPosition(selectedControlPoint, x, y);\n    }\n}\nexports.CurveSceneController = CurveSceneController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A decomposition of a positive-definite matirx into a product of a lower triangular matrix and its conjugate transpose\n */\nclass CholeskyDecomposition {\n    /**\n     * The values of the decomposition are stored in the lower triangular portion of the matrix g\n     * @param matrix Matrix\n     */\n    constructor(matrix) {\n        this.success = false;\n        this.CLOSE_TO_ZERO = 10e-8;\n        this.firstNonPositiveDefiniteLeadingSubmatrixSize = -1;\n        this.g = matrix.squareMatrix();\n        const n = this.g.shape[0];\n        if (this.g.get(0, 0) < this.CLOSE_TO_ZERO) {\n            return;\n        }\n        let sqrtGjj = Math.sqrt(this.g.get(0, 0));\n        for (let i = 0; i < n; i += 1) {\n            this.g.divideAt(i, 0, sqrtGjj);\n        }\n        for (let j = 1; j < n; j += 1) {\n            for (let i = j; i < n; i += 1) {\n                let sum = 0;\n                for (let k = 0; k < j; k += 1) {\n                    sum += this.g.get(i, k) * this.g.get(j, k);\n                }\n                this.g.substractAt(i, j, sum);\n            }\n            if (this.g.get(j, j) < this.CLOSE_TO_ZERO) {\n                this.firstNonPositiveDefiniteLeadingSubmatrixSize = j + 1;\n                return;\n            }\n            sqrtGjj = Math.sqrt(this.g.get(j, j));\n            for (let i = j; i < n; i += 1) {\n                this.g.divideAt(i, j, sqrtGjj);\n            }\n        }\n        for (let j = 0; j < n; j += 1) {\n            for (let i = 0; i < j; i += 1) {\n                this.g.set(i, j, 0);\n            }\n        }\n        this.success = true;\n    }\n    /**\n     * Solve the linear system\n     * @param b Vector\n     * @return The vector x\n     * @throws If the Cholesky decomposition failed\n     */\n    solve(b) {\n        'use strict';\n        // See Numerical Recipes Third Edition p. 101\n        if (!this.success) {\n            throw new Error(\"CholeskyDecomposistion.success === false\");\n        }\n        if (b.length !== this.g.shape[0]) {\n            throw new Error(\"The size of the cholesky decomposed matrix g and the vector b do not match\");\n        }\n        const n = this.g.shape[0];\n        let x = b.slice();\n        // Ly = b\n        for (let i = 0; i < n; i += 1) {\n            let sum = b[i];\n            for (let k = i - 1; k >= 0; k -= 1) {\n                sum -= this.g.get(i, k) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        // LT x = Y\n        for (let i = n - 1; i >= 0; i -= 1) {\n            let sum = x[i];\n            for (let k = i + 1; k < n; k += 1) {\n                sum -= this.g.get(k, i) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        return x;\n    }\n    /**\n     * Solve the linear equation Lower triangular matrix LT * x = b\n     * @param b Vector\n     */\n    solve_LT_result_equal_b(b) {\n        const n = this.g.shape[0];\n        let x = b.slice();\n        for (let i = 0; i < n; i += 1) {\n            let sum = b[i];\n            for (let k = i - 1; k >= 0; k -= 1) {\n                sum -= this.g.get(i, k) * x[k];\n            }\n            x[i] = sum / this.g.get(i, i);\n        }\n        return x;\n    }\n}\nexports.CholeskyDecomposition = CholeskyDecomposition;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A dense matrix\n */\nclass DenseMatrix {\n    /**\n     * Create a square matrix\n     * @param nrows Number of rows\n     * @param ncols Number of columns\n     * @param data A row after row flat array\n     * @throws If data length is not equal to nrows*ncols\n     */\n    constructor(nrows, ncols, data) {\n        this._shape = [nrows, ncols];\n        if (data) {\n            if (data.length !== this.shape[0] * this.shape[1]) {\n                throw new Error(\"Dense matrix constructor expect the data to have nrows*ncols length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            for (let i = 0; i < this.shape[0] * this.shape[1]; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n     * Returns the shape of the matrix : [number of rows, number of columns]\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Return the corresponding index in the flat row by row data vector\n     * @param row The row index\n     * @param column The column index\n     */\n    dataIndex(row, column) {\n        return row * this.shape[1] + column;\n    }\n    /**\n     * Return the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    get(row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    }\n    /**\n     * Check that the column index is inside appropriate range\n     * @param index The column index\n     * @throws If index is out of range\n     */\n    checkColumnRange(index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"DenseMatrix column index out of range\");\n        }\n    }\n    /**\n     * Check that the row index is inside appropriate range\n     * @param index The row index\n     * @throws If index is out of range\n     */\n    checkRowRange(index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"DenseMatrix row index out of range\");\n        }\n    }\n    removeRows(rows) {\n        const numberOfRows = this.shape[0] - rows.length;\n        const numberOfColumns = this.shape[1];\n        let result = new DenseMatrix(numberOfRows, numberOfColumns);\n        let k = 0;\n        let newRowIndex = 0;\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            if (rows[k] != i) {\n                for (let j = 0; j < this.shape[1]; j += 1) {\n                    result.set(newRowIndex, j, this.get(i, j));\n                }\n                newRowIndex += 1;\n            }\n            else {\n                k += 1;\n            }\n        }\n        return result;\n    }\n}\nexports.DenseMatrix = DenseMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * An identity matrix\n */\nclass DiagonalMatrix {\n    /**\n     * Create a Symmetric Matrix\n     * @param size The number of rows or the number columns\n     * @param data The matrix data in a flat vector\n     */\n    constructor(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size) {\n                throw new Error(\"Diagonal matrix constructor expect the data to have size length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            const n = size;\n            for (let i = 0; i < n; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n     * Returns the shape of the matrix : [number of rows, number of columns]\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n * Returns the value at a given row and column position\n * @param row The row index\n * @param column The column index\n * @return Scalar\n * @throws If an index is out of range\n */\n    get(row, column) {\n        this.checkRange(row, column);\n        return this.data[row];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRange(row, column);\n        this.data[row] = value;\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkRange(row, column) {\n        if (row < 0 || row >= this.shape[0] || row != column) {\n            throw new Error(\"DiagonalMatrix index is out of range\");\n        }\n    }\n}\nexports.DiagonalMatrix = DiagonalMatrix;\nfunction identityMatrix(n) {\n    let result = new DiagonalMatrix(n);\n    for (let i = 0; i < n; i += 1) {\n        result.set(i, i, 1);\n    }\n    return result;\n}\nexports.identityMatrix = identityMatrix;\n","\"use strict\";\n// https://rosettacode.org/wiki/Gaussian_elimination#JavaScript\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Lower Upper Solver\nfunction lusolve(matrix, b, update = false) {\n    let A = matrix.toNumberArray();\n    let lu = ludcmp(A, update);\n    if (lu === undefined)\n        return; // Singular Matrix!\n    return lubksb(lu, b, update);\n}\nexports.lusolve = lusolve;\n// Lower Upper Decomposition\nfunction ludcmp(A, update) {\n    // A is a matrix that we want to decompose into Lower and Upper matrices.\n    let d = true;\n    let n = A.length;\n    let idx = new Array(n); // Output vector with row permutations from partial pivoting\n    let vv = new Array(n); // Scaling information\n    for (let i = 0; i < n; i++) {\n        let max = 0;\n        for (let j = 0; j < n; j++) {\n            let temp = Math.abs(A[i][j]);\n            if (temp > max)\n                max = temp;\n        }\n        if (max == 0)\n            return; // Singular Matrix!\n        vv[i] = 1 / max; // Scaling\n    }\n    if (!update) { // make a copy of A \n        let Acpy = new Array(n);\n        for (let i = 0; i < n; i++) {\n            let Ai = A[i];\n            let Acpyi = new Array(Ai.length);\n            for (let j = 0; j < Ai.length; j += 1)\n                Acpyi[j] = Ai[j];\n            Acpy[i] = Acpyi;\n        }\n        A = Acpy;\n    }\n    let tiny = 1e-20; // in case pivot element is zero\n    for (let i = 0;; i++) {\n        for (let j = 0; j < i; j++) {\n            let sum = A[j][i];\n            for (let k = 0; k < j; k++)\n                sum -= A[j][k] * A[k][i];\n            A[j][i] = sum;\n        }\n        let jmax = 0;\n        let max = 0;\n        for (let j = i; j < n; j++) {\n            let sum = A[j][i];\n            for (let k = 0; k < i; k++)\n                sum -= A[j][k] * A[k][i];\n            A[j][i] = sum;\n            let temp = vv[j] * Math.abs(sum);\n            if (temp >= max) {\n                max = temp;\n                jmax = j;\n            }\n        }\n        if (i <= jmax) {\n            for (let j = 0; j < n; j++) {\n                let temp = A[jmax][j];\n                A[jmax][j] = A[i][j];\n                A[i][j] = temp;\n            }\n            d = !d;\n            vv[jmax] = vv[i];\n        }\n        idx[i] = jmax;\n        if (i == n - 1)\n            break;\n        let temp = A[i][i];\n        if (temp == 0)\n            A[i][i] = temp = tiny;\n        temp = 1 / temp;\n        for (let j = i + 1; j < n; j++)\n            A[j][i] *= temp;\n    }\n    return { A: A, idx: idx, d: d };\n}\n// Lower Upper Back Substitution\nfunction lubksb(lu, b, update) {\n    // solves the set of n linear equations A*x = b.\n    // lu is the object containing A, idx and d as determined by the routine ludcmp.\n    let A = lu.A;\n    let idx = lu.idx;\n    let n = idx.length;\n    if (!update) { // make a copy of b\n        let bcpy = new Array(n);\n        for (let i = 0; i < b.length; i += 1)\n            bcpy[i] = b[i];\n        b = bcpy;\n    }\n    for (let ii = -1, i = 0; i < n; i++) {\n        let ix = idx[i];\n        let sum = b[ix];\n        b[ix] = b[i];\n        if (ii > -1)\n            for (let j = ii; j < i; j++)\n                sum -= A[i][j] * b[j];\n        else if (sum)\n            ii = i;\n        b[i] = sum;\n    }\n    for (let i = n - 1; i >= 0; i--) {\n        let sum = b[i];\n        for (let j = i + 1; j < n; j++)\n            sum -= A[i][j] * b[j];\n        b[i] = sum / A[i][i];\n    }\n    return b; // solution vector x\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SquareMatrix_1 = require(\"./SquareMatrix\");\nconst DenseMatrix_1 = require(\"./DenseMatrix\");\n/**\n * Multiply a vector by a scalar\n * @param vector vector\n * @param value scalar\n */\nfunction multiplyVectorByScalar(vector, value) {\n    let result = [];\n    for (let vi of vector) {\n        result.push(vi * value);\n    }\n    return result;\n}\nexports.multiplyVectorByScalar = multiplyVectorByScalar;\n/**\n * Divide a vector by a scalar\n * @param vector Vector\n * @param value Scalar\n * @throws If the scalar value is zero\n */\nfunction divideVectorByScalar(vector, value) {\n    if (value === 0) {\n        throw new Error(\"Division by zero\");\n    }\n    let result = [];\n    for (let vi of vector) {\n        result.push(vi / value);\n    }\n    return result;\n}\nexports.divideVectorByScalar = divideVectorByScalar;\n/**\n * A standard function in basic linear algebra : y = ax + y\n * @param a Scalar\n * @param x Vector\n * @param y Vector\n * @throws If x and y have different length\n */\nfunction saxpy(a, x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    for (let i = 0; i < x.length; i += 1) {\n        y[i] += a * x[i];\n    }\n}\nexports.saxpy = saxpy;\n/**\n * A standard function in basic linear algebra : z = ax + y\n * @param a Scalar\n * @param x Vector\n * @param y Vector\n * @returns ax + y\n * @throws If x and y have different length\n */\nfunction saxpy2(a, x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    let result = [];\n    for (let i = 0; i < x.length; i += 1) {\n        result.push(a * x[i] + y[i]);\n    }\n    return result;\n}\nexports.saxpy2 = saxpy2;\n/**\n * Compute the dot product of two vectors\n * @param x Vector\n * @param y Vector\n * @return The scalar result\n * @throws If x and y have different length\n */\nfunction dotProduct(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Making the dot product of two vectors of different length\");\n    }\n    let result = 0;\n    for (let i = 0; i < x.length; i += 1) {\n        result += x[i] * y[i];\n    }\n    return result;\n}\nexports.dotProduct = dotProduct;\n/**\n * Add two vectors\n * @param x Vector\n * @param y Vector\n * @return Vector\n * @throws If x and y have different length\n */\nfunction addTwoVectors(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    let result = [];\n    for (let i = 0; i < x.length; i += 1) {\n        result.push(x[i] + y[i]);\n    }\n    return result;\n}\nexports.addTwoVectors = addTwoVectors;\n/**\n * Add the second vector to the first vector\n * @param x Vector\n * @param y Vector\n * @throws If x and y have different length\n */\nfunction addSecondVectorToFirst(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(\"Adding two vectors of different length\");\n    }\n    for (let i = 0; i < x.length; i += 1) {\n        x[i] += y[i];\n    }\n}\nexports.addSecondVectorToFirst = addSecondVectorToFirst;\n/**\n * Compute the square of the norm\n * @param v Vector\n * @return Non negative scalar\n */\nfunction squaredNorm(vector) {\n    let result = 0;\n    for (let vi of vector) {\n        result += vi * vi;\n    }\n    return result;\n}\nexports.squaredNorm = squaredNorm;\n/**\n * Compute the norm\n * @param v Vector\n * @return Non negative scalar\n */\nfunction norm(v) {\n    return Math.sqrt(squaredNorm(v));\n}\nexports.norm = norm;\n/**\n * Compute the norm p = 1\n * @param v Vector\n * @return Non negative scalar\n */\nfunction norm1(vector) {\n    let result = 0;\n    for (let vi of vector) {\n        result += Math.abs(vi);\n    }\n    return result;\n}\nexports.norm1 = norm1;\n/**\n * Create a zero vector of size n\n * @param n Size\n */\nfunction zeroVector(n) {\n    let result = [];\n    for (let i = 0; i < n; i += 1) {\n        result.push(0);\n    }\n    return result;\n}\nexports.zeroVector = zeroVector;\n/**\n * Compute the product of a vector and its transpose\n * @param v Vector\n */\nfunction product_v_vt(v) {\n    const n = v.length;\n    let result = new SquareMatrix_1.SquareMatrix(n);\n    for (let i = 0; i < n; i += 1) {\n        for (let j = 0; j < n; j += 1) {\n            result.set(i, j, v[i] * v[j]);\n        }\n    }\n    return result;\n}\nexports.product_v_vt = product_v_vt;\n/**\n * Compute the product of a first vector with the transpose of a second vector\n * @param v1 The first vector taken as a column vector\n * @param v2 The second vector taken after transposition as a row vector\n */\nfunction product_v1_v2t(v1, v2) {\n    const m = v1.length;\n    const n = v2.length;\n    let result = new DenseMatrix_1.DenseMatrix(m, n);\n    for (let i = 0; i < m; i += 1) {\n        for (let j = 0; j < n; j += 1) {\n            result.set(i, j, v1[i] * v2[j]);\n        }\n    }\n    return result;\n}\nexports.product_v1_v2t = product_v1_v2t;\nfunction isZeroVector(vector) {\n    for (let vi of vector) {\n        if (vi !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isZeroVector = isZeroVector;\n/**\n * Returns a vector filled with random values between 0 and 1\n * @param n The size of the random vector\n */\nfunction randomVector(n) {\n    let result = [];\n    for (let i = 0; i < n; i += 1) {\n        result.push((Math.random() - 0.5) * 10e8);\n        //result.push((Math.random())*10e8)\n    }\n    return result;\n}\nexports.randomVector = randomVector;\nfunction containsNaN(vector) {\n    for (let vi of vector) {\n        if (isNaN(vi)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.containsNaN = containsNaN;\n/**\n * Return the sign of a number.\n * It returns 1 if the number is positive, -1 if the number is negative and 0 if it is zero or minus zero\n * The standard Math.sign() function doesn't work with Windows Internet Explorer\n * @param x Number\n */\nfunction sign(x) {\n    if (x == 0)\n        return 0;\n    else\n        return x < 0 ? -1 : 1;\n}\nexports.sign = sign;\nfunction removeElements(array, indices) {\n    let result = array.slice();\n    for (let i = indices.length - 1; i >= 0; i--) {\n        result.splice(indices[i], 1);\n    }\n    return result;\n}\nexports.removeElements = removeElements;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A square matrix\n */\nclass SquareMatrix {\n    /**\n     * Create a square matrix\n     * @param size Number of row and column\n     * @param data A row after row flat array\n     * @throws If data length is not equal to size*size\n     */\n    constructor(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size * size) {\n                throw new Error(\"Square matrix constructor expect the data to have size*size length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            for (let i = 0; i < this.shape[0] * this.shape[1]; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n     * Returns the shape of the matrix : [number of rows, number of columns]\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Return the corresponding index in the flat row by row data vector\n     * @param row The row index\n     * @param column The column index\n     */\n    dataIndex(row, column) {\n        let n = row * this._shape[1] + column;\n        return n;\n    }\n    /**\n     * Return the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    get(row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    }\n    /**\n     * Change the value of the matrix at a given row and column position by this value divided by the divisor value\n     * @param row The row index\n     * @param column The column index\n     * @param divisor The divisor value\n     * @throws If an index is out of range\n     */\n    divideAt(row, column, divisor) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] /= divisor;\n    }\n    /**\n     * Change the value of the matrix at a given row and column position by this value substracted by the subtrahend value\n     * @param row The row index\n     * @param column The column index\n     * @param divisor The divisor value\n     * @throws If an index is out of range\n     */\n    substractAt(row, column, subtrahend) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] -= subtrahend;\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkRowRange(index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkColumnRange(index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n     * Multiply two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    multiplyByMatrix(that) {\n        if (this.shape[1] !== that.shape[0]) {\n            throw new Error(\"Size mismatch in matrix multiplication\");\n        }\n        let result = new SquareMatrix(this.shape[1]);\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            for (let j = 0; j < this.shape[0]; j += 1) {\n                let temp = 0;\n                for (let k = 0; k < this.shape[0]; k += 1) {\n                    temp += this.get(i, k) * that.get(k, j);\n                }\n                result.set(i, j, temp);\n            }\n        }\n        return result;\n    }\n    multiplyByVector(v) {\n        if (this.shape[1] !== v.length) {\n            throw new Error(\"SquareMatrix multiply a vector of incorrect length\");\n        }\n        let result = [];\n        const n = this.shape[1];\n        for (let i = 0; i < n; i += 1) {\n            let temp = 0;\n            for (let j = 0; j < n; j += 1) {\n                temp += this.get(i, j) * v[j];\n            }\n            result.push(temp);\n        }\n        return result;\n    }\n    /**\n     * Add two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    addByMatrix(that) {\n        if (this.shape[1] !== that.shape[0]) {\n            throw new Error(\"Size mismatch in matrix addition\");\n        }\n        let result = new SquareMatrix(this.shape[1]);\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            for (let j = 0; j < this.shape[0]; j += 1) {\n                result.set(i, j, this.get(i, j) + that.get(i, j));\n            }\n        }\n        return result;\n    }\n    /**\n     * Add two matrices\n     * @param that A square or a symmetric matrix\n     * @return a square matrix\n     */\n    mutiplyByConstant(value) {\n        let result = new SquareMatrix(this.shape[1]);\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            for (let j = 0; j < this.shape[0]; j += 1) {\n                result.set(i, j, this.get(i, j) * value);\n            }\n        }\n        return result;\n    }\n    toNumberArray() {\n        let result = [];\n        for (let i = 0; i < this.shape[0]; i += 1) {\n            result.push([]);\n            for (let j = 0; j < this.shape[1]; j += 1) {\n                result[i].push(this.get(i, j));\n            }\n        }\n        return result;\n    }\n}\nexports.SquareMatrix = SquareMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SquareMatrix_1 = require(\"./SquareMatrix\");\nconst DiagonalMatrix_1 = require(\"./DiagonalMatrix\");\nconst MathVectorBasicOperations_1 = require(\"./MathVectorBasicOperations\");\n/**\n * A symmetric matrix\n */\nclass SymmetricMatrix {\n    /**\n     * Create a Symmetric Matrix\n     * @param size The number of rows or the number columns\n     * @param data The matrix data in a flat vector\n     */\n    constructor(size, data) {\n        this._shape = [size, size];\n        if (data) {\n            if (data.length !== size * (size + 1) / 2) {\n                throw new Error(\"Square matrix constructor expect the data to have (size * (size + 1) / 2) length\");\n            }\n            this.data = data.slice();\n        }\n        else {\n            this.data = [];\n            const n = (size * (size + 1)) / 2;\n            for (let i = 0; i < n; i += 1) {\n                this.data.push(0);\n            }\n        }\n    }\n    /**\n    * Returns the shape of the matrix : [number of rows, number of columns]\n    */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Returns the corresponding index in the flat data vector.\n     * In this flat data vector the upper triangular matrix is store row-wise.\n     * @param row The row index\n     * @param column The column index\n     */\n    dataIndex(row, column) {\n        if (row <= column) {\n            return row * this.shape[1] - (row - 1) * row / 2 + column - row;\n        }\n        return column * this.shape[0] - (column - 1) * column / 2 + row - column;\n    }\n    /**\n     * Returns the value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @return Scalar\n     * @throws If an index is out of range\n     */\n    get(row, column) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        return this.data[this.dataIndex(row, column)];\n    }\n    /**\n     * Set a given value at a given row and column position\n     * @param row The row index\n     * @param column The column index\n     * @param value The new value\n     * @throws If an index is out of range\n     */\n    set(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(column);\n        this.data[this.dataIndex(row, column)] = value;\n    }\n    /**\n     * Check that the index is inside appropriate range\n     * @param index The column or the row index\n     * @throws If an index is out of range\n     */\n    checkRowRange(index) {\n        if (index < 0 || index >= this.shape[0]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n * Check that the index is inside appropriate range\n * @param index The column or the row index\n * @throws If an index is out of range\n */\n    checkColumnRange(index) {\n        if (index < 0 || index >= this.shape[1]) {\n            throw new Error(\"SymmetricMatrix index is out of range\");\n        }\n    }\n    /**\n     * Compute the product v^t M v\n     * @param v Vector\n     * @return Scalar\n     */\n    quadraticForm(v) {\n        let result = 0;\n        for (let i = 1; i < this.shape[1]; i += 1) {\n            for (let j = 0; j < i; j += 1) {\n                result += this.get(i, j) * v[i] * v[j];\n            }\n        }\n        result *= 2;\n        for (let i = 0; i < this.shape[1]; i += 1) {\n            result += this.get(i, i) * Math.pow(v[i], 2);\n        }\n        return result;\n    }\n    /**\n     * Return a safe copy of this matrix\n     * */\n    clone() {\n        return new SymmetricMatrix(this.shape[0], this.data);\n    }\n    /**\n     * Increases the given element of the matrix by the value\n     * @param row The row index\n     * @param column The column index\n     * @param value The number to be added\n     * @throws If an index is out of range\n     */\n    addAt(row, column, value) {\n        this.checkRowRange(row);\n        this.checkColumnRange(row);\n        this.data[this.dataIndex(row, column)] += value;\n    }\n    /**\n     * Increases every diagonal element of the matrix by the value\n     * @param value The number to be added\n     */\n    addValueOnDiagonalInPlace(value) {\n        const m = this.shape[0];\n        for (let i = 0; i < m; i += 1) {\n            this.data[this.dataIndex(i, i)] += value;\n        }\n    }\n    /**\n     * Returns the new matrix: this.matrix + value * I\n     * @param value\n     * @returns SymmetricMatrix\n     */\n    addValueOnDiagonal(value) {\n        let result = this.clone();\n        result.addValueOnDiagonalInPlace(value);\n        return result;\n    }\n    /**\n     * Returns a SquareMatrix with the values of this matrix\n     */\n    squareMatrix() {\n        const n = this.shape[0];\n        let result = new SquareMatrix_1.SquareMatrix(n);\n        for (let i = 0; i < n; i += 1) {\n            for (let j = 0; j < n; j += 1) {\n                result.set(i, j, this.get(i, j));\n            }\n        }\n        return result;\n    }\n    plusSymmetricMatrixMultipliedByValue(matrix, value) {\n        if (this.shape[0] !== matrix.shape[0]) {\n            throw new Error(\"Adding two symmetric matrix with different shapes\");\n        }\n        let result = this.clone();\n        const n = result.shape[0];\n        if (matrix instanceof DiagonalMatrix_1.DiagonalMatrix) {\n            for (let i = 0; i < n; i += 1) {\n                result.addAt(i, i, matrix.get(i, i) * value);\n            }\n            return result;\n        }\n        else {\n            for (let i = 0; i < n; i += 1) {\n                for (let j = 0; j <= i; j += 1) {\n                    result.addAt(i, j, matrix.get(i, j) * value);\n                }\n            }\n            return result;\n        }\n    }\n    multiplyByVector(v) {\n        if (this.shape[1] !== v.length) {\n            throw new Error(\"SymmetricMatrix multiply a vector of incorrect length\");\n        }\n        let result = [];\n        const n = this.shape[1];\n        for (let i = 0; i < n; i += 1) {\n            let temp = 0;\n            for (let j = 0; j < n; j += 1) {\n                temp += this.get(i, j) * v[j];\n            }\n            result.push(temp);\n        }\n        return result;\n    }\n    containsNaN() {\n        return MathVectorBasicOperations_1.containsNaN(this.data);\n    }\n    getData() {\n        return this.data;\n    }\n}\nexports.SymmetricMatrix = SymmetricMatrix;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SquareMatrix_1 = require(\"../linearAlgebra/SquareMatrix\");\nfunction rotationMatrixFromTwoVectors(unitVector1, unitVector2, tolerance = 10e-5) {\n    // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d\n    let p = unitVector1.crossPoduct(unitVector2);\n    let i = new SquareMatrix_1.SquareMatrix(3, [1, 0, 0, 0, 1, 0, 0, 0, 1]);\n    let v = new SquareMatrix_1.SquareMatrix(3, [0, -p.z, p.y, p.z, 0, -p.x, -p.y, p.x, 0]);\n    let c = unitVector1.dot(unitVector2);\n    if (1 + c < tolerance) {\n        throw new Error(\"The two given vectors points in opposite directions, the rotation matrix is indeterminate\");\n    }\n    return i.addByMatrix(v).addByMatrix(v.multiplyByMatrix(v).mutiplyByConstant(1 / (1 + c)));\n}\nexports.rotationMatrixFromTwoVectors = rotationMatrixFromTwoVectors;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A two dimensional vector\n */\nclass Vector2d {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    negative() {\n        return new Vector2d(-this.x, -this.y);\n    }\n    add(v) {\n        return new Vector2d(this.x + v.x, this.y + v.y);\n    }\n    multiply(value) {\n        return new Vector2d(this.x * value, this.y * value);\n    }\n    substract(v) {\n        return new Vector2d(this.x - v.x, this.y - v.y);\n    }\n    rotate90degrees() {\n        return new Vector2d(-this.y, this.x);\n    }\n    normalize() {\n        let norm = Math.sqrt(this.x * this.x + this.y * this.y);\n        let x = this.x / norm;\n        let y = this.y / norm;\n        return new Vector2d(x, y);\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n    distance(v) {\n        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\n    }\n    norm() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n    }\n    clone() {\n        return new Vector2d(this.x, this.y);\n    }\n}\nexports.Vector2d = Vector2d;\nfunction scale(factor, v) {\n    let result = [];\n    v.forEach(element => {\n        result.push(element.multiply(factor));\n    });\n    return result;\n}\nexports.scale = scale;\nfunction scaleX(factor, v) {\n    let result = [];\n    v.forEach(element => {\n        v.push(new Vector2d(element.x * factor, element.y));\n    });\n    return result;\n}\nexports.scaleX = scaleX;\nfunction scaleY(factor, v) {\n    let result = [];\n    v.forEach(element => {\n        v.push(new Vector2d(element.x, element.y * factor));\n    });\n    return result;\n}\nexports.scaleY = scaleY;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A three dimensional vector\n */\nclass Vector3d {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    negative() {\n        return new Vector3d(-this.x, -this.y, -this.z);\n    }\n    add(v) {\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    multiply(value) {\n        return new Vector3d(this.x * value, this.y * value, this.z * value);\n    }\n    substract(v) {\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    normalize() {\n        let norm = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        let x = this.x / norm;\n        let y = this.y / norm;\n        let z = this.z / norm;\n        return new Vector3d(x, y, z);\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    distance(v) {\n        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2) + Math.pow(this.z - v.z, 2));\n    }\n    norm() {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));\n    }\n    clone() {\n        return new Vector3d(this.x, this.y, this.z);\n    }\n    crossPoduct(v) {\n        return new Vector3d(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);\n    }\n    axisAngleRotation(axis, angle) {\n        //https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n        const k = axis.normalize();\n        const firstTerm = this.multiply(Math.cos(angle));\n        const secondTerm = k.crossPoduct(this).multiply(Math.sin(angle));\n        const thirdTerm = k.multiply(k.dot(this)).multiply(1 - Math.cos(angle));\n        return firstTerm.add(secondTerm).add(thirdTerm);\n    }\n}\nexports.Vector3d = Vector3d;\n/**\n* @param p0 point\n* @param p1 first point of the line\n* @param p2 second point of the line\n*/\nfunction pointLineDistance(p0, p1, p2) {\n    // https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n    return ((p0.substract(p1)).crossPoduct(p0.substract(p2))).norm() / p2.substract(p1).norm();\n}\nexports.pointLineDistance = pointLineDistance;\nfunction linePlaneIntersection(lineP1, lineP2, lookAtOrigin, cameraPosition, objectCenter) {\n    //https://en.wikipedia.org/wiki/Lineplane_intersection\n    const l = lineP2.substract(lineP1);\n    const n = lookAtOrigin.substract(cameraPosition);\n    const nn = n.normalize();\n    const a = nn.dot(objectCenter.substract(cameraPosition));\n    const p0 = nn.multiply(a).add(cameraPosition);\n    const d = (p0.substract(lineP1)).dot(n) / (l.dot(n));\n    return lineP1.add(l.multiply(d));\n}\nexports.linePlaneIntersection = linePlaneIntersection;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"../bsplinesOptimizationProblems/AbstractOptimizationProblemBSplineR1toR2\");\nclass AbstractCurveModel {\n    constructor() {\n        this.observers = [];\n        this.observersCP = [];\n        this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        this.activeOptimizer = true;\n        this.optimizationProblem = null;\n        this.optimizer = null;\n    }\n    registerObserver(observer, kind) {\n        switch (kind) {\n            case 'curve':\n                this.observers.push(observer);\n                break;\n            case 'control points':\n                this.observersCP.push(observer);\n                break;\n            default:\n                throw Error(\"unknown kind\");\n        }\n    }\n    removeObserver(observer, kind) {\n        switch (kind) {\n            case 'curve':\n                this.observers.splice(this.observers.indexOf(observer), 1);\n                break;\n            case 'control points':\n                this.observersCP.splice(this.observersCP.indexOf(observer), 1);\n                break;\n        }\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.clone());\n        }\n        for (let observer of this.observersCP) {\n            observer.update(this._spline.clone());\n        }\n    }\n    setControlPointPosition(controlPointIndex, x, y) {\n        this._spline.setControlPointPosition(controlPointIndex, new Vector2d_1.Vector2d(x, y));\n        this.notifyObservers();\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y);\n        }\n    }\n    optimize(selectedControlPoint, ndcX, ndcY) {\n        if (this.optimizationProblem && this.optimizer) {\n            //const p = this._spline.freeControlPoints[selectedControlPoint].clone()\n            const p = this.optimizationProblem.spline.freeControlPoints[selectedControlPoint].clone();\n            const distance = Math.sqrt(Math.pow(ndcX - p.x, 2) + Math.pow(ndcY - p.y, 2));\n            //console.log(ndcX - p.x)\n            const numberOfStep = 3 * Math.ceil(distance * 10);\n            //const numberOfStep = 1\n            for (let i = 1; i <= numberOfStep; i += 1) {\n                let alpha = Math.pow(i / numberOfStep, 3);\n                this._spline.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d((1 - alpha) * p.x + alpha * ndcX, (1 - alpha) * p.y + alpha * ndcY));\n                this.optimizationProblem.setTargetSpline(this._spline);\n                try {\n                    this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                    if (this.optimizer.success === true) {\n                        this.setSpline(this.optimizationProblem.spline.clone());\n                    }\n                }\n                catch (e) {\n                    this._spline.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d(p.x, p.y));\n                    console.log(e);\n                }\n            }\n        }\n    }\n    toggleActiveControlOfCurvatureExtrema() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    toggleActiveControlOfInflections() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n}\nexports.AbstractCurveModel = AbstractCurveModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PeriodicBSplineR1toR2_1 = require(\"../bsplines/PeriodicBSplineR1toR2\");\nconst OptimizationProblemPeriodicBSplineR1toR2_1 = require(\"../bsplinesOptimizationProblems/OptimizationProblemPeriodicBSplineR1toR2\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nconst AbstractCurveModel_1 = require(\"./AbstractCurveModel\");\nclass ClosedCurveModel extends AbstractCurveModel_1.AbstractCurveModel {\n    constructor() {\n        super();\n        const px0 = 0, px1 = 0.15, px2 = 0.27, px3 = 0.3;\n        const py0 = 0, py2 = 0.35, py4 = 0.6, py5 = 0.72;\n        const cp = [[-px2, -py2], [-px3, py0], [-px2, py2], [-px1, py4],\n            [px0, py5], [px1, py4], [px2, py2], [px3, py0],\n            [px2, -py2], [px1, -py4], [px0, -py5], [-px1, -py4],\n            [-px2, -py2], [-px3, py0], [-px2, py2]];\n        let cp1 = [];\n        for (let cpi of cp) {\n            cp1.push([cpi[1], -cpi[0]]);\n        }\n        const knots = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n        this._spline = PeriodicBSplineR1toR2_1.create_PeriodicBSplineR1toR2(cp1, knots);\n        this.optimizationProblem = new OptimizationProblemPeriodicBSplineR1toR2_1.OptimizationProblemPeriodicBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n    }\n    get isClosed() {\n        return true;\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n    addControlPoint(controlPointIndex) {\n        let cp = controlPointIndex;\n        if (cp != null) {\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this._spline.freeControlPoints.length - 1) {\n                cp -= 1;\n            }\n            const grevilleAbscissae = this._spline.grevilleAbscissae();\n            let meanGA = (grevilleAbscissae[cp] + grevilleAbscissae[cp + 1]) / 2;\n            if (meanGA < this._spline.knots[this._spline.degree]) {\n                let index = this._spline.degree;\n                meanGA = (this._spline.knots[index] + this._spline.knots[index + 1]) / 2;\n            }\n            else if (meanGA > this._spline.knots[this._spline.knots.length - this._spline.degree - 1]) {\n                let index = this._spline.knots.length - this._spline.degree - 1;\n                meanGA = (this._spline.knots[index] + this._spline.knots[index - 1]) / 2;\n            }\n            this._spline.insertKnot(meanGA);\n        }\n        this.optimizationProblem = new OptimizationProblemPeriodicBSplineR1toR2_1.OptimizationProblemPeriodicBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OptimizationProblemPeriodicBSplineR1toR2_1.OptimizationProblemPeriodicBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n}\nexports.ClosedCurveModel = ClosedCurveModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"../bsplinesOptimizationProblems/AbstractOptimizationProblemBSplineR1toR2\");\nconst AbstractCurveModel_1 = require(\"./AbstractCurveModel\");\nconst PeriodicBSplineR1toR2_1 = require(\"../bsplines/PeriodicBSplineR1toR2\");\nconst OptimizationProblemPeriodicBSplineR1toR2QuasiNewton_1 = require(\"../bsplinesOptimizationProblems/OptimizationProblemPeriodicBSplineR1toR2QuasiNewton\");\nclass ClosedCurveModelAlternative01 extends AbstractCurveModel_1.AbstractCurveModel {\n    constructor() {\n        super();\n        const px0 = 0, px1 = 0.15, px2 = 0.27, px3 = 0.3;\n        const py0 = 0, py2 = 0.35, py4 = 0.6, py5 = 0.72;\n        const cp = [[-px2, -py2], [-px3, py0], [-px2, py2], [-px1, py4],\n            [px0, py5], [px1, py4], [px2, py2], [px3, py0],\n            [px2, -py2], [px1, -py4], [px0, -py5], [-px1, -py4],\n            [-px2, -py2], [-px3, py0], [-px2, py2]];\n        let cp1 = [];\n        for (let cpi of cp) {\n            cp1.push([cpi[1], -cpi[0]]);\n        }\n        const knots = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n        this._splineTarget = PeriodicBSplineR1toR2_1.create_PeriodicBSplineR1toR2(cp1, knots);\n        this._spline = this._splineTarget.clone();\n        this.optimizationProblem = new OptimizationProblemPeriodicBSplineR1toR2QuasiNewton_1.OptimizationProblemPeriodicBSplineR1toR2QuasiNewton(this._splineTarget.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    get isClosed() {\n        return true;\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.clone());\n        }\n        for (let observer of this.observersCP) {\n            observer.update(this._splineTarget.clone());\n        }\n    }\n    moveControlPoint(controlPointIndex, deltaX, deltaY) {\n        this._splineTarget.moveControlPoint(controlPointIndex, deltaX, deltaY);\n        if (deltaX * deltaX + deltaY * deltaY > 0) {\n            this.notifyObservers();\n        }\n    }\n    setControlPointPosition(controlPointIndex, x, y) {\n        this._splineTarget.setControlPointPosition(controlPointIndex, new Vector2d_1.Vector2d(x, y));\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y);\n        }\n        else {\n            this._spline = this._splineTarget.clone();\n        }\n        this.notifyObservers();\n    }\n    optimize(selectedControlPoint, ndcX, ndcY) {\n        if (this.optimizationProblem && this.optimizer) {\n            const p = this._splineTarget.freeControlPoints[selectedControlPoint].clone();\n            this._splineTarget.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d(ndcX, ndcY));\n            this.optimizationProblem.setTargetSpline(this._splineTarget);\n            try {\n                this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                if (this.optimizer.success === true) {\n                    this.setSpline(this.optimizationProblem.spline.clone());\n                }\n            }\n            catch (e) {\n                this._splineTarget.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d(p.x, p.y));\n                console.log(e);\n            }\n        }\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n    addControlPoint(controlPointIndex) {\n        let cp = controlPointIndex;\n        if (cp != null) {\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this._spline.freeControlPoints.length - 1) {\n                cp -= 1;\n            }\n            const grevilleAbscissae = this._spline.grevilleAbscissae();\n            let meanGA = (grevilleAbscissae[cp] + grevilleAbscissae[cp + 1]) / 2;\n            if (meanGA < this._spline.knots[this._spline.degree]) {\n                let index = this._spline.degree;\n                meanGA = (this._spline.knots[index] + this._spline.knots[index + 1]) / 2;\n            }\n            else if (meanGA > this._spline.knots[this._spline.knots.length - this._spline.degree - 1]) {\n                let index = this._spline.knots.length - this._spline.degree - 1;\n                meanGA = (this._spline.knots[index] + this._spline.knots[index - 1]) / 2;\n            }\n            this._splineTarget.insertKnot(meanGA);\n            this._spline.insertKnot(meanGA);\n        }\n        this.optimizationProblem = new OptimizationProblemPeriodicBSplineR1toR2QuasiNewton_1.OptimizationProblemPeriodicBSplineR1toR2QuasiNewton(this._splineTarget.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OptimizationProblemPeriodicBSplineR1toR2QuasiNewton_1.OptimizationProblemPeriodicBSplineR1toR2QuasiNewton(this._splineTarget.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    toggleActiveControlOfCurvatureExtrema() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    toggleActiveControlOfInflections() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n}\nexports.ClosedCurveModelAlternative01 = ClosedCurveModelAlternative01;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BSplineR1toR2_1 = require(\"../bsplines/BSplineR1toR2\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst OptimizationProblemBSplineR1toR2_1 = require(\"../bsplinesOptimizationProblems/OptimizationProblemBSplineR1toR2\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nconst AbstractCurveModel_1 = require(\"./AbstractCurveModel\");\nclass CurveModel extends AbstractCurveModel_1.AbstractCurveModel {\n    constructor() {\n        super();\n        /*\n        const cp0 = new Vector2d(-0.5, 0)\n        const cp1 = new Vector2d(-0.1, 0.5)\n        const cp2 = new Vector2d(0.1, 0.5)\n        const cp3 = new Vector2d(0.5, 0)\n\n        this._spline = new BSplineR1toR2([ cp0, cp1, cp2, cp3 ], [ 0, 0, 0, 0, 1, 1, 1, 1 ])\n        */\n        const cp0 = new Vector2d_1.Vector2d(-0.5, 0);\n        const cp1 = new Vector2d_1.Vector2d(-0.3, 0.5);\n        const cp2 = new Vector2d_1.Vector2d(0, 0.7);\n        const cp3 = new Vector2d_1.Vector2d(0.3, 0.5);\n        const cp4 = new Vector2d_1.Vector2d(0.5, 0);\n        this._spline = new BSplineR1toR2_1.BSplineR1toR2([cp0, cp1, cp2, cp3, cp4], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);\n        this.optimizationProblem = new OptimizationProblemBSplineR1toR2_1.OptimizationProblemBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        //this.optimizer = new QuasiNewtonOptimizer(this.optimizationProblem)\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    get isClosed() {\n        return false;\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n    addControlPoint(controlPointIndex) {\n        let cp = controlPointIndex;\n        if (cp != null) {\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this._spline.controlPoints.length - 1) {\n                cp -= 1;\n            }\n            const grevilleAbscissae = this._spline.grevilleAbscissae();\n            this._spline.insertKnot(grevilleAbscissae[cp]);\n        }\n        this.optimizationProblem = new OptimizationProblemBSplineR1toR2_1.OptimizationProblemBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OptimizationProblemBSplineR1toR2_1.OptimizationProblemBSplineR1toR2(this._spline.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n}\nexports.CurveModel = CurveModel;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BSplineR1toR3_1 = require(\"../bsplines/BSplineR1toR3\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nclass CurveModel3d {\n    constructor() {\n        this.observers = [];\n        const cp0 = new Vector3d_1.Vector3d(-0.25, 0, -0.15);\n        const cp1 = new Vector3d_1.Vector3d(-0.15, 0.15, -0.05);\n        const cp2 = new Vector3d_1.Vector3d(0, 0.25, -0.05);\n        const cp3 = new Vector3d_1.Vector3d(0.15, 0.15, -0.05);\n        const cp4 = new Vector3d_1.Vector3d(0.25, 0, 0.05);\n        this._spline = new BSplineR1toR3_1.BSplineR1toR3([cp0, cp1, cp2, cp3, cp4], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]);\n    }\n    registerObserver(observer) {\n        this.observers.push(observer);\n    }\n    removeObserver(observer) {\n        this.observers.splice(this.observers.indexOf(observer), 1);\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.clone());\n        }\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    get isClosed() {\n        return false;\n    }\n    setControlPointPosition(controlPointIndex, x, y, z) {\n        this._spline.setControlPointPosition(controlPointIndex, new Vector3d_1.Vector3d(x, y, z));\n        this.notifyObservers();\n        /*\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y)\n        }\n        */\n    }\n}\nexports.CurveModel3d = CurveModel3d;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BSplineR1toR2_1 = require(\"../bsplines/BSplineR1toR2\");\nconst Vector2d_1 = require(\"../mathVector/Vector2d\");\nconst OptimizationProblemBSplineR1toR2WithWeigthingFactors_1 = require(\"../bsplinesOptimizationProblems/OptimizationProblemBSplineR1toR2WithWeigthingFactors\");\nconst Optimizer_1 = require(\"../optimizers/Optimizer\");\nconst AbstractOptimizationProblemBSplineR1toR2_1 = require(\"../bsplinesOptimizationProblems/AbstractOptimizationProblemBSplineR1toR2\");\nconst AbstractCurveModel_1 = require(\"./AbstractCurveModel\");\nclass CurveModelAlternative01 extends AbstractCurveModel_1.AbstractCurveModel {\n    constructor() {\n        super();\n        const cp0 = new Vector2d_1.Vector2d(-0.5, 0);\n        const cp1 = new Vector2d_1.Vector2d(-0.1, 0.5);\n        const cp2 = new Vector2d_1.Vector2d(0.1, 0.5);\n        const cp3 = new Vector2d_1.Vector2d(0.5, 0);\n        this._splineTarget = new BSplineR1toR2_1.BSplineR1toR2([cp0, cp1, cp2, cp3], [0, 0, 0, 0, 1, 1, 1, 1]);\n        this._spline = this._splineTarget.clone();\n        //this.optimizationProblem = new  OptimizationProblemBSplineR1toR2(this._splineTarget.clone(), this._spline.clone(), this.activeControl)\n        this.optimizationProblem = new OptimizationProblemBSplineR1toR2WithWeigthingFactors_1.OptimizationProblemBSplineR1toR2WithWeigthingFactors(this._splineTarget.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n    }\n    get spline() {\n        return this._spline.clone();\n    }\n    get isClosed() {\n        return false;\n    }\n    notifyObservers() {\n        for (let observer of this.observers) {\n            observer.update(this._spline.clone());\n        }\n        for (let observer of this.observersCP) {\n            observer.update(this._splineTarget.clone());\n        }\n    }\n    moveControlPoint(controlPointIndex, deltaX, deltaY) {\n        this._splineTarget.moveControlPoint(controlPointIndex, deltaX, deltaY);\n        if (deltaX * deltaX + deltaY * deltaY > 0) {\n            this.notifyObservers();\n        }\n    }\n    setControlPointPosition(controlPointIndex, x, y) {\n        this._splineTarget.setControlPointPosition(controlPointIndex, new Vector2d_1.Vector2d(x, y));\n        if (this.activeOptimizer) {\n            this.optimize(controlPointIndex, x, y);\n        }\n        else {\n            this._spline = this._splineTarget.clone();\n        }\n        this.notifyObservers();\n    }\n    optimize(selectedControlPoint, ndcX, ndcY) {\n        if (this.optimizationProblem && this.optimizer) {\n            const p = this._splineTarget.freeControlPoints[selectedControlPoint].clone();\n            this._splineTarget.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d(ndcX, ndcY));\n            this.optimizationProblem.setTargetSpline(this._splineTarget);\n            try {\n                this.optimizer.optimize_using_trust_region(10e-6, 1000, 800);\n                if (this.optimizer.success === true) {\n                    this.setSpline(this.optimizationProblem.spline.clone());\n                }\n            }\n            catch (e) {\n                this._splineTarget.setControlPointPosition(selectedControlPoint, new Vector2d_1.Vector2d(p.x, p.y));\n                console.log(e);\n            }\n        }\n    }\n    setSpline(spline) {\n        this._spline = spline;\n        this.notifyObservers();\n    }\n    addControlPoint(controlPointIndex) {\n        let cp = controlPointIndex;\n        if (cp != null) {\n            if (cp === 0) {\n                cp += 1;\n            }\n            if (cp === this._splineTarget.controlPoints.length - 1) {\n                cp -= 1;\n            }\n            const grevilleAbscissae = this._splineTarget.grevilleAbscissae();\n            this._splineTarget.insertKnot(grevilleAbscissae[cp]);\n            this._spline.insertKnot(grevilleAbscissae[cp]);\n        }\n        this.optimizationProblem = new OptimizationProblemBSplineR1toR2WithWeigthingFactors_1.OptimizationProblemBSplineR1toR2WithWeigthingFactors(this._splineTarget.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    setActiveControl() {\n        this.optimizationProblem = new OptimizationProblemBSplineR1toR2WithWeigthingFactors_1.OptimizationProblemBSplineR1toR2WithWeigthingFactors(this._splineTarget.clone(), this._spline.clone(), this.activeControl);\n        this.optimizer = new Optimizer_1.Optimizer(this.optimizationProblem);\n        this.notifyObservers();\n    }\n    toggleActiveControlOfCurvatureExtrema() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n    toggleActiveControlOfInflections() {\n        if (!this.activeOptimizer) {\n            this.activeOptimizer = true;\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.curvatureExtrema) {\n            this.activeControl = AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.both;\n        }\n        else if (this.activeControl == AbstractOptimizationProblemBSplineR1toR2_1.ActiveControl.inflections) {\n            this.activeOptimizer = false;\n        }\n        if (this.activeOptimizer) {\n            this.setActiveControl();\n        }\n    }\n}\nexports.CurveModelAlternative01 = CurveModelAlternative01;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TrustRegionSubproblem_1 = require(\"./TrustRegionSubproblem\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst SymmetricMatrix_1 = require(\"../linearAlgebra/SymmetricMatrix\");\nconst CholeskyDecomposition_1 = require(\"../linearAlgebra/CholeskyDecomposition\");\nclass Optimizer {\n    constructor(o) {\n        this.o = o;\n        this.success = false;\n        if (this.o.f.length !== this.o.gradient_f.shape[0]) {\n            console.log(\"Problem about f length and gradient_f shape 0 is in the Optimizer Constructor\");\n        }\n    }\n    optimize_using_trust_region(epsilon = 10e-8, maxTrustRadius = 10, maxNumSteps = 800) {\n        this.success = false;\n        // Bibliographic reference: Numerical Optimization, second edition, Jorge Nocedal and Stephen J. Wright, p. 69\n        let numSteps = 0;\n        let t = this.o.numberOfConstraints / this.o.f0;\n        //let t = 10 / this.o.f0\n        let trustRadius = 0.1;\n        let rho;\n        const eta = 0.1; // [0, 1/4)\n        const mu = 10; // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 569\n        let counter = 0;\n        let numStepsX = 0;\n        //while (this.o.numberOfConstraints / t > epsilon) {\n        while (10 / t > epsilon) {\n            //console.log(t)\n            while (true) {\n                counter += 1;\n                numSteps += 1;\n                if (this.o.f.length !== this.o.gradient_f.shape[0]) {\n                    console.log(\"Problem about f length and gradient_f shape 0 is in the function optimize_using_trust_region\");\n                }\n                let b = this.barrier(this.o.f, this.o.gradient_f, this.o.hessian_f);\n                let gradient = MathVectorBasicOperations_1.saxpy2(t, this.o.gradient_f0, b.gradient);\n                let hessian = b.hessian.plusSymmetricMatrixMultipliedByValue(this.o.hessian_f0, t);\n                let trustRegionSubproblem = new TrustRegionSubproblem_1.TrustRegionSubproblem(gradient, hessian);\n                let tr = trustRegionSubproblem.solve(trustRadius);\n                let fStep = this.o.fStep(tr.step);\n                let numSteps2 = 0;\n                while (Math.max.apply(null, fStep) >= 0) {\n                    numSteps2 += 1;\n                    trustRadius *= 0.25;\n                    tr = trustRegionSubproblem.solve(trustRadius);\n                    fStep = this.o.fStep(tr.step);\n                    if (numSteps2 > 100) {\n                        throw new Error(\"maxSteps2 > 100\");\n                    }\n                }\n                let barrierValueStep = this.barrierValue(fStep);\n                let actualReduction = t * (this.o.f0 - this.o.f0Step(tr.step)) + (b.value - barrierValueStep);\n                let predictedReduction = -MathVectorBasicOperations_1.dotProduct(gradient, tr.step) - 0.5 * hessian.quadraticForm(tr.step);\n                rho = actualReduction / predictedReduction;\n                if (rho < 0.25) {\n                    trustRadius *= 0.25;\n                }\n                else if (rho > 0.75 && tr.hitsBoundary) {\n                    trustRadius = Math.min(2 * trustRadius, maxTrustRadius);\n                }\n                if (rho > eta) {\n                    this.o.step(tr.step);\n                    numStepsX += 1;\n                }\n                if (numSteps > maxNumSteps) {\n                    return;\n                }\n                if ((new CholeskyDecomposition_1.CholeskyDecomposition(hessian).success)) {\n                    let newtonDecrementSquared = -MathVectorBasicOperations_1.dotProduct(gradient, tr.step);\n                    if (newtonDecrementSquared < 0) {\n                        throw new Error(\"newtonDecrementSquared is smaller than zero\");\n                    }\n                    if (newtonDecrementSquared < epsilon) {\n                        break;\n                    }\n                }\n                if (trustRadius < 10e-18) {\n                    console.log(b);\n                    throw new Error(\"trust Radius < 10e-18\");\n                }\n            }\n            if (trustRadius > 0.001) {\n                t *= mu;\n            }\n            else {\n                t *= 100 * mu;\n                //console.log(\"100*mu\")\n            }\n        }\n        this.success = true;\n        if (numSteps > 100) {\n            console.log(\"numSteps: \" + numSteps);\n            console.log(\"t: \" + t);\n            console.log(\"trustRadius: \" + trustRadius);\n        }\n        //console.log(counter)\n    }\n    optimize_using_line_search(epsilon = 10e-6, maxNumSteps = 300) {\n        // Bibliographic reference: Numerical Optimization, second edition, Jorge Nocedal and Stephen J. Wright, p. 69\n        let numSteps = 0;\n        let t = this.o.numberOfConstraints / this.o.f0;\n        let rho;\n        const eta = 0.1; // [0, 1/4)\n        const mu = 10; // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 569\n        while (this.o.numberOfConstraints / t > epsilon) {\n            while (true) {\n                numSteps += 1;\n                const b = this.barrier(this.o.f, this.o.gradient_f, this.o.hessian_f);\n                const gradient = MathVectorBasicOperations_1.saxpy2(t, this.o.gradient_f0, b.gradient);\n                const hessian = b.hessian.plusSymmetricMatrixMultipliedByValue(this.o.hessian_f0, t);\n                const newtonStep = this.computeNewtonStep(gradient, hessian);\n                const stepRatio = this.backtrackingLineSearch(t, newtonStep, this.o.f0, b.value, this.o.gradient_f0, b.gradient);\n                const step = MathVectorBasicOperations_1.multiplyVectorByScalar(newtonStep, stepRatio);\n                this.o.step(step);\n                if (numSteps > maxNumSteps) {\n                    console.log(\"numSteps > maxNumSteps\");\n                    return;\n                }\n                let newtonDecrementSquared = this.newtonDecrementSquared(step, t, this.o.gradient_f0, b.gradient);\n                if (newtonDecrementSquared < 0) {\n                    throw new Error(\"newtonDecrementSquared is smaller than zero\");\n                }\n                if (newtonDecrementSquared < epsilon) {\n                    break;\n                }\n            }\n            t *= mu;\n        }\n    }\n    newtonDecrementSquared(newtonStep, t, gradient_f0, barrierGradient) {\n        return -MathVectorBasicOperations_1.dotProduct(MathVectorBasicOperations_1.saxpy2(t, gradient_f0, barrierGradient), newtonStep);\n    }\n    barrierValue(f) {\n        let result = 0;\n        const n = f.length;\n        for (let i = 0; i < n; i += 1) {\n            result -= Math.log(-f[i]);\n        }\n        return result;\n    }\n    barrierGradient(f, gradient_f) {\n        let result = MathVectorBasicOperations_1.zeroVector(gradient_f.shape[1]);\n        const n = f.length;\n        const m = gradient_f.shape[1];\n        if (n !== gradient_f.shape[0]) {\n            throw new Error(\"barrierGradient f and gradient_f dimensions do not match\");\n        }\n        for (let i = 0; i < n; i += 1) {\n            for (let j = 0; j < m; j += 1) {\n                if (f[i] === 0) {\n                    throw new Error(\"barrierGradient makes a division by zero\");\n                }\n                result[j] += -gradient_f.get(i, j) / f[i];\n            }\n        }\n        return result;\n    }\n    barrierHessian(f, gradient_f, hessian_f) {\n        // Bibliographic reference: Convex Optimization, Stephen Boyd and Lieven Vandenberghe, p. 564\n        const m = gradient_f.shape[0];\n        const n = gradient_f.shape[1];\n        let result = new SymmetricMatrix_1.SymmetricMatrix(n);\n        // barrier hessian first term\n        for (let i = 0; i < m; i += 1) {\n            for (let k = 0; k < n; k += 1) {\n                for (let l = 0; l <= k; l += 1) {\n                    result.addAt(k, l, gradient_f.get(i, k) * gradient_f.get(i, l) / (f[i] * f[i]));\n                }\n            }\n        }\n        // barrier hessian second term\n        if (hessian_f) {\n            for (let i = 0; i < n; i += 1) {\n                for (let j = 0; j <= i; j += 1) {\n                    for (let k = 0; k < f.length; k += 1) {\n                        if (hessian_f.length != f.length) {\n                            console.log(\"f.length: \" + f.length);\n                            console.log(\"hessian_f.length: \" + hessian_f.length);\n                            throw new Error(\"hessian_f.length != f.length\");\n                        }\n                        result.addAt(i, j, -hessian_f[k].get(i, j) / f[k]);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    barrier(f, gradient_f, hessian_f) {\n        return { value: this.barrierValue(f),\n            gradient: this.barrierGradient(f, gradient_f),\n            hessian: this.barrierHessian(f, gradient_f, hessian_f)\n        };\n    }\n    backtrackingLineSearch(t, newtonStep, f0, barrierValue, gradient_f0, barrierGradient) {\n        const alpha = 0.2;\n        const beta = 0.5;\n        let result = 1;\n        let step = newtonStep.slice();\n        while (Math.max(...this.o.fStep(step)) > 0) {\n            result *= beta;\n            step = MathVectorBasicOperations_1.multiplyVectorByScalar(newtonStep, result);\n        }\n        while (t * this.o.f0Step(step) + this.barrierValue(this.o.fStep(step)) > t * f0 + barrierValue\n            + alpha * result * MathVectorBasicOperations_1.dotProduct(MathVectorBasicOperations_1.addTwoVectors(MathVectorBasicOperations_1.multiplyVectorByScalar(gradient_f0, t), barrierGradient), newtonStep)) {\n            result *= beta;\n            step = MathVectorBasicOperations_1.multiplyVectorByScalar(newtonStep, result);\n        }\n        return result;\n    }\n    computeNewtonStep(gradient, hessian) {\n        let choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessian);\n        if (choleskyDecomposition.success === false) {\n            console.log(\"choleskyDecomposition failed\");\n        }\n        return choleskyDecomposition.solve(MathVectorBasicOperations_1.multiplyVectorByScalar(gradient, -1));\n    }\n}\nexports.Optimizer = Optimizer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SquareMatrix_1 = require(\"../linearAlgebra/SquareMatrix\");\nconst MathVectorBasicOperations_1 = require(\"../linearAlgebra/MathVectorBasicOperations\");\nconst CholeskyDecomposition_1 = require(\"../linearAlgebra/CholeskyDecomposition\");\n// Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 187\n// note: lambda is never negative\nvar lambdaRange;\n(function (lambdaRange) {\n    lambdaRange[lambdaRange[\"N\"] = 0] = \"N\";\n    lambdaRange[lambdaRange[\"L\"] = 1] = \"L\";\n    lambdaRange[lambdaRange[\"G\"] = 2] = \"G\";\n    lambdaRange[lambdaRange[\"F\"] = 3] = \"F\";\n})(lambdaRange || (lambdaRange = {}));\n/**\n * A trust region subproblem solver\n */\nclass TrustRegionSubproblem {\n    /**\n     * Create the trust region subproblem solver\n     * @param gradient The gradient of the objective function to minimize\n     * @param hessian The hessian of the objective function to minimize\n     * @param k_easy Optional value in the range (0, 1)\n     * @param k_hard Optional value in the range (0, 1)\n     */\n    constructor(gradient, hessian, k_easy = 0.1, k_hard = 0.2) {\n        this.gradient = gradient;\n        this.hessian = hessian;\n        this.k_easy = k_easy;\n        this.k_hard = k_hard;\n        this.CLOSE_TO_ZERO = 10e-8;\n        this.numberOfIterations = 0;\n        this.lambda = { current: 0, lowerBound: 0, upperBound: 0 };\n        this.hitsBoundary = true;\n        this.step = [];\n        this.stepSquaredNorm = 0;\n        this.stepNorm = 0;\n        this.range = lambdaRange.F;\n        this.lambdaPlus = 0;\n        this.hardCase = false;\n        this.gNorm = MathVectorBasicOperations_1.norm(this.gradient);\n        if (MathVectorBasicOperations_1.containsNaN(gradient)) {\n            throw new Error(\"The gradient parameter passed to the TrustRegionSubproblem constructor contains NaN\");\n        }\n        if (hessian.containsNaN()) {\n            throw new Error(\"The hessian parameter passed to the TrustRegionSubproblem to constructor contains NaN\");\n        }\n        this.cauchyPoint = MathVectorBasicOperations_1.zeroVector(this.gradient.length);\n    }\n    /**\n     * Find the nearly exact trust region subproblem minimizer\n     * @param trustRegionRadius The trust region radius\n     * @returns The vector .step and the boolean .hitsBoundary\n     */\n    solve(trustRegionRadius) {\n        // Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 193\n        // see also the list of errata: ftp://ftp.numerical.rl.ac.uk/pub/trbook/trbook-errata.pdf for Algorithm 7.3.4 Step 1a\n        this.cauchyPoint = this.computeCauchyPoint(trustRegionRadius);\n        this.lambda = this.initialLambdas(trustRegionRadius);\n        this.numberOfIterations = 0;\n        const maxNumberOfIterations = 300;\n        while (true) {\n            this.numberOfIterations += 1;\n            // step 1.\n            let hessianPlusLambda = this.hessian.addValueOnDiagonal(this.lambda.current);\n            let choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n            //We have found the exact lambda, however the hessian is indefinite\n            //The idea is then to find an approximate solution increasing the lambda value by EPSILON\n            if (this.lambda.upperBound === this.lambda.lowerBound && !choleskyDecomposition.success) {\n                const EPSILON = 10e-6;\n                this.lambda.upperBound += EPSILON;\n                this.lambda.current += EPSILON;\n                hessianPlusLambda = this.hessian.addValueOnDiagonal(this.lambda.current);\n                choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n                this.range = lambdaRange.G;\n            }\n            // step 1a.\n            this.update_step_and_range(trustRegionRadius, choleskyDecomposition);\n            if (this.interiorConvergence()) {\n                break;\n            }\n            // step 2.\n            this.update_lower_and_upper_bounds();\n            // step 3.\n            this.update_lambda_lambdaPlus_lowerBound_and_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition);\n            // step 4.\n            if (this.check_for_termination_and_update_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition)) {\n                break;\n            }\n            // step 5.\n            this.update_lambda();\n            if (this.numberOfIterations > maxNumberOfIterations) {\n                console.log(\"gradient: \" + this.gradient);\n                console.log(\"hessian: \" + this.hessian.getData());\n                console.log(\"trust region radius: \" + trustRegionRadius);\n                throw new Error(\"Trust region subproblem maximum number of step exceeded\");\n            }\n        }\n        //console.log(this.numberOfIterations)\n        return {\n            step: this.step,\n            hitsBoundary: this.hitsBoundary,\n            hardCase: this.hardCase\n        };\n    }\n    /**\n     * An interior solution with a zero Lagrangian multiplier implies interior convergence\n     */\n    interiorConvergence() {\n        // A range G corresponds to a step smaller than the trust region radius\n        if (this.lambda.current === 0 && this.range === lambdaRange.G) {\n            this.hitsBoundary = false;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Updates the lambdaRange set. Updates the step if the factorization succeeded.\n     * @param trustRegionRadius Trust region radius\n     * @param choleskyDecomposition Cholesky decomposition\n     */\n    update_step_and_range(trustRegionRadius, choleskyDecomposition) {\n        if (choleskyDecomposition.success) {\n            this.step = choleskyDecomposition.solve(MathVectorBasicOperations_1.multiplyVectorByScalar(this.gradient, -1));\n            this.stepSquaredNorm = MathVectorBasicOperations_1.squaredNorm(this.step);\n            this.stepNorm = Math.sqrt(this.stepSquaredNorm);\n            if (this.stepNorm < trustRegionRadius) {\n                this.range = lambdaRange.G;\n            }\n            else {\n                this.range = lambdaRange.L; // once a Newton iterate falls into L it stays there\n            }\n        }\n        else {\n            this.range = lambdaRange.N;\n        }\n    }\n    /**\n     * Update lambda.upperBound or lambda.lowerBound\n     */\n    update_lower_and_upper_bounds() {\n        if (this.range === lambdaRange.G) {\n            this.lambda.upperBound = this.lambda.current;\n        }\n        else {\n            this.lambda.lowerBound = this.lambda.current;\n        }\n    }\n    /**\n     * Update lambdaPlus, lambda.lowerBound, lambda.current and step\n     * @param trustRegionRadius Trust region radius\n     * @param hessianPlusLambda Hessian + lambda.current * I\n     * @param choleskyDecomposition The Cholesky Decomposition of Hessian + lambda.current * I\n     */\n    update_lambda_lambdaPlus_lowerBound_and_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition) {\n        // Step 3. If lambda in F\n        if (this.range === lambdaRange.L || this.range === lambdaRange.G) {\n            // Step 3a. Solve Lw = step and set lambdaPlus (algorithm 7.3.1)\n            let w = solveLowerTriangular(choleskyDecomposition.g, this.step);\n            let wSquaredNorm = MathVectorBasicOperations_1.squaredNorm(w);\n            this.lambdaPlus = this.lambda.current + (this.stepNorm / trustRegionRadius - 1) * (this.stepSquaredNorm / wSquaredNorm);\n            // Step 3b. If lambda in G\n            if (this.range === lambdaRange.G) {\n                // i. Use the LINPACK method to find a unit vector u to make <u, H(lambda), u> small.\n                let s_min = estimateSmallestSingularValue(choleskyDecomposition.g);\n                // ii. Replace lambda.lowerBound by max [lambda_lb, lambda - <u, H(lambda), u>].\n                this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambda.current - Math.pow(s_min.value, 2));\n                // iii. Find the root alpha of the equation || step + alpha u || = trustRegionRadius which makes\n                // the model q(step + alpha u) smallest and replace step by step + alpha u\n                let intersection = getBoundariesIntersections(this.step, s_min.vector, trustRegionRadius);\n                let t;\n                if (Math.abs(intersection.tmin) < Math.abs(intersection.tmax)) {\n                    t = intersection.tmin;\n                }\n                else {\n                    t = intersection.tmax;\n                }\n                MathVectorBasicOperations_1.saxpy(t, s_min.vector, this.step);\n                this.stepSquaredNorm = MathVectorBasicOperations_1.squaredNorm(this.step);\n                this.stepNorm = Math.sqrt(this.stepSquaredNorm);\n            }\n        }\n        else {\n            // Step 3c. Use the partial factorization to find delta and v such that (H(lambda) + delta e_k e_k^T) v = 0\n            let sls = singularLeadingSubmatrix(hessianPlusLambda, choleskyDecomposition.g, choleskyDecomposition.firstNonPositiveDefiniteLeadingSubmatrixSize);\n            // Step 3d. Replace lambda.lb by max [ lambda_lb, lambda_current + delta / || v ||^2 ]\n            let vSquaredNorm = MathVectorBasicOperations_1.squaredNorm(sls.vector);\n            this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambda.current + sls.delta / vSquaredNorm);\n        }\n    }\n    /**\n     * Check for termination\n     * @param trustRegionRadius Trust region radius\n     * @param hessianPlusLambda Hessian + lambda.current * I\n     * @param choleskyDecomposition The CholeskyDecomposition of Hessian + lambda.current * I\n     */\n    check_for_termination_and_update_step(trustRegionRadius, hessianPlusLambda, choleskyDecomposition) {\n        let terminate = false;\n        // Algorithm 7.3.5, Step 1. If lambda is in F and | ||s(lambda)|| - trustRegionRadius | <= k_easy * trustRegionRadius\n        if ((this.range === lambdaRange.L || this.range === lambdaRange.G) && Math.abs(this.stepNorm - trustRegionRadius) <= this.k_easy * trustRegionRadius) {\n            // Added test to make sure that the result is better than the Cauchy point\n            let evalResult = MathVectorBasicOperations_1.dotProduct(this.gradient, this.step) + 0.5 * this.hessian.quadraticForm(this.step);\n            let evalCauchy = MathVectorBasicOperations_1.dotProduct(this.gradient, this.cauchyPoint) + 0.5 * this.hessian.quadraticForm(this.cauchyPoint);\n            if (evalResult > evalCauchy) {\n                return false;\n            }\n            else {\n                // stop with s = s(lambda)\n                this.hitsBoundary = true;\n                terminate = true;\n            }\n        }\n        if (this.range === lambdaRange.G) {\n            // Algorithm 7.3.5, Step 2. If lambda = 0 in G\n            if (this.lambda.current === 0) {\n                this.hitsBoundary = false; // since the Lagrange Multiplier is zero\n                terminate = true;\n                return terminate;\n            }\n            // Algorithm 7.3.5, Step 3. If lambda is in G and the LINPACK method gives u and alpha such that\n            // alpha^2 <u, H(lambda), u> <= k_hard ( <s(lambda), H(lambda) * s(lambda) + lambda * trustRegionRadius^2 >)\n            let s_min = estimateSmallestSingularValue(choleskyDecomposition.g);\n            let intersection = getBoundariesIntersections(this.step, s_min.vector, trustRegionRadius);\n            let t_abs_max;\n            // To do : explain better why > instead of <\n            // relative_error is smaller for <\n            // it seems that we need the worst case to make sure the result is a better solution\n            // than the Cauchy point\n            if (Math.abs(intersection.tmin) > Math.abs(intersection.tmax)) {\n                t_abs_max = intersection.tmin;\n            }\n            else {\n                t_abs_max = intersection.tmax;\n            }\n            let quadraticTerm = hessianPlusLambda.quadraticForm(this.step);\n            let relative_error = Math.pow(t_abs_max * s_min.value, 2) / (quadraticTerm + this.lambda.current * Math.pow(trustRegionRadius, 2));\n            if (relative_error <= this.k_hard) {\n                //saxpy(t_abs_min, s_min.vector, this.step) done at step 3b iii.\n                this.hitsBoundary = true;\n                this.hardCase = true;\n                terminate = true;\n            }\n        }\n        return terminate;\n    }\n    /**\n     * Update lambda.current\n     */\n    update_lambda() {\n        //step 5.\n        if (this.range === lambdaRange.L && this.gNorm !== 0) {\n            this.lambda.current = this.lambdaPlus;\n        }\n        else if (this.range === lambdaRange.G) {\n            let hessianPlusLambda = this.hessian.clone();\n            hessianPlusLambda.addValueOnDiagonal(this.lambdaPlus);\n            let choleskyDecomposition = new CholeskyDecomposition_1.CholeskyDecomposition(hessianPlusLambda);\n            // If the factorization succeeds, then lambdaPlus is in L. Otherwise, lambdaPlus is in N\n            if (choleskyDecomposition.success) {\n                this.lambda.current = this.lambdaPlus;\n            }\n            else {\n                this.lambda.lowerBound = Math.max(this.lambda.lowerBound, this.lambdaPlus);\n                // Check lambda.lb for interior convergence ???\n                this.lambda.current = updateLambda_using_equation_7_3_14(this.lambda.lowerBound, this.lambda.upperBound);\n            }\n        }\n        else {\n            this.lambda.current = updateLambda_using_equation_7_3_14(this.lambda.lowerBound, this.lambda.upperBound);\n        }\n    }\n    /**\n     * Returns the minimizer along the steepest descent (-gradient) direction subject to trust-region bound.\n     * Note: If the gradient is a zero vector then the function returns a zero vector\n     * @param trustRegionRadius The trust region radius\n     * @return The minimizer vector deta x\n     */\n    computeCauchyPoint(trustRegionRadius) {\n        // Bibliographic referece: Numerical Optimizatoin, second edition, Nocedal and Wright, p. 71-72\n        const gHg = this.hessian.quadraticForm(this.gradient);\n        const gNorm = MathVectorBasicOperations_1.norm(this.gradient);\n        // return a zero step if the gradient is zero\n        if (gNorm === 0) {\n            return MathVectorBasicOperations_1.zeroVector(this.gradient.length);\n        }\n        let result = MathVectorBasicOperations_1.multiplyVectorByScalar(this.gradient, -trustRegionRadius / gNorm);\n        if (gHg <= 0) {\n            return result;\n        }\n        let tau = Math.pow(gNorm, 3) / trustRegionRadius / gHg;\n        if (tau < 1) {\n            return MathVectorBasicOperations_1.multiplyVectorByScalar(result, tau);\n        }\n        return result;\n    }\n    /**\n     * Return an initial value, an upper bound and a lower bound for lambda.\n     * @param trustRegionRadius The trust region radius\n     * @return .current (lambda intial value) .lb (lower bound) and .ub (upper bound)\n     */\n    initialLambdas(trustRegionRadius) {\n        // Bibliographic reference : Trust-Region Methods, Conn, Gould and Toint p. 192\n        let gershgorin = gershgorin_bounds(this.hessian);\n        let hessianFrobeniusNorm = frobeniusNorm(this.hessian);\n        let hessianInfiniteNorm = 0;\n        let minHessianDiagonal = this.hessian.get(0, 0);\n        for (let i = 0; i < this.hessian.shape[0]; i += 1) {\n            let tempInfiniteNorm = 0;\n            for (let j = 0; j < this.hessian.shape[0]; j += 1) {\n                tempInfiniteNorm += Math.abs(this.hessian.get(i, j));\n            }\n            hessianInfiniteNorm = Math.max(hessianInfiniteNorm, tempInfiniteNorm);\n            minHessianDiagonal = Math.min(minHessianDiagonal, this.hessian.get(i, i));\n        }\n        let lowerBound = Math.max(0, Math.max(-minHessianDiagonal, MathVectorBasicOperations_1.norm(this.gradient) / trustRegionRadius - Math.min(gershgorin.upperBound, Math.min(hessianFrobeniusNorm, hessianInfiniteNorm))));\n        let upperBound = Math.max(0, MathVectorBasicOperations_1.norm(this.gradient) / trustRegionRadius + Math.min(-gershgorin.lowerBound, Math.min(hessianFrobeniusNorm, hessianInfiniteNorm)));\n        let lambda_initial;\n        if (lowerBound === 0) {\n            lambda_initial = 0;\n        }\n        else {\n            lambda_initial = updateLambda_using_equation_7_3_14(lowerBound, upperBound);\n        }\n        return {\n            current: lambda_initial,\n            lowerBound: lowerBound,\n            upperBound: upperBound\n        };\n    }\n}\nexports.TrustRegionSubproblem = TrustRegionSubproblem;\n/**\n *\n * @param A\n * @param L\n * @param k\n * @return dela, vector\n * @throws If k < 0\n */\nfunction singularLeadingSubmatrix(A, L, k) {\n    if (k < 0) {\n        throw new Error('k should not be a negative value');\n    }\n    let delta = 0;\n    let l = new SquareMatrix_1.SquareMatrix(k);\n    let v = [];\n    let u = MathVectorBasicOperations_1.zeroVector(k);\n    for (let j = 0; j < k - 1; j += 1) {\n        delta += Math.pow(L.get(k - 1, j), 2);\n    }\n    delta -= A.get(k - 1, k - 1);\n    for (let i = 0; i < k - 1; i += 1) {\n        for (let j = 0; j <= i; j += 1) {\n            l.set(i, j, L.get(i, j));\n        }\n        u[i] = L.get(k - 1, i);\n    }\n    v = MathVectorBasicOperations_1.zeroVector(A.shape[0]);\n    v[k - 1] = 1;\n    if (k !== 1) {\n        let vtemp = solveLowerTriangular(l, u);\n        for (let i = 0; i < k - 1; i += 1) {\n            v[i] = vtemp[i];\n        }\n    }\n    return {\n        delta: delta,\n        vector: v\n    };\n}\n/**\n * Estimate the smallest singular value\n * @param lowerTriangular\n */\nfunction estimateSmallestSingularValue(lowerTriangular) {\n    // Bibliographic reference :  Golub, G. H., Van Loan, C. F. (2013), \"Matrix computations\". Forth Edition. JHU press. pp. 140-142.\n    // Web reference: https://github.com/scipy/scipy/blob/master/scipy/optimize/_trustregion_exact.py\n    const n = lowerTriangular.shape[0];\n    let p = MathVectorBasicOperations_1.zeroVector(n);\n    let y = MathVectorBasicOperations_1.zeroVector(n);\n    let p_plus = [];\n    let p_minus = [];\n    for (let k = 0; k < n; k += 1) {\n        let y_plus = (1 - p[k]) / lowerTriangular.get(k, k);\n        let y_minus = (-1 - p[k]) / lowerTriangular.get(k, k);\n        for (let i = k + 1; i < n; i += 1) {\n            p_plus.push(p[i] + lowerTriangular.get(i, k) * y_plus);\n            p_minus.push(p[i] + lowerTriangular.get(i, k) * y_minus);\n        }\n        if (Math.abs(y_plus) + MathVectorBasicOperations_1.norm1(p_plus) >= Math.abs(y_minus) + MathVectorBasicOperations_1.norm1(p_minus)) {\n            y[k] = y_plus;\n            for (let i = k + 1; i < n; i += 1) {\n                p[i] = p_plus[i - k - 1];\n            }\n        }\n        else {\n            y[k] = y_minus;\n            for (let i = k + 1; i < n; i += 1) {\n                p[i] = p_minus[i - k - 1];\n            }\n        }\n    }\n    let v = solveUpperTriangular(lowerTriangular, y);\n    let vNorm = MathVectorBasicOperations_1.norm(v);\n    let yNorm = MathVectorBasicOperations_1.norm(y);\n    if (vNorm === 0) {\n        throw new Error(\"divideVectorByScalar division by zero\");\n    }\n    return {\n        value: yNorm / vNorm,\n        vector: MathVectorBasicOperations_1.divideVectorByScalar(v, vNorm)\n    };\n}\n/**\n * Solve the linear problem upper triangular matrix UT x = y\n * @param lowerTriangular The transpose of the upper triangular matrix\n * @param y The vector y\n */\nfunction solveUpperTriangular(lowerTriangular, y) {\n    let x = y.slice();\n    const n = lowerTriangular.shape[0];\n    // LT x = y\n    for (let i = n - 1; i >= 0; i -= 1) {\n        let sum = x[i];\n        for (let k = i + 1; k < n; k += 1) {\n            sum -= lowerTriangular.get(k, i) * x[k];\n        }\n        x[i] = sum / lowerTriangular.get(i, i);\n    }\n    return x;\n}\n/**\n * Solve the linear problem lower triangular matrix LT x = b\n * @param lowerTriangular The lower triangular matrix\n * @param b The vector b\n */\nfunction solveLowerTriangular(lowerTriangular, b) {\n    if (lowerTriangular.shape[0] !== b.length) {\n        throw new Error('solveLowerTriangular: matrix and vector are not the same sizes');\n    }\n    let x = b.slice();\n    const n = lowerTriangular.shape[0];\n    // L x = b\n    for (let i = 0; i < n; i += 1) {\n        let sum = b[i];\n        for (let k = i - 1; k >= 0; k -= 1) {\n            sum -= lowerTriangular.get(i, k) * x[k];\n        }\n        x[i] = sum / lowerTriangular.get(i, i);\n    }\n    return x;\n}\n/**\n * The frobenius norm\n * @param matrix The matrix\n * @return The square root of the sum of every elements squared\n */\nfunction frobeniusNorm(matrix) {\n    let result = 0;\n    const m = matrix.shape[0];\n    const n = matrix.shape[1];\n    for (let i = 0; i < m; i += 1) {\n        for (let j = 0; j < n; j += 1) {\n            result += Math.pow(matrix.get(i, j), 2);\n        }\n    }\n    result = Math.sqrt(result);\n    return result;\n}\nexports.frobeniusNorm = frobeniusNorm;\n/**\n* Given a symmetric matrix, compute the Gershgorin upper and lower bounds for its eigenvalues\n* @param matrix Symmetric Matrix\n* @return .lb (lower bound) and .ub (upper bound)\n*/\nfunction gershgorin_bounds(matrix) {\n    // Bibliographic Reference : Trust-Region Methods, Conn, Gould and Toint p. 19\n    // Gershgorin Bounds : All eigenvalues of a matrix A lie in the complex plane within the intersection\n    // of n discs centered at a_(i, i) and of radii : sum of a_(i, j) for 1  i  n and  j != i\n    // When the matrix is symmetric, the eigenvalues are real and the discs become intervals on the real\n    // line\n    const m = matrix.shape[0];\n    const n = matrix.shape[1];\n    let matrixRowSums = [];\n    for (let i = 0; i < m; i += 1) {\n        let rowSum = 0;\n        for (let j = 0; j < n; j += 1) {\n            rowSum += Math.abs(matrix.get(i, j));\n        }\n        matrixRowSums.push(rowSum);\n    }\n    let matrixDiagonal = [];\n    let matrixDiagonalAbsolute = [];\n    for (let i = 0; i < m; i += 1) {\n        matrixDiagonal.push(matrix.get(i, i));\n        matrixDiagonalAbsolute.push(Math.abs(matrix.get(i, i)));\n    }\n    let lb = [];\n    let ub = [];\n    for (let i = 0; i < m; i += 1) {\n        lb.push(matrixDiagonal[i] + matrixDiagonalAbsolute[i] - matrixRowSums[i]);\n        ub.push(matrixDiagonal[i] - matrixDiagonalAbsolute[i] + matrixRowSums[i]);\n    }\n    let lowerBound = Math.min.apply(null, lb);\n    let upperBound = Math.max.apply(null, ub);\n    return {\n        lowerBound: lowerBound,\n        upperBound: upperBound\n    };\n}\nexports.gershgorin_bounds = gershgorin_bounds;\n/**\n * Solve the scalar quadratic equation ||z + t d|| == trust_radius\n * This is like a line-sphere intersection\n * @param z Vector\n * @param d Vector\n * @param trustRegionRadius\n * @returns The two values of t, sorted from low to high\n */\nfunction getBoundariesIntersections(z, d, trustRegionRadius) {\n    if (MathVectorBasicOperations_1.isZeroVector(d)) {\n        throw new Error(\"In getBoundariesInstersections the d vector cannot be the zero vector\");\n    }\n    const a = MathVectorBasicOperations_1.squaredNorm(d);\n    const b = 2 * MathVectorBasicOperations_1.dotProduct(z, d);\n    const c = MathVectorBasicOperations_1.squaredNorm(z) - trustRegionRadius * trustRegionRadius;\n    const sqrtDiscriminant = Math.sqrt(b * b - 4 * a * c);\n    let sign_b = MathVectorBasicOperations_1.sign(b);\n    if (sign_b === 0) {\n        sign_b = 1;\n    }\n    const aux = b + sqrtDiscriminant * sign_b;\n    const ta = -aux / (2 * a);\n    const tb = -2 * c / aux;\n    return {\n        tmin: Math.min(ta, tb),\n        tmax: Math.max(ta, tb)\n    };\n}\nexports.getBoundariesIntersections = getBoundariesIntersections;\nfunction updateLambda_using_equation_7_3_14(lowerBound, upperBound, theta = 0.01) {\n    // Bibliographic Reference: Trust-Region Methods, Conn, Gould and Toint p. 190\n    return Math.max(Math.sqrt(upperBound * lowerBound), lowerBound + theta * (upperBound - lowerBound));\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mat4_1 = require(\"../webgl/mat4\");\nconst mat3_1 = require(\"../webgl/mat3\");\nconst quat_1 = require(\"../webgl/quat\");\nclass AbstractObject3dShadowView {\n    constructor(object3dShadowShaders, lightDirection) {\n        this.object3dShadowShaders = object3dShadowShaders;\n        this.lightDirection = lightDirection;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint16Array([]);\n        this.orientation = new Float32Array([0, 0, 0, 1]);\n        this.orientation = quat_1.setAxisAngle(new Float32Array([1, 0, 0]), -Math.PI / 2);\n    }\n    renderFrame() {\n        let gl = this.object3dShadowShaders.gl, a_Position = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.object3dShadowShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        this.setUniforms();\n        this.object3dShadowShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    initVertexBuffers(gl) {\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShadowShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Normal < 0) {\n            console.log('Failed to get the storage location of a_Normal');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    updateBuffers() {\n        const gl = this.object3dShadowShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    setUniforms() {\n        const gl = this.object3dShadowShaders.gl;\n        const translate1 = mat4_1.translate(mat4_1.identity_mat4(), new Float32Array([0, 0, 0]));\n        //const translate2 = translate(identity_mat4(), new Float32Array([0, 0, 0]))\n        //const model = multiply(translate2, multiply(fromQuat(this.orientation), translate1))\n        const model = mat4_1.multiply(mat4_1.fromQuat(this.orientation), translate1);\n        //const model = identity_mat4()\n        const view = this.viewMatrix();\n        const projection = this.projectionMatrix();\n        const mv = mat4_1.multiply(view, model);\n        const mvp = mat4_1.multiply(projection, mv);\n        const ambientLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"Ambient\");\n        const lightColorLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"LightColor\");\n        const modelViewProjectionMatrixLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"ModelViewProjectionMatrix\");\n        const normalMatrixLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"NormalMatrix\");\n        const lightDirectionLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"LightDirection\");\n        const halfVectorLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"LightDirection\");\n        const shininessLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"Shininess\");\n        const strengthLoc = gl.getUniformLocation(this.object3dShadowShaders.program, \"Strength\");\n        gl.uniformMatrix4fv(modelViewProjectionMatrixLoc, false, mvp);\n        gl.uniformMatrix3fv(normalMatrixLoc, false, mat3_1.mat4_to_mat3(mv));\n        gl.uniform3f(lightDirectionLoc, this.lightDirection[0], this.lightDirection[1], this.lightDirection[2]);\n        gl.uniform3f(lightColorLoc, 1, 1, 1);\n        gl.uniform3f(ambientLoc, 0.5, 0.5, 0.5);\n        const hvX = this.lightDirection[0];\n        const hvY = this.lightDirection[1];\n        const hvZ = this.lightDirection[2] + 1;\n        const norm = Math.sqrt(hvX * hvX + hvY * hvY + hvZ * hvZ);\n        gl.uniform3f(halfVectorLoc, hvX / norm, hvY / norm, hvZ / norm);\n        gl.uniform1f(shininessLoc, 50);\n        gl.uniform1f(strengthLoc, 20);\n    }\n    viewMatrix() {\n        const camera_position = new Float32Array([0, 0, 3.3]);\n        const look_at_origin = new Float32Array([0, -0.2, 0]);\n        const head_is_up = new Float32Array([0, 1, 0]);\n        return mat4_1.lookAt(camera_position, look_at_origin, head_is_up);\n    }\n    projectionMatrix() {\n        const fovy = 20 * Math.PI / 180;\n        const canvas = this.object3dShadowShaders.gl.canvas;\n        const rect = canvas.getBoundingClientRect();\n        return mat4_1.perspective(fovy, rect.width / rect.height, 0.01, 20);\n    }\n}\nexports.AbstractObject3dShadowView = AbstractObject3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mat4_1 = require(\"../webgl/mat4\");\nconst mat3_1 = require(\"../webgl/mat3\");\nconst quat_1 = require(\"../webgl/quat\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst SquareMatrix_1 = require(\"../linearAlgebra/SquareMatrix\");\nclass AbstractObject3dView {\n    constructor(object3dShaders, lightDirection) {\n        this.object3dShaders = object3dShaders;\n        this.lightDirection = lightDirection;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint16Array([]);\n        this.orientation = new Float32Array([0, 0, 0, 1]);\n        this.camera_position = new Float32Array([0, 0, 3.3]);\n        this.look_at_origin = new Float32Array([0, -0.2, 0]);\n        //private look_at_origin = new Float32Array([0, 0, 0])\n        this.head_is_up = new Float32Array([0, 1, 0]);\n        this.fovy = 20 * Math.PI / 180;\n        this.orientation = quat_1.setAxisAngle(new Float32Array([1, 0, 0]), -Math.PI / 2);\n        //this.orientation = setAxisAngle(new Float32Array([1, 0, 0]), 0)\n    }\n    renderFrame() {\n        let gl = this.object3dShaders.gl, a_Position = gl.getAttribLocation(this.object3dShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.object3dShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        this.setUniforms();\n        this.object3dShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    initVertexBuffers(gl) {\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.object3dShaders.program, 'a_Position'), a_Normal = gl.getAttribLocation(this.object3dShaders.program, 'a_Normal'), a_Color = gl.getAttribLocation(this.object3dShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Normal < 0) {\n            console.log('Failed to get the storage location of a_Normal');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 9, 0);\n        gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 9, FSIZE * 6);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Normal);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    updateBuffers() {\n        const gl = this.object3dShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    getModelTransformationMatrix() {\n        const model = mat4_1.fromQuat(this.orientation);\n        const m = [model[0], model[4], model[8], model[1], model[5], model[9], model[2], model[6], model[10]];\n        return new SquareMatrix_1.SquareMatrix(3, m);\n    }\n    setUniforms() {\n        const gl = this.object3dShaders.gl;\n        const translate1 = mat4_1.translate(mat4_1.identity_mat4(), new Float32Array([0, 0, 0]));\n        const model = mat4_1.multiply(mat4_1.fromQuat(this.orientation), translate1);\n        const view = this.viewMatrix();\n        const projection = this.projectionMatrix();\n        const mv = mat4_1.multiply(view, model);\n        const mvp = mat4_1.multiply(projection, mv);\n        const ambientLoc = gl.getUniformLocation(this.object3dShaders.program, \"Ambient\");\n        const lightColorLoc = gl.getUniformLocation(this.object3dShaders.program, \"LightColor\");\n        const modelViewProjectionMatrixLoc = gl.getUniformLocation(this.object3dShaders.program, \"ModelViewProjectionMatrix\");\n        const normalMatrixLoc = gl.getUniformLocation(this.object3dShaders.program, \"NormalMatrix\");\n        const lightDirectionLoc = gl.getUniformLocation(this.object3dShaders.program, \"LightDirection\");\n        const halfVectorLoc = gl.getUniformLocation(this.object3dShaders.program, \"LightDirection\");\n        const shininessLoc = gl.getUniformLocation(this.object3dShaders.program, \"Shininess\");\n        const strengthLoc = gl.getUniformLocation(this.object3dShaders.program, \"Strength\");\n        gl.uniformMatrix4fv(modelViewProjectionMatrixLoc, false, mvp);\n        gl.uniformMatrix3fv(normalMatrixLoc, false, mat3_1.mat4_to_mat3(mv));\n        gl.uniform3f(lightDirectionLoc, this.lightDirection[0], this.lightDirection[1], this.lightDirection[2]);\n        gl.uniform3f(lightColorLoc, 1, 1, 1);\n        gl.uniform3f(ambientLoc, 0.1, 0.1, 0.1);\n        const hvX = this.lightDirection[0];\n        const hvY = this.lightDirection[1];\n        const hvZ = this.lightDirection[2] + 1;\n        const norm = Math.sqrt(hvX * hvX + hvY * hvY + hvZ * hvZ);\n        gl.uniform3f(halfVectorLoc, hvX / norm, hvY / norm, hvZ / norm);\n        gl.uniform1f(shininessLoc, 50);\n        gl.uniform1f(strengthLoc, 20);\n    }\n    viewMatrix() {\n        return mat4_1.lookAt(this.camera_position, this.look_at_origin, this.head_is_up);\n    }\n    projectionMatrix() {\n        const canvas = this.object3dShaders.gl.canvas;\n        const rect = canvas.getBoundingClientRect();\n        return mat4_1.perspective(this.fovy, rect.width / rect.height, 0.01, 20);\n    }\n    pickingLine(ndcX, ndcY) {\n        //https://jsantell.com/model-view-projection/\n        const canvas = this.object3dShaders.gl.canvas;\n        const rect = canvas.getBoundingClientRect();\n        const p1 = new Vector3d_1.Vector3d(this.camera_position[0], this.camera_position[1], this.camera_position[2]);\n        const pOrigin = new Vector3d_1.Vector3d(this.look_at_origin[0], this.look_at_origin[1], this.look_at_origin[2]);\n        const v1 = pOrigin.substract(p1);\n        const v2 = new Vector3d_1.Vector3d(this.head_is_up[0], this.head_is_up[1], this.head_is_up[2]);\n        const v3 = (v1).crossPoduct(v2);\n        const top = v1.axisAngleRotation(v3, this.fovy / 2);\n        const bottom = v1.axisAngleRotation(v3, -this.fovy / 2);\n        const center = top.add(bottom).multiply(0.5);\n        const right = v1.axisAngleRotation(v2, -this.fovy / 2);\n        const v4 = right.substract(center).multiply(ndcX * rect.width / rect.height);\n        const v5 = top.substract(center).multiply(ndcY);\n        const p2 = v4.add(v5).add(center).add(p1);\n        return { p1: p1, p2: p2 };\n    }\n    distanceToCamera(point) {\n        const p1 = this.getCameraPosition();\n        const pOrigin = new Vector3d_1.Vector3d(this.look_at_origin[0], this.look_at_origin[1], this.look_at_origin[2]);\n        const v1 = pOrigin.substract(p1);\n        // returns null if the point is behind the camera\n        if ((point.substract(p1)).dot(v1) < 0) {\n            return null;\n        }\n        return point.substract(p1).norm();\n    }\n    getCameraPosition() {\n        return new Vector3d_1.Vector3d(this.camera_position[0], this.camera_position[1], this.camera_position[2]);\n    }\n    getLookAtOrigin() {\n        return new Vector3d_1.Vector3d(this.look_at_origin[0], this.look_at_origin[1], this.look_at_origin[2]);\n    }\n}\nexports.AbstractObject3dView = AbstractObject3dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toFloat32Array(v) {\n    let result = new Float32Array(v.length);\n    for (let i = 0; i < v.length; i += 1) {\n        result[i] = v[i];\n    }\n    return result;\n}\nexports.toFloat32Array = toFloat32Array;\nfunction toUint16Array(v) {\n    let result = new Uint16Array(v.length);\n    for (let i = 0; i < v.length; i += 1) {\n        result[i] = v[i];\n    }\n    return result;\n}\nexports.toUint16Array = toUint16Array;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst AbstractObject3dShadowView_1 = require(\"./AbstractObject3dShadowView\");\nconst ControlPoints3dView_1 = require(\"./ControlPoints3dView\");\nclass ControlPoints3dShadowView extends AbstractObject3dShadowView_1.AbstractObject3dShadowView {\n    constructor(spline, object3dShadowShaders, lightDirection) {\n        super(object3dShadowShaders, lightDirection);\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShadowShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.015;\n        const sectorCount = 50;\n        const stackCount = 50;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let cp of this.spline.controlPoints) {\n            let v = ControlPoints3dView_1.verticesForOneSphere(cp, radius, sectorCount, stackCount, { red: 0.5, green: 0.5, blue: 0.5 });\n            let i = ControlPoints3dView_1.indicesForOneSphere(startingIndex, sectorCount, stackCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...i];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = ArrayConversion_1.toFloat32Array(vertices);\n        this.indices = ArrayConversion_1.toUint16Array(indices);\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.ControlPoints3dShadowView = ControlPoints3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst AbstractObject3dView_1 = require(\"./AbstractObject3dView\");\nconst LUSolve_1 = require(\"../linearAlgebra/LUSolve\");\nclass ControlPoints3dView extends AbstractObject3dView_1.AbstractObject3dView {\n    constructor(spline, object3dShaders, lightDirection) {\n        super(object3dShaders, lightDirection);\n        this.spline = spline;\n        this.selectedControlPoint = null;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.015;\n        const sectorCount = 50;\n        const stackCount = 50;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let i = 0; i < this.spline.controlPoints.length; i += 1) {\n            let v;\n            if (i === this.selectedControlPoint) {\n                v = verticesForOneSphere(this.spline.controlPoints[i], radius, sectorCount, stackCount, { red: 0.7, green: 0.7, blue: 0.7 });\n            }\n            else {\n                v = verticesForOneSphere(this.spline.controlPoints[i], radius, sectorCount, stackCount, { red: 0.5, green: 0.5, blue: 0.5 });\n            }\n            let ind = indicesForOneSphere(startingIndex, sectorCount, stackCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = ArrayConversion_1.toFloat32Array(vertices);\n        this.indices = ArrayConversion_1.toUint16Array(indices);\n    }\n    updateVerticesIndicesAndBuffers() {\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    controlPointSelection(x, y, deltaSquared = 0.01) {\n        let result = null;\n        let previousDistance = null;\n        const l = this.pickingLine(x, y);\n        for (let i = 0; i < this.spline.controlPoints.length; i += 1) {\n            const m = this.getModelTransformationMatrix();\n            const cp = this.spline.controlPoints[i];\n            const v = m.multiplyByVector([cp.x, cp.y, cp.z]);\n            const p = new Vector3d_1.Vector3d(v[0], v[1], v[2]);\n            if (Vector3d_1.pointLineDistance(p, l.p1, l.p2) < deltaSquared) {\n                let d = this.distanceToCamera(p);\n                if (d !== null) {\n                    if (previousDistance === null || d < previousDistance) {\n                        result = i;\n                        previousDistance = d;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    getSelectedControlPoint() {\n        return this.selectedControlPoint;\n    }\n    setSelected(controlPointIndex) {\n        this.selectedControlPoint = controlPointIndex;\n    }\n    computeNewPosition(ndcX, ndcY) {\n        let result = null;\n        if (this.selectedControlPoint !== null) {\n            const m = this.getModelTransformationMatrix();\n            const cp = this.spline.controlPoints[this.selectedControlPoint];\n            const v = m.multiplyByVector([cp.x, cp.y, cp.z]);\n            const p = new Vector3d_1.Vector3d(v[0], v[1], v[2]);\n            const l = this.pickingLine(ndcX, ndcY);\n            let pp = Vector3d_1.linePlaneIntersection(l.p1, l.p2, this.getLookAtOrigin(), this.getCameraPosition(), p);\n            let point = LUSolve_1.lusolve(m, [pp.x, pp.y, pp.z]);\n            if (point !== undefined) {\n                result = new Vector3d_1.Vector3d(point[0], point[1], point[2]);\n            }\n        }\n        return result;\n    }\n}\nexports.ControlPoints3dView = ControlPoints3dView;\nfunction verticesForOneSphere(center, radius, sectorCount, stackCount, color) {\n    //http://www.songho.ca/opengl/gl_sphere.html\n    let x, y, z, xy; // vertex position\n    let nx, ny, nz; // vertex normal\n    let sectorAngle, stackAngle;\n    const lengthInv = 1 / radius;\n    const sectorStep = 2 * Math.PI / sectorCount;\n    const stackStep = Math.PI / stackCount;\n    let result = [];\n    for (let i = 0; i <= stackCount; i += 1) {\n        stackAngle = Math.PI / 2 - i * stackStep; // starting from pi/2 to -pi/2\n        xy = radius * Math.cos(stackAngle);\n        z = radius * Math.sin(stackAngle);\n        // add (sectorCout+1) vertices per stack\n        // the first and last vertices have the same position and normal\n        for (let j = 0; j <= sectorCount; j += 1) {\n            sectorAngle = j * sectorStep; // starting for 0 to 2pi\n            // vertex position (x, y, z)\n            x = xy * Math.cos(sectorAngle); // r * cos(u) * cos(v)\n            y = xy * Math.sin(sectorAngle); // r * cos(u) * sin(v)\n            result.push(x + center.x);\n            result.push(y + center.y);\n            result.push(z + center.z);\n            // normalized vertex normal (nx, ny, nz)\n            nx = x * lengthInv;\n            ny = y * lengthInv;\n            nz = z * lengthInv;\n            result.push(nx);\n            result.push(ny);\n            result.push(nz);\n            // Color\n            result.push(color.red);\n            result.push(color.green);\n            result.push(color.blue);\n        }\n    }\n    return result;\n}\nexports.verticesForOneSphere = verticesForOneSphere;\nfunction indicesForOneSphere(startingIndex, sectorCount, stackCount) {\n    let result = [];\n    for (let i = 0; i < stackCount; i += 1) {\n        let k1 = i * (sectorCount + 1); // beginning of current stack\n        let k2 = k1 + sectorCount + 1; // beginning of next stack\n        for (let j = 0; j < sectorCount; j += 1, k1 += 1, k2 += 1) {\n            if (i != 0) {\n                result.push(k1 + startingIndex);\n                result.push(k2 + startingIndex);\n                result.push(k1 + 1 + startingIndex);\n            }\n            if (i != (stackCount - 1)) {\n                result.push(k1 + 1 + startingIndex);\n                result.push(k2 + startingIndex);\n                result.push(k2 + 1 + startingIndex);\n            }\n        }\n    }\n    return result;\n}\nexports.indicesForOneSphere = indicesForOneSphere;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass ControlPointsShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    v_Color = a_Color; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            '//uniform bool selected; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'varying vec3 v_Color; \\n' +\n            'void main() {\\n' +\n            '     vec4 fColor = vec4(0.1, 0.1, 0.1, 0.0); \\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     vec4 color1 = vec4(v_Color, 0.35); \\n' +\n            '     vec4 color2 = vec4(v_Color, 0.9); \\n' +\n            '     float delta = 0.1; \\n' +\n            '     float alpha1 = smoothstep(0.35-delta, 0.35, dist); \\n' +\n            '     float alpha2 = smoothstep(0.65-delta, 0.65, dist); \\n' +\n            '     vec4 fColor1 = mix(color1, fColor, alpha1); \\n' +\n            '     vec4 fColor2 = mix(color2, fColor, alpha2); \\n' +\n            '     gl_FragColor = (fColor1+fColor2)/2.0; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfElements, selectedControlPoint) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n            if (selectedControlPoint != -1 && selectedControlPoint !== null) {\n                this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_BYTE, selectedControlPoint * 6);\n            }\n        }\n    }\n}\nexports.ControlPointsShaders = ControlPointsShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ControlPointsView {\n    constructor(spline, controlPointsShaders, red, blue, green) {\n        this.controlPointsShaders = controlPointsShaders;\n        this.red = red;\n        this.blue = blue;\n        this.green = green;\n        this.z = 0;\n        this.selectedControlPoint = null;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.freeControlPoints;\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.controlPointsShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const size = 0.03;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (let i = 0; i < this.controlPoints.length; i += 1) {\n            let x = this.controlPoints[i].x;\n            let y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        if (a_Color < 0) {\n            console.log('Failed to get the storage location of a_Color');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        let gl = this.controlPointsShaders.gl, a_Position = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Texture'), a_Color = gl.getAttribLocation(this.controlPointsShaders.program, 'a_Color'), FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        gl.useProgram(this.controlPointsShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 8, FSIZE * 5);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.enableVertexAttribArray(a_Color);\n        this.controlPointsShaders.renderFrame(this.indices.length, this.selectedControlPoint);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    controlPointSelection(x, y, deltaSquared = 0.01) {\n        let result = null;\n        for (let i = 0; i < this.controlPoints.length; i += 1) {\n            if (Math.pow(x - this.controlPoints[i].x, 2) + Math.pow(y - this.controlPoints[i].y, 2) < deltaSquared) {\n                return i;\n            }\n        }\n        return result;\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    updatePoints(points) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    updateBuffers() {\n        var gl = this.controlPointsShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n    getSelectedControlPoint() {\n        return this.selectedControlPoint;\n    }\n    setSelected(controlPointIndex) {\n        this.selectedControlPoint = controlPointIndex;\n    }\n}\nexports.ControlPointsView = ControlPointsView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst AbstractObject3dShadowView_1 = require(\"./AbstractObject3dShadowView\");\nconst ControlPolygon3dView_1 = require(\"./ControlPolygon3dView\");\nclass ControlPolygon3dShadowView extends AbstractObject3dShadowView_1.AbstractObject3dShadowView {\n    constructor(spline, object3dShadowShaders, lightDirection, closed) {\n        super(object3dShadowShaders, lightDirection);\n        this.closed = closed;\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShadowShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.003;\n        const sectorCount = 20;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let i = 0; i < this.controlPoints.length - 1; i += 1) {\n            let v = ControlPolygon3dView_1.verticesForOneCylinder(this.controlPoints[i], this.controlPoints[i + 1], radius, sectorCount);\n            let ind = ControlPolygon3dView_1.indicesForOneCylinder(startingIndex, sectorCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = ArrayConversion_1.toFloat32Array(vertices);\n        this.indices = ArrayConversion_1.toUint16Array(indices);\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.ControlPolygon3dShadowView = ControlPolygon3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst RotationMatrix_1 = require(\"../mathVector/RotationMatrix\");\nconst AbstractObject3dView_1 = require(\"./AbstractObject3dView\");\nclass ControlPolygon3dView extends AbstractObject3dView_1.AbstractObject3dView {\n    constructor(spline, object3dShaders, lightDirection, closed) {\n        super(object3dShaders, lightDirection);\n        this.closed = closed;\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.003;\n        const sectorCount = 20;\n        let vertices = [];\n        let indices = [];\n        let startingIndex = 0;\n        for (let i = 0; i < this.controlPoints.length - 1; i += 1) {\n            let v = verticesForOneCylinder(this.controlPoints[i], this.controlPoints[i + 1], radius, sectorCount);\n            let ind = indicesForOneCylinder(startingIndex, sectorCount);\n            vertices = [...vertices, ...v];\n            indices = [...indices, ...ind];\n            startingIndex += v.length / 9;\n        }\n        this.vertices = ArrayConversion_1.toFloat32Array(vertices);\n        this.indices = ArrayConversion_1.toUint16Array(indices);\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.ControlPolygon3dView = ControlPolygon3dView;\nfunction verticesForOneCylinder(centerTop, centerBottom, radius, sectorCount) {\n    let axisVector = centerTop.substract(centerBottom).normalize();\n    const circleTop = orientedCircle(centerTop, radius, axisVector, sectorCount);\n    const circleBottom = orientedCircle(centerBottom, radius, axisVector, sectorCount);\n    let result = [];\n    for (let i = 0; i < circleTop.vertices.length; i += 1) {\n        // vertex position (x, y, z)\n        result.push(circleTop.vertices[i].x);\n        result.push(circleTop.vertices[i].y);\n        result.push(circleTop.vertices[i].z);\n        // normalized vertex normal (nx, ny, nz)\n        result.push(circleTop.normals[i].x);\n        result.push(circleTop.normals[i].y);\n        result.push(circleTop.normals[i].z);\n        // Color\n        result.push(0.5);\n        result.push(0.5);\n        result.push(0.5);\n    }\n    for (let i = 0; i < circleBottom.vertices.length; i += 1) {\n        // vertex position (x, y, z)\n        result.push(circleBottom.vertices[i].x);\n        result.push(circleBottom.vertices[i].y);\n        result.push(circleBottom.vertices[i].z);\n        // normalized vertex normal (nx, ny, nz)\n        result.push(circleBottom.normals[i].x);\n        result.push(circleBottom.normals[i].y);\n        result.push(circleBottom.normals[i].z);\n        // Color\n        result.push(0.8);\n        result.push(0.8);\n        result.push(0.8);\n    }\n    return result;\n}\nexports.verticesForOneCylinder = verticesForOneCylinder;\nfunction orientedCircle(center, radius, axisVector, sectorCount) {\n    const n = axisVector.dot(new Vector3d_1.Vector3d(0, 0, 1));\n    const sectorStep = 2 * Math.PI / sectorCount;\n    let vertices = [];\n    let normals = [];\n    if (n > 0) {\n        const rotationMatrix = RotationMatrix_1.rotationMatrixFromTwoVectors(new Vector3d_1.Vector3d(0, 0, 1), axisVector);\n        for (let j = 0; j <= sectorCount; j += 1) {\n            let sectorAngle = j * sectorStep; // starting for 0 to 2pi\n            // cicle in the plane xy \n            let x = radius * Math.cos(sectorAngle);\n            let y = radius * Math.sin(sectorAngle);\n            let v = rotationMatrix.multiplyByVector([x, y, 0]);\n            vertices.push(new Vector3d_1.Vector3d(v[0] + center.x, v[1] + center.y, v[2] + center.z));\n            let nx = Math.cos(sectorAngle);\n            let ny = Math.sin(sectorAngle);\n            let nv = rotationMatrix.multiplyByVector([nx, ny, 0]);\n            normals.push(new Vector3d_1.Vector3d(nv[0], nv[1], nv[2]));\n        }\n    }\n    else {\n        const rotationMatrix = RotationMatrix_1.rotationMatrixFromTwoVectors(new Vector3d_1.Vector3d(0, 1, 0), axisVector);\n        for (let j = 0; j <= sectorCount; j += 1) {\n            let sectorAngle = j * sectorStep; // starting for 0 to 2pi\n            // cicle in the plane xz \n            let x = radius * Math.cos(sectorAngle);\n            let z = radius * Math.sin(sectorAngle);\n            let v = rotationMatrix.multiplyByVector([x, 0, z]);\n            vertices.push(new Vector3d_1.Vector3d(v[0] + center.x, v[1] + center.y, v[2] + center.z));\n            let nx = Math.cos(sectorAngle);\n            let nz = Math.sin(sectorAngle);\n            let nv = rotationMatrix.multiplyByVector([nx, 0, nz]);\n            normals.push(new Vector3d_1.Vector3d(nv[0], nv[1], nv[2]));\n        }\n    }\n    return { vertices: vertices, normals: normals };\n}\nexports.orientedCircle = orientedCircle;\nfunction indicesForOneCylinder(startingIndex, sectorCount) {\n    let result = [];\n    let k1 = 0; // beginning of current stack\n    let k2 = k1 + sectorCount + 1; // beginning of next stack\n    for (let j = 0; j < sectorCount; j += 1, k1 += 1, k2 += 1) {\n        result.push(k1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k2 + 1 + startingIndex);\n    }\n    return result;\n}\nexports.indicesForOneCylinder = indicesForOneCylinder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass ControlPolygonShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec4 fColor; \\n' +\n            'void main() {\\n' +\n            '    gl_FragColor = fColor; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfElements) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n    }\n}\nexports.ControlPolygonShaders = ControlPolygonShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ControlPolygonView {\n    constructor(spline, controlPolygonShaders, closed, red, green, blue, alpha) {\n        this.controlPolygonShaders = controlPolygonShaders;\n        this.closed = closed;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.controlPolygonShaders = controlPolygonShaders;\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.controlPolygonShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    set isClosed(bool) {\n        this.closed = bool;\n    }\n    updateVerticesAndIndices() {\n        const thickness = 0.003;\n        this.vertices = new Float32Array(this.controlPoints.length * 12);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (let i = 0; i < this.controlPoints.length - 1; i += 1) {\n            const normal = this.controlPoints[i + 1].substract(this.controlPoints[i]).normalize().rotate90degrees();\n            this.vertices[12 * i] = this.controlPoints[i].x - thickness * normal.x;\n            this.vertices[12 * i + 1] = this.controlPoints[i].y - thickness * normal.y;\n            this.vertices[12 * i + 2] = this.z;\n            this.vertices[12 * i + 3] = this.controlPoints[i + 1].x - thickness * normal.x;\n            this.vertices[12 * i + 4] = this.controlPoints[i + 1].y - thickness * normal.y;\n            this.vertices[12 * i + 5] = this.z;\n            this.vertices[12 * i + 6] = this.controlPoints[i + 1].x + thickness * normal.x;\n            this.vertices[12 * i + 7] = this.controlPoints[i + 1].y + thickness * normal.y;\n            this.vertices[12 * i + 8] = this.z;\n            this.vertices[12 * i + 9] = this.controlPoints[i].x + thickness * normal.x;\n            this.vertices[12 * i + 10] = this.controlPoints[i].y + thickness * normal.y;\n            this.vertices[12 * i + 11] = this.z;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        const gl = this.controlPolygonShaders.gl;\n        const a_Position = gl.getAttribLocation(this.controlPolygonShaders.program, 'a_Position');\n        const fColorLocation = gl.getUniformLocation(this.controlPolygonShaders.program, \"fColor\");\n        gl.useProgram(this.controlPolygonShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(a_Position);\n        gl.uniform4f(fColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.controlPolygonShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    update(message) {\n        this.controlPoints = message.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    updateBuffers() {\n        const gl = this.controlPolygonShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n}\nexports.ControlPolygonView = ControlPolygonView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass CurvatureExtremaShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec2 a_Texture; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '    v_Texture = a_Texture; \\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision highp float; \\n' +\n            'uniform vec4 a_Color; \\n' +\n            'varying vec2 v_Texture; \\n' +\n            'void main() {\\n' +\n            '     float dist = distance(v_Texture, vec2(0.0, 0.0)); \\n' +\n            '     if (dist > 0.5) discard; \\n' +\n            '     gl_FragColor = a_Color; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfElements) {\n        if (this.program) {\n            this.gl.drawElements(this.gl.TRIANGLES, numberOfElements, this.gl.UNSIGNED_BYTE, 0);\n        }\n    }\n}\nexports.CurvatureExtremaShaders = CurvatureExtremaShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PeriodicBSplineR1toR2DifferentialProperties_1 = require(\"../bsplines/PeriodicBSplineR1toR2DifferentialProperties\");\nconst PeriodicBSplineR1toR2_1 = require(\"../bsplines/PeriodicBSplineR1toR2\");\nconst BSplineR1toR2_1 = require(\"../bsplines/BSplineR1toR2\");\nconst BSplineR1toR2DifferentialProperties_1 = require(\"../bsplines/BSplineR1toR2DifferentialProperties\");\nclass CurvatureExtremaView {\n    constructor(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.curvatureExtrema = [];\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    updateVerticesAndIndices() {\n        const size = 0.03;\n        this.vertices = new Float32Array(this.curvatureExtrema.length * 32);\n        this.indices = new Uint8Array(this.curvatureExtrema.length * 6);\n        for (let i = 0; i < this.curvatureExtrema.length; i += 1) {\n            let x = this.curvatureExtrema[i].x;\n            let y = this.curvatureExtrema[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        let gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    update(spline) {\n        if (spline instanceof BSplineR1toR2_1.BSplineR1toR2) {\n            const splineDP = new BSplineR1toR2DifferentialProperties_1.BSplineR1toR2DifferentialProperties(spline);\n            this.curvatureExtrema = splineDP.curvatureExtrema();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n        if (spline instanceof PeriodicBSplineR1toR2_1.PeriodicBSplineR1toR2) {\n            const splineDP = new PeriodicBSplineR1toR2DifferentialProperties_1.PeriodicBSplineR1toR2DifferentialProperties(spline);\n            this.curvatureExtrema = splineDP.curvatureExtrema();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n    }\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    updateBuffers() {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n}\nexports.CurvatureExtremaView = CurvatureExtremaView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst AbstractObject3dShadowView_1 = require(\"./AbstractObject3dShadowView\");\nconst Curve3dView_1 = require(\"./Curve3dView\");\nclass Curve3dShadowView extends AbstractObject3dShadowView_1.AbstractObject3dShadowView {\n    constructor(spline, object3dShadowShaders, lightDirection, closed) {\n        super(object3dShadowShaders, lightDirection);\n        this.spline = spline;\n        this.closed = closed;\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShadowShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.005;\n        const sectorCount = 20;\n        const stackCount = 200;\n        let indices = [];\n        let startingIndex = 0;\n        const vertices = this.computeVertices(radius, stackCount, sectorCount);\n        for (let i = 0; i < stackCount - 1; i += 1) {\n            let ind = Curve3dView_1.indicesForOneCylinder(startingIndex, sectorCount);\n            indices = [...indices, ...ind];\n            startingIndex += sectorCount + 1;\n        }\n        this.vertices = ArrayConversion_1.toFloat32Array(vertices);\n        this.indices = ArrayConversion_1.toUint16Array(indices);\n    }\n    frames(number) {\n        const start = this.spline.knots[this.spline.degree];\n        const end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        let pointSequenceOnSpline = [];\n        for (let i = 0; i < number; i += 1) {\n            let point = this.spline.evaluate(i / (number - 1) * (end - start) + start);\n            pointSequenceOnSpline.push(point);\n        }\n        const tangentSequenceOnSpline = Curve3dView_1.computeApproximatedTangentsFromPointsSequence(pointSequenceOnSpline);\n        const randomUpVector = Curve3dView_1.computeRandomUpVector(tangentSequenceOnSpline[0]);\n        const upVectorSequenceOnSpline = Curve3dView_1.computeUpVectorSequence(tangentSequenceOnSpline, randomUpVector);\n        return { pointSequence: pointSequenceOnSpline, tangentSequence: tangentSequenceOnSpline, upVectorSequence: upVectorSequenceOnSpline };\n    }\n    computeVertices(radius, stackCount, sectorCount) {\n        let frames = this.frames(stackCount);\n        let result = [];\n        for (let i = 0; i < frames.pointSequence.length; i += 1) {\n            let oe = Curve3dView_1.orientedEllipse(frames.pointSequence[i], frames.tangentSequence[i], frames.upVectorSequence[i], sectorCount, radius, radius);\n            for (let j = 0; j < oe.vertices.length; j += 1) {\n                // vertex position (x, y, z)\n                result.push(oe.vertices[j].x);\n                result.push(oe.vertices[j].y);\n                result.push(oe.vertices[j].z);\n                // normalized vertex normal (nx, ny, nz)\n                result.push(oe.normals[j].x);\n                result.push(oe.normals[j].y);\n                result.push(oe.normals[j].z);\n                // Color\n                result.push(1.0);\n                result.push(0.5);\n                result.push(0.5);\n            }\n        }\n        return result;\n    }\n    update(spline) {\n        this.controlPoints = spline.freeControlPoints;\n        if (this.closed) {\n            this.controlPoints.push(this.controlPoints[0]);\n        }\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.Curve3dShadowView = Curve3dShadowView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ArrayConversion_1 = require(\"./ArrayConversion\");\nconst Vector3d_1 = require(\"../mathVector/Vector3d\");\nconst RotationMatrix_1 = require(\"../mathVector/RotationMatrix\");\nconst AbstractObject3dView_1 = require(\"./AbstractObject3dView\");\nclass Curve3dView extends AbstractObject3dView_1.AbstractObject3dView {\n    //private controlPoints: Vector3d[]\n    constructor(spline, object3dShaders, lightDirection, closed) {\n        super(object3dShaders, lightDirection);\n        this.spline = spline;\n        this.closed = closed;\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.object3dShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updateVerticesAndIndices() {\n        const radius = 0.005;\n        const sectorCount = 20;\n        const stackCount = 200;\n        let indices = [];\n        let startingIndex = 0;\n        const vertices = this.computeVertices(radius, stackCount, sectorCount);\n        for (let i = 0; i < stackCount - 1; i += 1) {\n            let ind = indicesForOneCylinder(startingIndex, sectorCount);\n            indices = [...indices, ...ind];\n            startingIndex += sectorCount + 1;\n        }\n        this.vertices = ArrayConversion_1.toFloat32Array(vertices);\n        this.indices = ArrayConversion_1.toUint16Array(indices);\n    }\n    frames(number) {\n        const start = this.spline.knots[this.spline.degree];\n        const end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        let pointSequenceOnSpline = [];\n        for (let i = 0; i < number; i += 1) {\n            let point = this.spline.evaluate(i / (number - 1) * (end - start) + start);\n            pointSequenceOnSpline.push(point);\n        }\n        const tangentSequenceOnSpline = computeApproximatedTangentsFromPointsSequence(pointSequenceOnSpline);\n        const randomUpVector = computeRandomUpVector(tangentSequenceOnSpline[0]);\n        const upVectorSequenceOnSpline = computeUpVectorSequence(tangentSequenceOnSpline, randomUpVector);\n        return { pointSequence: pointSequenceOnSpline, tangentSequence: tangentSequenceOnSpline, upVectorSequence: upVectorSequenceOnSpline };\n    }\n    computeVertices(radius, stackCount, sectorCount) {\n        let frames = this.frames(stackCount);\n        let result = [];\n        for (let i = 0; i < frames.pointSequence.length; i += 1) {\n            let oe = orientedEllipse(frames.pointSequence[i], frames.tangentSequence[i], frames.upVectorSequence[i], sectorCount, radius, radius);\n            for (let j = 0; j < oe.vertices.length; j += 1) {\n                // vertex position (x, y, z)\n                result.push(oe.vertices[j].x);\n                result.push(oe.vertices[j].y);\n                result.push(oe.vertices[j].z);\n                // normalized vertex normal (nx, ny, nz)\n                result.push(oe.normals[j].x);\n                result.push(oe.normals[j].y);\n                result.push(oe.normals[j].z);\n                // Color\n                result.push(1.0);\n                result.push(0.5);\n                result.push(0.5);\n            }\n        }\n        return result;\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n}\nexports.Curve3dView = Curve3dView;\nfunction computeRandomUpVector(tangentVector) {\n    if (tangentVector.x > tangentVector.y) {\n        return tangentVector.crossPoduct(new Vector3d_1.Vector3d(0, 1, 0)).normalize();\n    }\n    else {\n        return tangentVector.crossPoduct(new Vector3d_1.Vector3d(1, 0, 0)).normalize();\n    }\n}\nexports.computeRandomUpVector = computeRandomUpVector;\nfunction indicesForOneCylinder(startingIndex, sectorCount) {\n    let result = [];\n    let k1 = 0; // beginning of current stack\n    let k2 = k1 + sectorCount + 1; // beginning of next stack\n    for (let j = 0; j < sectorCount; j += 1, k1 += 1, k2 += 1) {\n        result.push(k1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k1 + 1 + startingIndex);\n        result.push(k2 + startingIndex);\n        result.push(k2 + 1 + startingIndex);\n    }\n    return result;\n}\nexports.indicesForOneCylinder = indicesForOneCylinder;\nfunction computeUpVectorSequence(tangentSequence, firstUpVector) {\n    let result = [];\n    result.push(firstUpVector);\n    for (let i = 0; i < tangentSequence.length - 1; i += 1) {\n        let rotationMatrix = RotationMatrix_1.rotationMatrixFromTwoVectors(tangentSequence[i], tangentSequence[i + 1]);\n        let lastUpVector = result[result.length - 1];\n        let newUpVector = rotationMatrix.multiplyByVector([lastUpVector.x, lastUpVector.y, lastUpVector.z]);\n        result.push(new Vector3d_1.Vector3d(newUpVector[0], newUpVector[1], newUpVector[2]).normalize());\n    }\n    return result;\n}\nexports.computeUpVectorSequence = computeUpVectorSequence;\nfunction orientedEllipse(center, normal, up, sectorCount, semiMinorAxis, semiMajorAxis, miter = new Vector3d_1.Vector3d(1, 0, 0)) {\n    const sectorStep = 2 * Math.PI / sectorCount;\n    let vertices = [];\n    let normals = [];\n    let side = normal.crossPoduct(up).normalize();\n    for (let i = 0; i <= sectorCount; i += 1) {\n        let sectorAngle = i * sectorStep; // starting for 0 to 2pi\n        let v1 = up.multiply(Math.sin(sectorAngle) * semiMinorAxis);\n        let v2 = side.multiply(Math.cos(sectorAngle) * semiMajorAxis);\n        vertices.push(v1.add(v2).add(center));\n    }\n    for (let i = 0; i <= sectorCount; i += 1) {\n        let sectorAngle = i * sectorStep; // starting for 0 to 2pi\n        let v1 = up.multiply(Math.sin(sectorAngle) * semiMinorAxis);\n        let v2 = side.multiply(Math.cos(sectorAngle) * semiMajorAxis);\n        normals.push(v1.add(v2).normalize());\n    }\n    return { vertices: vertices, normals: normals };\n}\nexports.orientedEllipse = orientedEllipse;\nfunction computeMiterFromPointsSequence(points, radius) {\n    const tolerance = 10e-5;\n    const maxLength = radius * 3;\n    let miters = [];\n    let lengths = [];\n    let normal;\n    for (let i = 1; i < points.length - 1; i += 1) {\n        let tangent = points[i + 1].substract(points[i - 1]).normalize();\n        let v1 = points[i + 1].substract(points[i]);\n        let v2 = points[i + 2].substract(points[i + 1]);\n        let n = v1.crossPoduct(v2);\n        if (n.norm() > tolerance) {\n            normal = n.normalize();\n        }\n        else {\n            normal = computeRandomUpVector(tangent);\n        }\n        miters.push(normal);\n        let l = normal.crossPoduct(v1).norm();\n        if (l > maxLength) {\n            l = maxLength;\n        }\n        if (l > tolerance) {\n            lengths.push(radius / l);\n        }\n        else {\n            lengths.push(radius);\n        }\n    }\n    return { miters: miters, lengths: lengths };\n}\nfunction computeApproximatedTangentsFromPointsSequence(points) {\n    let result = [];\n    let tangent = (points[1].substract(points[0])).normalize();\n    result.push(tangent);\n    for (let i = 1; i < points.length - 1; i += 1) {\n        tangent = (points[i + 1].substract(points[i - 1])).normalize();\n        result.push(tangent);\n    }\n    tangent = (points[points.length - 1].substract(points[points.length - 2])).normalize();\n    result.push(tangent);\n    return result;\n}\nexports.computeApproximatedTangentsFromPointsSequence = computeApproximatedTangentsFromPointsSequence;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst quat_1 = require(\"../webgl/quat\");\nconst ControlPoints3dView_1 = require(\"./ControlPoints3dView\");\nconst ControlPoints3dShadowView_1 = require(\"./ControlPoints3dShadowView\");\nconst ControlPolygon3dView_1 = require(\"./ControlPolygon3dView\");\nconst ControlPolygon3dShadowView_1 = require(\"./ControlPolygon3dShadowView\");\nconst Object3dShaders_1 = require(\"./Object3dShaders\");\nconst Curve3dView_1 = require(\"./Curve3dView\");\nconst Curve3dShadowView_1 = require(\"./Curve3dShadowView\");\nconst Object3dShadowShaders_1 = require(\"./Object3dShadowShaders\");\nconst CurveScene3dController_1 = require(\"../controllers/CurveScene3dController\");\nvar STATE;\n(function (STATE) {\n    STATE[STATE[\"NONE\"] = 0] = \"NONE\";\n    STATE[STATE[\"ROTATE\"] = 1] = \"ROTATE\";\n})(STATE || (STATE = {}));\nclass CurveScene3dView {\n    constructor(canvas, gl, curve3dModel) {\n        this.canvas = canvas;\n        this.gl = gl;\n        this.selectedControlPoint = null;\n        this.dragging = false;\n        this.lightDirection = [0, 1, 1];\n        this.previousMousePosition = { x: 0, y: 0 };\n        this.state = STATE.NONE;\n        this.curve3dModel = curve3dModel;\n        this.object3dShaders = new Object3dShaders_1.Object3dShaders(this.gl);\n        this.object3dShadowShaders = new Object3dShadowShaders_1.Object3dShadowShaders(this.gl);\n        this.controlPoints3dView = new ControlPoints3dView_1.ControlPoints3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection);\n        this.controlPoints3dShadowView = new ControlPoints3dShadowView_1.ControlPoints3dShadowView(curve3dModel.spline, this.object3dShadowShaders, this.lightDirection);\n        this.controlPolygon3dView = new ControlPolygon3dView_1.ControlPolygon3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection, false);\n        this.controlPolygon3dShadowView = new ControlPolygon3dShadowView_1.ControlPolygon3dShadowView(curve3dModel.spline, this.object3dShadowShaders, this.lightDirection, false);\n        this.curve3dView = new Curve3dView_1.Curve3dView(curve3dModel.spline, this.object3dShaders, this.lightDirection, false);\n        this.curve3dShadowView = new Curve3dShadowView_1.Curve3dShadowView(curve3dModel.spline, this.object3dShadowShaders, this.lightDirection, false);\n        this.curve3dModel.registerObserver(this.controlPoints3dView);\n        this.curve3dModel.registerObserver(this.controlPolygon3dView);\n        this.curve3dModel.registerObserver(this.curve3dView);\n        this.curveScene3dControler = new CurveScene3dController_1.CurveScene3dController(curve3dModel);\n    }\n    renderFrame() {\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.gl.clearColor(0.2, 0.2, 0.2, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.clear(this.gl.DEPTH_BUFFER_BIT);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.controlPoints3dView.renderFrame();\n        this.controlPoints3dShadowView.renderFrame();\n        this.controlPolygon3dView.renderFrame();\n        this.controlPolygon3dShadowView.renderFrame();\n        this.curve3dView.renderFrame();\n        this.curve3dShadowView.renderFrame();\n    }\n    mousedown(event, deltaSquared = 0.01) {\n        const ndc = this.mouse_get_NormalizedDeviceCoordinates(event);\n        this.selectedControlPoint = this.controlPoints3dView.controlPointSelection(ndc.x, ndc.y, deltaSquared);\n        this.controlPoints3dView.setSelected(this.selectedControlPoint);\n        this.previousMousePosition = ndc;\n        if (event.button === 0 && this.selectedControlPoint === null) {\n            this.state = STATE.ROTATE;\n        }\n        if (this.selectedControlPoint !== null) {\n            this.dragging = true;\n        }\n        this.controlPoints3dView.updateVerticesIndicesAndBuffers();\n    }\n    mousemove(event) {\n        if (this.state === STATE.ROTATE || this.dragging === true) {\n            const currentMousePosition = this.mouse_get_NormalizedDeviceCoordinates(event);\n            const deltaMove = {\n                x: currentMousePosition.x - this.previousMousePosition.x,\n                y: currentMousePosition.y - this.previousMousePosition.y\n            };\n            this.previousMousePosition = this.mouse_get_NormalizedDeviceCoordinates(event);\n            if (this.state === STATE.ROTATE) {\n                const deltaRotationQuaternion = quat_1.fromEuler(-deltaMove.y * 500, deltaMove.x * 500, 0);\n                this.controlPoints3dView.orientation = quat_1.multiply_quats(deltaRotationQuaternion, this.controlPoints3dView.orientation);\n                this.controlPoints3dShadowView.orientation = quat_1.multiply_quats(deltaRotationQuaternion, this.controlPoints3dShadowView.orientation);\n                this.controlPolygon3dView.orientation = quat_1.multiply_quats(deltaRotationQuaternion, this.controlPolygon3dView.orientation);\n                this.controlPolygon3dShadowView.orientation = quat_1.multiply_quats(deltaRotationQuaternion, this.controlPolygon3dShadowView.orientation);\n                this.curve3dView.orientation = quat_1.multiply_quats(deltaRotationQuaternion, this.curve3dView.orientation);\n                this.curve3dShadowView.orientation = quat_1.multiply_quats(deltaRotationQuaternion, this.curve3dShadowView.orientation);\n            }\n            if (this.dragging === true) {\n                const selectedControlPoint = this.controlPoints3dView.getSelectedControlPoint();\n                if (selectedControlPoint != null && this.dragging === true) {\n                    const p = this.controlPoints3dView.computeNewPosition(currentMousePosition.x, currentMousePosition.y);\n                    if (p !== null && this.selectedControlPoint !== null) {\n                        this.curveScene3dControler.setControlPointPosition(this.selectedControlPoint, p.x, p.y, p.z);\n                    }\n                }\n            }\n        }\n    }\n    mouseup(event) {\n        this.state = STATE.NONE;\n        this.dragging = false;\n    }\n    mouse_get_NormalizedDeviceCoordinates(event) {\n        const rect = this.canvas.getBoundingClientRect();\n        const w = parseInt(this.canvas.style.width, 10);\n        const h = parseInt(this.canvas.style.height, 10);\n        const x = ((event.clientX - rect.left) - w / 2) / (w / 2);\n        const y = (h / 2 - (event.clientY - rect.top)) / (h / 2);\n        return { x: x, y: y };\n    }\n}\nexports.CurveScene3dView = CurveScene3dView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CurveSceneController_1 = require(\"../controllers/CurveSceneController\");\nconst ControlPointsShaders_1 = require(\"../views/ControlPointsShaders\");\nconst ControlPointsView_1 = require(\"../views/ControlPointsView\");\nconst ControlPolygonShaders_1 = require(\"../views/ControlPolygonShaders\");\nconst ControlPolygonView_1 = require(\"../views/ControlPolygonView\");\nconst CurveShaders_1 = require(\"../views/CurveShaders\");\nconst CurveView_1 = require(\"../views/CurveView\");\nconst CurvatureExtremaShaders_1 = require(\"./CurvatureExtremaShaders\");\nconst CurvatureExtremaView_1 = require(\"./CurvatureExtremaView\");\nconst InflectionsView_1 = require(\"../views/InflectionsView\");\nconst CurveModel_1 = require(\"../models/CurveModel\");\nconst ClosedCurveModel_1 = require(\"../models/ClosedCurveModel\");\nconst CurveModelAlternative01_1 = require(\"../models/CurveModelAlternative01\");\nconst ClosedCurveModelAlternative01_1 = require(\"../models/ClosedCurveModelAlternative01\");\nclass CurveSceneView {\n    constructor(canvas, gl, curveModel) {\n        this.canvas = canvas;\n        this.gl = gl;\n        this.curveModel = curveModel;\n        this.selectedControlPoint = null;\n        this.dragging = false;\n        this.curveShaders = new CurveShaders_1.CurveShaders(this.gl);\n        this.curveView = new CurveView_1.CurveView(this.curveModel.spline, this.curveShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.controlPointsShaders = new ControlPointsShaders_1.ControlPointsShaders(this.gl);\n        this.controlPointsView = new ControlPointsView_1.ControlPointsView(this.curveModel.spline, this.controlPointsShaders, 1, 1, 1);\n        this.controlPolygonShaders = new ControlPolygonShaders_1.ControlPolygonShaders(this.gl);\n        this.controlPolygonView = new ControlPolygonView_1.ControlPolygonView(this.curveModel.spline, this.controlPolygonShaders, this.curveModel.isClosed, 216.0 / 255.0, 216.0 / 255.0, 216.0 / 255.0, 0.05);\n        this.curvatureExtremaShaders = new CurvatureExtremaShaders_1.CurvatureExtremaShaders(this.gl);\n        this.curvatureExtremaView = new CurvatureExtremaView_1.CurvatureExtremaView(this.curveModel.spline, this.curvatureExtremaShaders, 216 / 255, 91 / 255, 95 / 255, 1);\n        this.inflectionsView = new InflectionsView_1.InflectionsView(this.curveModel.spline, this.curvatureExtremaShaders, 216 / 255, 120 / 255, 120 / 255, 1);\n        this.curveModel.registerObserver(this.controlPointsView, \"control points\");\n        this.curveModel.registerObserver(this.controlPolygonView, \"control points\");\n        this.curveModel.registerObserver(this.curveView, \"curve\");\n        this.curveModel.registerObserver(this.curvatureExtremaView, \"curve\");\n        this.curveModel.registerObserver(this.inflectionsView, \"curve\");\n        this.curveSceneControler = new CurveSceneController_1.CurveSceneController(curveModel);\n        this.renderFrame();\n    }\n    renderFrame() {\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clearColor(0.27, 0.27, 0.27, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        this.curveView.renderFrame();\n        this.curvatureExtremaView.renderFrame();\n        this.inflectionsView.renderFrame();\n        this.controlPolygonView.renderFrame();\n        this.controlPointsView.renderFrame();\n    }\n    leftMouseDown_event(ndcX, ndcY, deltaSquared = 0.01) {\n        this.selectedControlPoint = this.controlPointsView.controlPointSelection(ndcX, ndcY, deltaSquared);\n        this.controlPointsView.setSelected(this.selectedControlPoint);\n        if (this.selectedControlPoint !== null) {\n            this.dragging = true;\n        }\n    }\n    leftMouseDragged_event(ndcX, ndcY) {\n        let x = ndcX, y = ndcY, selectedControlPoint = this.controlPointsView.getSelectedControlPoint();\n        if (selectedControlPoint != null && this.dragging === true) {\n            this.curveSceneControler.setControlPointPosition(selectedControlPoint, x, y);\n        }\n    }\n    leftMouseUp_event() {\n        this.dragging = false;\n    }\n    addControlPoint() {\n        const cp = this.selectedControlPoint;\n        this.selectedControlPoint = null;\n        this.controlPointsView.setSelected(this.selectedControlPoint);\n        this.curveModel.addControlPoint(cp);\n        this.renderFrame();\n    }\n    toggleControlOfCurvatureExtrema() {\n        this.curveModel.toggleActiveControlOfCurvatureExtrema();\n    }\n    toggleControlOfInflections() {\n        this.curveModel.toggleActiveControlOfInflections();\n    }\n    selectCurveCategory(s) {\n        switch (s) {\n            case \"0\":\n                this.updateCurveModel(new CurveModel_1.CurveModel());\n                //this.updateCurveModel(new CurveModelQuasiNewton())\n                break;\n            case \"1\":\n                //this.updateCurveModel(new ClosedCurveModelQuasiNewton())\n                this.updateCurveModel(new ClosedCurveModel_1.ClosedCurveModel());\n                break;\n            case \"2\":\n                this.updateCurveModel(new CurveModelAlternative01_1.CurveModelAlternative01());\n                break;\n            case \"3\":\n                this.updateCurveModel(new ClosedCurveModelAlternative01_1.ClosedCurveModelAlternative01());\n                break;\n        }\n        let toggleButtonCurvatureExtrema = document.getElementById(\"toggleButtonCurvatureExtrema\");\n        let toggleButtonInflection = document.getElementById(\"toggleButtonInflections\");\n        toggleButtonCurvatureExtrema.checked = true;\n        toggleButtonInflection.checked = true;\n    }\n    updateCurveModel(curveModel) {\n        this.curveModel = curveModel;\n        this.curveModel.registerObserver(this.controlPointsView, \"control points\");\n        this.curveModel.registerObserver(this.controlPolygonView, \"control points\");\n        this.curveModel.registerObserver(this.curveView, \"curve\");\n        this.curveModel.registerObserver(this.curvatureExtremaView, \"curve\");\n        this.curveModel.registerObserver(this.inflectionsView, \"curve\");\n        this.curveSceneControler = new CurveSceneController_1.CurveSceneController(curveModel);\n        this.controlPolygonView.isClosed = this.curveModel.isClosed;\n        this.curveModel.notifyObservers();\n        this.renderFrame();\n    }\n}\nexports.CurveSceneView = CurveSceneView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass CurveShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'void main() {\\n' +\n            '    gl_Position = vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec4 fColor; \\n' +\n            'void main() {\\n' +\n            '    gl_FragColor = fColor; \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfVertices) {\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, numberOfVertices);\n    }\n}\nexports.CurveShaders = CurveShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CurveView {\n    constructor(spline, curveShaders, red, green, blue, alpha) {\n        this.spline = spline;\n        this.curveShaders = curveShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.POINT_SEQUENCE_SIZE = 1000;\n        this.pointSequenceOnSpline = [];\n        this.vertexBuffer = null;\n        this.vertices = new Float32Array(this.POINT_SEQUENCE_SIZE * 6);\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.curveShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n    }\n    updatePointSequenceOnSpline() {\n        const start = this.spline.knots[this.spline.degree];\n        const end = this.spline.knots[this.spline.knots.length - this.spline.degree - 1];\n        this.pointSequenceOnSpline = [];\n        for (let i = 0; i < this.POINT_SEQUENCE_SIZE; i += 1) {\n            let point = this.spline.evaluate(i / (this.POINT_SEQUENCE_SIZE - 1) * (end - start) + start);\n            this.pointSequenceOnSpline.push(point);\n        }\n    }\n    updateVertices() {\n        const thickness = 0.005;\n        const maxLength = thickness * 3;\n        let tangent = ((this.pointSequenceOnSpline[1]).substract(this.pointSequenceOnSpline[0])).normalize(), normal = tangent.rotate90degrees(), miter, length, result = [];\n        result.push(this.pointSequenceOnSpline[0].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[0].substract(normal.multiply(thickness)));\n        for (let i = 1; i < this.pointSequenceOnSpline.length - 1; i += 1) {\n            normal = (this.pointSequenceOnSpline[i].substract(this.pointSequenceOnSpline[i - 1])).normalize().rotate90degrees();\n            tangent = (this.pointSequenceOnSpline[i + 1].substract(this.pointSequenceOnSpline[i - 1])).normalize();\n            miter = tangent.rotate90degrees();\n            length = thickness / (miter.dot(normal));\n            if (length > maxLength) {\n                length = maxLength;\n            }\n            result.push(this.pointSequenceOnSpline[i].add(miter.multiply(length)));\n            result.push(this.pointSequenceOnSpline[i].substract(miter.multiply(length)));\n        }\n        tangent = this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].substract(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 2]).normalize();\n        normal = tangent.rotate90degrees();\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].add(normal.multiply(thickness)));\n        result.push(this.pointSequenceOnSpline[this.pointSequenceOnSpline.length - 1].substract(normal.multiply(thickness)));\n        for (let i = 0; i < result.length; i += 1) {\n            this.vertices[3 * i] = result[i].x;\n            this.vertices[3 * i + 1] = result[i].y;\n            this.vertices[3 * i + 2] = 0.0;\n        }\n    }\n    update(spline) {\n        this.spline = spline;\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        this.updateBuffers();\n    }\n    updateBuffers() {\n        const gl = this.curveShaders.gl;\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    renderFrame() {\n        const gl = this.curveShaders.gl;\n        const a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        const fColorLocation = gl.getUniformLocation(this.curveShaders.program, \"fColor\");\n        gl.useProgram(this.curveShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.uniform4f(fColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curveShaders.renderFrame(this.vertices.length / 3);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    initVertexBuffers(gl) {\n        const a_Position = gl.getAttribLocation(this.curveShaders.program, 'a_Position');\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        this.updatePointSequenceOnSpline();\n        this.updateVertices();\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        return 1;\n    }\n}\nexports.CurveView = CurveView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PeriodicBSplineR1toR2DifferentialProperties_1 = require(\"../bsplines/PeriodicBSplineR1toR2DifferentialProperties\");\nconst PeriodicBSplineR1toR2_1 = require(\"../bsplines/PeriodicBSplineR1toR2\");\nconst BSplineR1toR2_1 = require(\"../bsplines/BSplineR1toR2\");\nconst BSplineR1toR2DifferentialProperties_1 = require(\"../bsplines/BSplineR1toR2DifferentialProperties\");\nclass InflectionsView {\n    constructor(spline, curvatureExtremaShaders, red, green, blue, alpha) {\n        this.curvatureExtremaShaders = curvatureExtremaShaders;\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = alpha;\n        this.z = 0;\n        this.vertexBuffer = null;\n        this.indexBuffer = null;\n        this.vertices = new Float32Array([]);\n        this.indices = new Uint8Array([]);\n        this.controlPoints = spline.freeControlPoints;\n        // Write the positions of vertices to a vertex shader\n        const check = this.initVertexBuffers(this.curvatureExtremaShaders.gl);\n        if (check < 0) {\n            console.log('Failed to set the positions of the vertices');\n        }\n        this.update(spline);\n    }\n    updateVerticesAndIndices() {\n        const size = 0.025;\n        this.vertices = new Float32Array(this.controlPoints.length * 32);\n        this.indices = new Uint8Array(this.controlPoints.length * 6);\n        for (let i = 0; i < this.controlPoints.length; i += 1) {\n            let x = this.controlPoints[i].x;\n            let y = this.controlPoints[i].y;\n            this.vertices[32 * i] = x - size;\n            this.vertices[32 * i + 1] = y - size;\n            this.vertices[32 * i + 2] = this.z;\n            this.vertices[32 * i + 3] = -1;\n            this.vertices[32 * i + 4] = -1;\n            this.vertices[32 * i + 5] = this.red;\n            this.vertices[32 * i + 6] = this.green;\n            this.vertices[32 * i + 7] = this.blue;\n            this.vertices[32 * i + 8] = x + size;\n            this.vertices[32 * i + 9] = y - size;\n            this.vertices[32 * i + 10] = this.z;\n            this.vertices[32 * i + 11] = 1;\n            this.vertices[32 * i + 12] = -1;\n            this.vertices[32 * i + 13] = this.red;\n            this.vertices[32 * i + 14] = this.green;\n            this.vertices[32 * i + 15] = this.blue;\n            this.vertices[32 * i + 16] = x + size;\n            this.vertices[32 * i + 17] = y + size;\n            this.vertices[32 * i + 18] = this.z;\n            this.vertices[32 * i + 19] = 1;\n            this.vertices[32 * i + 20] = 1;\n            this.vertices[32 * i + 21] = this.red;\n            this.vertices[32 * i + 22] = this.green;\n            this.vertices[32 * i + 23] = this.blue;\n            this.vertices[32 * i + 24] = x - size;\n            this.vertices[32 * i + 25] = y + size;\n            this.vertices[32 * i + 26] = this.z;\n            this.vertices[32 * i + 27] = -1;\n            this.vertices[32 * i + 28] = 1;\n            this.vertices[32 * i + 29] = this.red;\n            this.vertices[32 * i + 30] = this.green;\n            this.vertices[32 * i + 31] = this.blue;\n            this.indices[6 * i] = 4 * i;\n            this.indices[6 * i + 1] = 4 * i + 1;\n            this.indices[6 * i + 2] = 4 * i + 2;\n            this.indices[6 * i + 3] = 4 * i;\n            this.indices[6 * i + 4] = 4 * i + 2;\n            this.indices[6 * i + 5] = 4 * i + 3;\n        }\n    }\n    initVertexBuffers(gl) {\n        this.updateVerticesAndIndices();\n        // Create a buffer object\n        this.vertexBuffer = gl.createBuffer();\n        if (!this.vertexBuffer) {\n            console.log('Failed to create the vertex buffer object');\n            return -1;\n        }\n        // Bind the buffer objects to targets\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        // Write date into the buffer object\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        let a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT;\n        if (a_Position < 0) {\n            console.log('Failed to get the storage location of a_Position');\n            return -1;\n        }\n        if (a_Texture < 0) {\n            console.log('Failed to get the storage location of a_Texture');\n            return -1;\n        }\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        // Unbind the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        this.indexBuffer = gl.createBuffer();\n        if (!this.indexBuffer) {\n            console.log('Failed to create the index buffer object');\n            return -1;\n        }\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        return this.indices.length;\n    }\n    renderFrame() {\n        let gl = this.curvatureExtremaShaders.gl, a_Position = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Position'), a_Texture = gl.getAttribLocation(this.curvatureExtremaShaders.program, 'a_Texture'), \n        //a_Color = gl.getAttribLocation(<CurvatureExtremaShaders>this.curvatureExtremaShaders.program, 'a_Color'),\n        FSIZE = this.vertices.BYTES_PER_ELEMENT, a_ColorLocation = gl.getUniformLocation(this.curvatureExtremaShaders.program, \"a_Color\");\n        gl.useProgram(this.curvatureExtremaShaders.program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        // Assign the buffer object to a_Position variable\n        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 8, 0);\n        gl.vertexAttribPointer(a_Texture, 2, gl.FLOAT, false, FSIZE * 8, FSIZE * 3);\n        // Enable the assignment to a_Position variable\n        gl.enableVertexAttribArray(a_Position);\n        gl.enableVertexAttribArray(a_Texture);\n        gl.uniform4f(a_ColorLocation, this.red, this.green, this.blue, this.alpha);\n        this.curvatureExtremaShaders.renderFrame(this.indices.length);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    update(spline) {\n        if (spline instanceof BSplineR1toR2_1.BSplineR1toR2) {\n            const splineDP = new BSplineR1toR2DifferentialProperties_1.BSplineR1toR2DifferentialProperties(spline);\n            this.controlPoints = splineDP.inflections();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n        if (spline instanceof PeriodicBSplineR1toR2_1.PeriodicBSplineR1toR2) {\n            const splineDP = new PeriodicBSplineR1toR2DifferentialProperties_1.PeriodicBSplineR1toR2DifferentialProperties(spline);\n            this.controlPoints = splineDP.inflections();\n            this.updateVerticesAndIndices();\n            this.updateBuffers();\n        }\n    }\n    /*\n    updatePoints(points: Vector_2d[]) {\n        this.controlPoints = points;\n        this.updateVerticesAndIndices();\n        this.updateBuffers();\n    }\n    */\n    updateBuffers() {\n        var gl = this.curvatureExtremaShaders.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    }\n}\nexports.InflectionsView = InflectionsView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass Object3dShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec3 a_Normal; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'uniform mat4 ModelViewProjectionMatrix; \\n' +\n            'uniform mat3 NormalMatrix; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '    normal = normalize(NormalMatrix * a_Normal); \\n' +\n            '    color = vec4(a_Color, 1); \\n' +\n            '    gl_Position = ModelViewProjectionMatrix * vec4(a_Position, 1.0); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec3 Ambient; \\n' +\n            'uniform vec3 LightColor; \\n' +\n            'uniform vec3 LightDirection; \\n' +\n            'uniform vec3 HalfVector; \\n' +\n            'uniform float Shininess; \\n' +\n            'uniform float Strength; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '   float diffuse = abs(dot(normal, LightDirection)); \\n' +\n            '   float specular = abs(dot(normal, HalfVector)); \\n' +\n            '   specular = pow(specular, Shininess); \\n' +\n            '   vec3 scatteredLight = Ambient + LightColor*diffuse; \\n' +\n            '   vec3 reflectedLight = LightColor*specular*Strength; \\n' +\n            '   vec3 rgb = min(color.rgb*scatteredLight + reflectedLight, vec3(1.0)); \\n' +\n            '   gl_FragColor = vec4(rgb, color.a); \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfIndices) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfIndices, this.gl.UNSIGNED_SHORT, 0);\n    }\n}\nexports.Object3dShaders = Object3dShaders;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cuon_utils_1 = require(\"../webgl/cuon-utils\");\nclass Object3dShadowShaders {\n    constructor(gl) {\n        this.gl = gl;\n        // Vertex shader program\n        this.VSHADER_SOURCE = 'attribute vec3 a_Position; \\n' +\n            'attribute vec3 a_Normal; \\n' +\n            'attribute vec3 a_Color; \\n' +\n            'uniform mat4 ModelViewProjectionMatrix; \\n' +\n            'uniform mat3 NormalMatrix; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '    normal = normalize(NormalMatrix * a_Normal); \\n' +\n            '    color = vec4(a_Color, 1.0); \\n' +\n            '    vec4 position = ModelViewProjectionMatrix * vec4(a_Position, 1.0); \\n' +\n            '    gl_Position = vec4(position.x, position.y*0.0 - 1.5, position.z, position.w); \\n' +\n            '}\\n';\n        // Fragment shader program\n        this.FSHADER_SOURCE = 'precision mediump float; \\n' +\n            'uniform vec3 Ambient; \\n' +\n            'uniform vec3 LightColor; \\n' +\n            'uniform vec3 LightDirection; \\n' +\n            'uniform vec3 HalfVector; \\n' +\n            'uniform float Shininess; \\n' +\n            'uniform float Strength; \\n' +\n            'varying vec3 normal; \\n' +\n            'varying vec4 color; \\n' +\n            'void main() {\\n' +\n            '   float diffuse = abs(dot(normal, LightDirection)); \\n' +\n            '   float specular = abs(dot(normal, HalfVector)); \\n' +\n            '   specular = pow(specular, Shininess); \\n' +\n            '   vec3 scatteredLight = Ambient + LightColor*diffuse; \\n' +\n            '   vec3 reflectedLight = LightColor*specular*Strength; \\n' +\n            '   vec3 rgb = min(color.rgb*scatteredLight + reflectedLight, vec3(1.0)); \\n' +\n            '   gl_FragColor = vec4(rgb, color.a); \\n' +\n            '   gl_FragColor = vec4(0.1, 0.1, 0.1, 1); \\n' +\n            '}\\n';\n        this.program = cuon_utils_1.createProgram(this.gl, this.VSHADER_SOURCE, this.FSHADER_SOURCE);\n        if (!this.program) {\n            console.log('Failed to create program');\n        }\n        this.gl.useProgram(this.program);\n    }\n    renderFrame(numberOfIndices) {\n        this.gl.drawElements(this.gl.TRIANGLES, numberOfIndices, this.gl.UNSIGNED_SHORT, 0);\n    }\n}\nexports.Object3dShadowShaders = Object3dShadowShaders;\n","\"use strict\";\n//import { CurveSceneView } from \"./CurveSceneView\"\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction wire3dEventListener(canvas, curveScene3dView) {\n    /*\n    hideContextMenu()\n\n    function hideContextMenu() {\n        const cm = document.getElementById(\"contextMenu\")\n        if (cm) {\n            cm.style.display = \"none\"\n        }\n    }\n    */\n    canvas.addEventListener('mousedown', (event) => {\n        curveScene3dView.mousedown(event);\n        event.preventDefault();\n        curveScene3dView.renderFrame();\n    });\n    canvas.addEventListener('mousemove', (event) => {\n        curveScene3dView.mousemove(event);\n        event.preventDefault();\n        curveScene3dView.renderFrame();\n    });\n    canvas.addEventListener('mouseup', (event) => {\n        curveScene3dView.mouseup(event);\n        event.preventDefault();\n        curveScene3dView.renderFrame();\n    });\n    /*\n    \n    function mouse_get_NormalizedDeviceCoordinates(event: MouseEvent) {\n        var x, y,\n            rect  = canvas.getBoundingClientRect(),\n            ev\n\n        ev = event\n        \n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2)\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2)\n        return [x, y]\n    }\n\n    function touch_get_NormalizedDeviceCoordinates(event: TouchEvent) {\n        var x, y,\n            rect  = canvas.getBoundingClientRect(),\n            ev;\n \n        ev = event.touches[0]\n        \n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2)\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2)\n        return [x, y]\n    }\n\n\n    function mouse_click(ev: MouseEvent) {\n        hideContextMenu()\n        let c = mouse_get_NormalizedDeviceCoordinates(ev)\n        const mousePrecision =  0.0005\n        curveSceneView.leftMouseDown_event(c[0], c[1], mousePrecision)\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n    }\n\n    function mouse_drag(ev: MouseEvent) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev)\n        curveSceneView.leftMouseDragged_event(c[0], c[1])\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n\n    }\n\n    function mouse_stop_drag(ev: MouseEvent) {\n        curveSceneView.leftMouseUp_event()\n        ev.preventDefault()\n    }\n\n    function touch_click(ev: TouchEvent) {\n        let c = touch_get_NormalizedDeviceCoordinates(ev)\n        curveSceneView.leftMouseDown_event(c[0], c[1])\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n    }\n\n    function touch_drag(ev: TouchEvent) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev)\n        curveSceneView.leftMouseDragged_event(c[0], c[1])\n        curveSceneView.renderFrame()\n        ev.preventDefault()\n    }\n\n    function touch_stop_drag(ev: TouchEvent) {\n        curveSceneView.leftMouseUp_event()\n        ev.preventDefault()\n    }\n\n    canvas.addEventListener('mousedown', mouse_click, false)\n    canvas.addEventListener('mousemove', mouse_drag, false)\n    canvas.addEventListener('mouseup', mouse_stop_drag, false)\n    canvas.addEventListener('touchstart', touch_click, false)\n    canvas.addEventListener('touchmove', touch_drag, false)\n    canvas.addEventListener('touchend', touch_stop_drag, false)\n\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\"touchstart\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault()\n        }\n    }, false)\n    document.body.addEventListener(\"touchend\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault()\n        }\n    }, false)\n    document.body.addEventListener(\"touchmove\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault()\n        }\n    }, false)\n\n\n\n    function rightClick(e: MouseEvent) {\n        e.preventDefault()\n\n        const cm = document.getElementById(\"contextMenu\")\n        if (cm) {\n                //cm.style.display = \"block\"\n                cm.style.left = e.pageX + \"px\"\n                cm.style.top = e.pageY + \"px\"\n                cm.style.display = \"block\"\n        }\n    }\n\n    function addControlPoint() {\n        hideContextMenu()\n        curveSceneView.addControlPoint()\n    }\n\n    document.getElementById(\"addControlPoint\")?.addEventListener('click', addControlPoint)\n\n    canvas.addEventListener('contextmenu', rightClick, false)\n\n\n    let toggleButtonCurvatureExtrema = <HTMLButtonElement> document.getElementById(\"toggleButtonCurvatureExtrema\")\n    let toggleButtonInflection = <HTMLButtonElement> document.getElementById(\"toggleButtonInflections\")\n    \n\n    function toggleControlOfCurvatureExtrema() {\n        curveSceneView.toggleControlOfCurvatureExtrema()\n    }\n\n    function toggleControlOfInflections() {\n        curveSceneView.toggleControlOfInflections()\n    }\n\n\n    function selectCurveCategory(event: any) {\n        curveSceneView.selectCurveCategory(event.detail.category)\n    }\n\n    toggleButtonCurvatureExtrema.addEventListener('click', toggleControlOfCurvatureExtrema)\n    toggleButtonInflection.addEventListener('click', toggleControlOfInflections)\n\n    let app = document.getElementsByTagName(\"app-curves-and-surfaces\")[0]\n    app.addEventListener(\"changeCurveCategory\", selectCurveCategory)\n    */\n}\nexports.wire3dEventListener = wire3dEventListener;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction wireEventListener(canvas, curveSceneView) {\n    var _a;\n    hideContextMenu();\n    function mouse_get_NormalizedDeviceCoordinates(event) {\n        const rect = canvas.getBoundingClientRect();\n        const w = parseInt(canvas.style.width, 10);\n        const h = parseInt(canvas.style.height, 10);\n        const x = ((event.clientX - rect.left) - w / 2) / (w / 2);\n        const y = (h / 2 - (event.clientY - rect.top)) / (h / 2);\n        return [x, y];\n    }\n    function touch_get_NormalizedDeviceCoordinates(event) {\n        var x, y, rect = canvas.getBoundingClientRect(), ev;\n        ev = event.touches[0];\n        x = ((ev.clientX - rect.left) - canvas.width / 2) / (canvas.width / 2);\n        y = (canvas.height / 2 - (ev.clientY - rect.top)) / (canvas.height / 2);\n        return [x, y];\n    }\n    function mouse_click(ev) {\n        hideContextMenu();\n        let c = mouse_get_NormalizedDeviceCoordinates(ev);\n        const mousePrecision = 0.0005;\n        curveSceneView.leftMouseDown_event(c[0], c[1], mousePrecision);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function mouse_drag(ev) {\n        var c = mouse_get_NormalizedDeviceCoordinates(ev);\n        curveSceneView.leftMouseDragged_event(c[0], c[1]);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function mouse_stop_drag(ev) {\n        curveSceneView.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    function touch_click(ev) {\n        let c = touch_get_NormalizedDeviceCoordinates(ev);\n        curveSceneView.leftMouseDown_event(c[0], c[1]);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function touch_drag(ev) {\n        var c = touch_get_NormalizedDeviceCoordinates(ev);\n        curveSceneView.leftMouseDragged_event(c[0], c[1]);\n        curveSceneView.renderFrame();\n        ev.preventDefault();\n    }\n    function touch_stop_drag(ev) {\n        curveSceneView.leftMouseUp_event();\n        ev.preventDefault();\n    }\n    canvas.addEventListener('mousedown', mouse_click, false);\n    canvas.addEventListener('mousemove', mouse_drag, false);\n    canvas.addEventListener('mouseup', mouse_stop_drag, false);\n    canvas.addEventListener('touchstart', touch_click, false);\n    canvas.addEventListener('touchmove', touch_drag, false);\n    canvas.addEventListener('touchend', touch_stop_drag, false);\n    // Prevent scrolling when touching the canvas\n    document.body.addEventListener(\"touchstart\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchend\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    document.body.addEventListener(\"touchmove\", function (e) {\n        if (e.target === canvas) {\n            e.preventDefault();\n        }\n    }, false);\n    function hideContextMenu() {\n        const cm = document.getElementById(\"contextMenu\");\n        if (cm) {\n            cm.style.display = \"none\";\n        }\n    }\n    function rightClick(e) {\n        e.preventDefault();\n        const cm = document.getElementById(\"contextMenu\");\n        if (cm) {\n            //cm.style.display = \"block\"\n            cm.style.left = e.pageX + \"px\";\n            cm.style.top = e.pageY + \"px\";\n            cm.style.display = \"block\";\n        }\n    }\n    function addControlPoint() {\n        hideContextMenu();\n        curveSceneView.addControlPoint();\n    }\n    (_a = document.getElementById(\"addControlPoint\")) === null || _a === void 0 ? void 0 : _a.addEventListener('click', addControlPoint);\n    canvas.addEventListener('contextmenu', rightClick, false);\n    function toggleControlOfCurvatureExtrema() {\n        curveSceneView.toggleControlOfCurvatureExtrema();\n    }\n    function toggleControlOfInflections() {\n        curveSceneView.toggleControlOfInflections();\n    }\n    function selectCurveCategory(event) {\n        curveSceneView.selectCurveCategory(event.detail.category);\n    }\n    let app = document.getElementsByTagName(\"app-curves-and-surfaces\")[0];\n    app.addEventListener(\"changeCurveCategory\", selectCurveCategory);\n    app.addEventListener(\"toogleControlOverCurvatureExtrema\", toggleControlOfCurvatureExtrema);\n    app.addEventListener(\"toogleControlOverInflections\", toggleControlOfInflections);\n}\nexports.wireEventListener = wireEventListener;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <rounded-switch-inflections></rounded-switch-inflections>\n    <rounded-switch-curvature-extrema></rounded-switch-curvature-extrema>\n    <curve-category></curve-category>\n    <copyright-years></copyright-years>\n`;\n//import { CopyrightYears } from \"./CopyrightYears\"\nconst CurveCategory_1 = require(\"./CurveCategory\");\nconst RoundedSwitchCurvatureExtrema_1 = require(\"./RoundedSwitchCurvatureExtrema\");\nconst RoundedSwitchInflections_1 = require(\"./RoundedSwitchInflections\");\nclass AppCurvesAndSurfaces extends HTMLElement {\n    constructor() {\n        super();\n        window.customElements.define('rounded-switch-inflections', RoundedSwitchInflections_1.RoundedSwitchInflections);\n        window.customElements.define('rounded-switch-curvature-extrema', RoundedSwitchCurvatureExtrema_1.RoundedSwitchCurvatureExtrema);\n        window.customElements.define('curve-category', CurveCategory_1.CurveCategory);\n        //window.customElements.define('copyright-years', CopyrightYears)\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n}\nexports.AppCurvesAndSurfaces = AppCurvesAndSurfaces;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    .text_center {\n        text-align: center;\n        margin-bottom: 1cm;\n        color:rgb(100, 100, 100);\n        font-size: 80%;\n    }\n    </style>\n    <div class=\"text_center\" id=\"copyright\"></div>\n`;\nclass CopyrightYears extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n        let currentYear = new Date().getFullYear();\n        // \\u00A9: copyright symbol\n        this.shadowRoot.getElementById('copyright').innerText = \"\\u00A9\" + \" 2018-\" + currentYear;\n    }\n}\nexports.CopyrightYears = CopyrightYears;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n    }\n    #container {\n        text-align: center;\n        margin-bottom: 1%;\n    }\n    </style>\n    <div id=\"container\">\n    <p class=\"text_control_button\"> Curve Category: </p>\n        <select id=\"curve-category-selector\">\n            <option id= \"option1\" value=\"0\" selected=\"selected\"> Open </option>\n            <option id= \"option2\" value=\"1\" > Closed </option>\n            <!--\n            <option id= \"option3\" value=\"2\" > Alternative open planar </option>\n            <option id= \"option4\" value=\"3\" > Alternative closed planar </option>\n            -->\n        </select>\n    </div>\n`;\nclass CurveCategory extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('curve-category-selector').\n            addEventListener('change', this.categorySelected);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('curve-category-selector').\n            removeEventListener('change', this.categorySelected);\n    }\n    categorySelected(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"changeCurveCategory\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.CurveCategory = CurveCategory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n    body {\n        margin: 0;\n        padding: 0;\n        font-family:  'Open Sans', sans-serif;\n        background-color: rgb(230, 230, 230);}\n\n\n    .switch {\n        position: relative;\n        display: inline-block;\n        width: 60px;\n        height: 30px;\n      }\n    \n      .switch input {\n        opacity: 0;\n        width: 0;\n        height: 0;\n      }\n      \n      .slider {\n        position: absolute;\n        cursor: pointer;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      .slider:before {\n        position: absolute;\n        content: \"\";\n        height: 23px;\n        width: 23px;\n        left: 4px;\n        bottom: 4px;\n        background-color: white;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      input:checked + .slider {\n        background-color: rgb(130, 194, 141);\n      }\n      \n      input:focus + .slider {\n        box-shadow: 0 0 1px rgb(145, 182, 145);\n      }\n      \n      input:checked + .slider:before {\n        -webkit-transform: translateX(26px);\n        -ms-transform: translateX(26px);\n        transform: translateX(26px);\n      }\n      \n      .slider.round {\n        border-radius: 34px;\n      }\n      \n      .slider.round:before {\n        border-radius: 50%;\n      }\n\n      .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n        }\n    </style>\n\n    <div id=\"container\">\n        <center>  <p class=\"text_control_button\"> Curvature extrema </p> \n            <label class=\"switch\">\n            <input type=\"checkbox\"  checked id=\"toggleButtonCurvatureExtrema\">\n            <span class=\"slider round\"></span>\n            </label>\n        </center>\n    </div>\n`;\nclass RoundedSwitchCurvatureExtrema extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonCurvatureExtrema').\n            addEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonCurvatureExtrema').\n            removeEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    toogleControlOverCurvatureExtrema(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"toogleControlOverCurvatureExtrema\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.RoundedSwitchCurvatureExtrema = RoundedSwitchCurvatureExtrema;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n    <style>\n\n    body {\n        margin: 0;\n        padding: 0;\n        font-family:  'Open Sans', sans-serif;\n        background-color: rgb(230, 230, 230);}\n\n\n    .switch {\n        position: relative;\n        display: inline-block;\n        width: 60px;\n        height: 30px;\n      }\n    \n      .switch input {\n        opacity: 0;\n        width: 0;\n        height: 0;\n      }\n      \n      .slider {\n        position: absolute;\n        cursor: pointer;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      .slider:before {\n        position: absolute;\n        content: \"\";\n        height: 23px;\n        width: 23px;\n        left: 4px;\n        bottom: 4px;\n        background-color: white;\n        -webkit-transition: .4s;\n        transition: .4s;\n      }\n      \n      input:checked + .slider {\n        background-color: rgb(130, 194, 141);\n      }\n      \n      input:focus + .slider {\n        box-shadow: 0 0 1px rgb(145, 182, 145);\n      }\n      \n      input:checked + .slider:before {\n        -webkit-transform: translateX(26px);\n        -ms-transform: translateX(26px);\n        transform: translateX(26px);\n      }\n      \n      .slider.round {\n        border-radius: 34px;\n      }\n      \n      .slider.round:before {\n        border-radius: 50%;\n      }\n\n      .text_control_button {\n        font-size: small;\n        font-weight: bold;\n        margin-bottom: 0%;\n        color:rgb(100, 100, 100);\n        }\n    </style>\n\n    <div id=\"container\">\n        <center>  <p class=\"text_control_button\"> Inflections </p>\n            <label class=\"switch\">\n            <input type=\"checkbox\" checked id=\"toggleButtonInflections\">\n            <span class=\"slider round\"></span>\n            </label>\n        </center>\n    </div>\n`;\nclass RoundedSwitchInflections extends HTMLElement {\n    constructor() {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n    connectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonInflections').\n            addEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    disconnectedCallback() {\n        this.shadowRoot.getElementById('toggleButtonInflections').\n            removeEventListener('change', this.toogleControlOverCurvatureExtrema);\n    }\n    toogleControlOverCurvatureExtrema(event) {\n        let category = event.target;\n        this.dispatchEvent(new CustomEvent(\"toogleControlOverInflections\", {\n            bubbles: true,\n            composed: true,\n            detail: { category: category.value }\n        }));\n    }\n}\nexports.RoundedSwitchInflections = RoundedSwitchInflections;\n","\"use strict\";\n// Reference: cuon-utils.js\n// cuon-utils.js (c) 2012 kanda and matsuda\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Create the linked program object\n * @param gl GL context\n * @param vshader a vertex shader program (string)\n * @param fshader a fragment shader program (string)\n * @return created program object, or null if the creation has failed\n */\nfunction createProgram(gl, vshader, fshader) {\n    // Create shader object\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n    if (!vertexShader || !fragmentShader) {\n        console.log(\"createProgram was unable to produce a vertex or fragment shader\");\n        return null;\n    }\n    // Create a program object\n    var program = gl.createProgram();\n    if (!program) {\n        console.log(\"createProgram was unable to produce a program\");\n        return null;\n    }\n    // Attach the shader objects\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    // Link the program object\n    gl.linkProgram(program);\n    // Check the result of linking\n    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        const error = gl.getProgramInfoLog(program);\n        console.log('Failed to link program: ' + error);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n        return null;\n    }\n    return program;\n}\nexports.createProgram = createProgram;\n/**\n * Create a shader object\n * @param gl GL context\n * @param type the type of the shader object to be created\n * @param source shader program (string)\n * @return created shader object, or null if the creation has failed.\n */\nfunction loadShader(gl, type, source) {\n    const shader = gl.createShader(type);\n    if (shader == null) {\n        console.log('unable to create shader');\n        return null;\n    }\n    // Set the shader program\n    gl.shaderSource(shader, source);\n    // Compile the shader\n    gl.compileShader(shader);\n    // Check the result of compilation\n    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n        const error = gl.getShaderInfoLog(shader);\n        console.log('Failed to compile shader: ' + error);\n        gl.deleteShader(shader);\n        return null;\n    }\n    return shader;\n}\n","\"use strict\";\n//http://glmatrix.net/docs/mat4.js.html\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copies the upper-left 3x3 values into a mat3.\n *\n * @param a   the source 4x4 matrix\n * @returns  3x3 matrix\n */\nfunction mat4_to_mat3(a) {\n    let result = new Float32Array(9);\n    result[0] = a[0];\n    result[1] = a[1];\n    result[2] = a[2];\n    result[3] = a[4];\n    result[4] = a[5];\n    result[5] = a[6];\n    result[6] = a[8];\n    result[7] = a[9];\n    result[8] = a[10];\n    return result;\n}\nexports.mat4_to_mat3 = mat4_to_mat3;\n","\"use strict\";\n//http://glmatrix.net/docs/mat4.js.html\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction identity_mat4() {\n    let result = new Float32Array(16);\n    result[0] = 1;\n    result[5] = 1;\n    result[10] = 1;\n    result[15] = 1;\n    return result;\n}\nexports.identity_mat4 = identity_mat4;\nfunction fromQuat(quaternion) {\n    let result = new Float32Array(16);\n    let x = quaternion[0], y = quaternion[1], z = quaternion[2], w = quaternion[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    result[0] = 1 - yy - zz;\n    result[1] = yx + wz;\n    result[2] = zx - wy;\n    result[3] = 0;\n    result[4] = yx - wz;\n    result[5] = 1 - xx - zz;\n    result[6] = zy + wx;\n    result[7] = 0;\n    result[8] = zx + wy;\n    result[9] = zy - wx;\n    result[10] = 1 - xx - yy;\n    result[11] = 0;\n    result[12] = 0;\n    result[13] = 0;\n    result[14] = 0;\n    result[15] = 1;\n    return result;\n}\nexports.fromQuat = fromQuat;\nfunction hypot(...args) {\n    var y = 0, i = args.length;\n    while (i--)\n        y += args[i] * args[i];\n    return Math.sqrt(y);\n}\nfunction lookAt(eye, center, up) {\n    let result = new Float32Array(16);\n    const EPSILON = 0.000001;\n    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n    let eyex = eye[0];\n    let eyey = eye[1];\n    let eyez = eye[2];\n    let upx = up[0];\n    let upy = up[1];\n    let upz = up[2];\n    let centerx = center[0];\n    let centery = center[1];\n    let centerz = center[2];\n    if (Math.abs(eyex - centerx) < EPSILON &&\n        Math.abs(eyey - centery) < EPSILON &&\n        Math.abs(eyez - centerz) < EPSILON) {\n        return identity_mat4();\n    }\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n    len = 1 / hypot(z0, z1, z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = hypot(x0, x1, x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    }\n    else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n    len = hypot(y0, y1, y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    }\n    else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n    result[0] = x0;\n    result[1] = y0;\n    result[2] = z0;\n    result[3] = 0;\n    result[4] = x1;\n    result[5] = y1;\n    result[6] = z1;\n    result[7] = 0;\n    result[8] = x2;\n    result[9] = y2;\n    result[10] = z2;\n    result[11] = 0;\n    result[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    result[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    result[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    result[15] = 1;\n    return result;\n}\nexports.lookAt = lookAt;\n/**\n * Generates a perspective projection matrix with the given bounds.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param fovy Vertical field of view in radians\n * @param aspect Aspect ratio. typically viewport width/height\n * @param  near Near bound of the frustum\n * @param  far Far bound of the frustum, can be null or Infinity\n * @returns projection matrix\n */\nfunction perspective(fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2), nf;\n    let result = new Float32Array(16);\n    result[0] = f / aspect;\n    result[1] = 0;\n    result[2] = 0;\n    result[3] = 0;\n    result[4] = 0;\n    result[5] = f;\n    result[6] = 0;\n    result[7] = 0;\n    result[8] = 0;\n    result[9] = 0;\n    result[11] = -1;\n    result[12] = 0;\n    result[13] = 0;\n    result[15] = 0;\n    if (far != null && far !== Infinity) {\n        nf = 1 / (near - far);\n        result[10] = (far + near) * nf;\n        result[14] = (2 * far * near) * nf;\n    }\n    else {\n        result[10] = -1;\n        result[14] = -2 * near;\n    }\n    return result;\n}\nexports.perspective = perspective;\n/**\n* Multiplies two mat4s\n*\n* @param  a the first operand\n* @param  b the second operand\n* @returns matrix\n*/\nfunction multiply(a, b) {\n    let result = new Float32Array(16);\n    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    // Cache only the current line of the second matrix\n    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    result[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    result[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    result[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    result[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    result[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    result[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    result[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return result;\n}\nexports.multiply = multiply;\n/**\n * Translate a mat4 by the given vector\n *\n * @param a the matrix to translate\n * @param v vector to translate by\n * @returns matrix\n */\nfunction translate(a, v) {\n    let result = new Float32Array(16);\n    const x = v[0], y = v[1], z = v[2];\n    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    result[0] = a00;\n    result[1] = a01;\n    result[2] = a02;\n    result[3] = a03;\n    result[4] = a10;\n    result[5] = a11;\n    result[6] = a12;\n    result[7] = a13;\n    result[8] = a20;\n    result[9] = a21;\n    result[10] = a22;\n    result[11] = a23;\n    result[12] = a00 * x + a10 * y + a20 * z + a[12];\n    result[13] = a01 * x + a11 * y + a21 * z + a[13];\n    result[14] = a02 * x + a12 * y + a22 * z + a[14];\n    result[15] = a03 * x + a13 * y + a23 * z + a[15];\n    return result;\n}\nexports.translate = translate;\n/**\n* Generates a orthogonal projection matrix with the given bounds\n*\n* @param  left Left bound of the frustum\n* @param  right Right bound of the frustum\n* @param  bottom Bottom bound of the frustum\n* @param  top Top bound of the frustum\n* @param  near Near bound of the frustum\n* @param far Far bound of the frustum\n* @return result mat4 frustum matrix\n*/\nfunction ortho(left, right, bottom, top, near, far) {\n    let result = new Float32Array(16);\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    result[0] = -2 * lr;\n    result[1] = 0;\n    result[2] = 0;\n    result[3] = 0;\n    result[4] = 0;\n    result[5] = -2 * bt;\n    result[6] = 0;\n    result[7] = 0;\n    result[8] = 0;\n    result[9] = 0;\n    result[10] = 2 * nf;\n    result[11] = 0;\n    result[12] = (left + right) * lr;\n    result[13] = (top + bottom) * bt;\n    result[14] = (far + near) * nf;\n    result[15] = 1;\n    return result;\n}\nexports.ortho = ortho;\n/**\n* Transforms the vec2 with a mat4\n* 3rd vector component is implicitly '0'\n* 4th vector component is implicitly '1'\n*\n* @param x, y the vector to transform\n* @param  m matrix to transform with\n* @returns newX, newY\n*/\nfunction mat4_times_vec2(m, x, y) {\n    const newX = m[0] * x + m[4] * y + m[12];\n    const newY = m[1] * x + m[5] * y + m[13];\n    return { x: newX, y: newY };\n}\nexports.mat4_times_vec2 = mat4_times_vec2;\n","\"use strict\";\n//http://glmatrix.net/docs/quat.js.html\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction identity_quat() {\n    let result = new Float32Array(4);\n    result[3] = 1;\n    return result;\n}\nexports.identity_quat = identity_quat;\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param  axis the axis around which to rotate\n * @param  rad the angle in radians\n * @returns  result\n **/\nfunction setAxisAngle(axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    let result = new Float32Array([0, 0, 0, 0]);\n    result[0] = s * axis[0];\n    result[1] = s * axis[1];\n    result[2] = s * axis[2];\n    result[3] = Math.cos(rad);\n    return result;\n}\nexports.setAxisAngle = setAxisAngle;\n/**\n * Multiplies two quaternions\n *\n * @param  a the first quaternion operand\n * @param  b the second quaternion operand\n * @returns the resulting quaternion\n */\nfunction multiply_quats(a, b) {\n    let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n    let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n    let result = new Float32Array([0, 0, 0, 0]);\n    result[0] = ax * bw + aw * bx + ay * bz - az * by;\n    result[1] = ay * bw + aw * by + az * bx - ax * bz;\n    result[2] = az * bw + aw * bz + ax * by - ay * bx;\n    result[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return result;\n}\nexports.multiply_quats = multiply_quats;\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param Angle to rotate around X axis in degrees.\n * @param Angle to rotate around Y axis in degrees.\n * @param Angle to rotate around Z axis in degrees.\n */\nfunction fromEuler(x, y, z) {\n    let result = new Float32Array([0, 0, 0, 0]);\n    let halfToRad = 0.5 * Math.PI / 180.0;\n    x *= halfToRad;\n    y *= halfToRad;\n    z *= halfToRad;\n    let sx = Math.sin(x);\n    let cx = Math.cos(x);\n    let sy = Math.sin(y);\n    let cy = Math.cos(y);\n    let sz = Math.sin(z);\n    let cz = Math.cos(z);\n    result[0] = sx * cy * cz - cx * sy * sz;\n    result[1] = cx * sy * cz + sx * cy * sz;\n    result[2] = cx * cy * sz - sx * sy * cz;\n    result[3] = cx * cy * cz + sx * sy * sz;\n    return result;\n}\nexports.fromEuler = fromEuler;\n","\"use strict\";\n/*\n * Copyright 2010, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @fileoverview This file contains functions every webgl program will need\n * a version of one way or another.\n *\n * Instead of setting up a context manually it is recommended to\n * use. This will check for success or failure. On failure it\n * will attempt to present an approriate message to the user.\n *\n *       gl = WebGLUtils.setupWebGL(canvas);\n *\n * For animated WebGL apps use of setTimeout or setInterval are\n * discouraged. It is recommended you structure your rendering\n * loop like this.\n *\n *       function render() {\n *         window.requestAnimationFrame(render, canvas);\n *\n *         // do rendering\n *         ...\n *       }\n *       render();\n *\n * This will call your rendering function up to the refresh rate\n * of your display but will stop rendering if your app is not\n * visible.\n */\nfunction WebGLUtils() {\n    /**\n     * Creates the HTLM for a failure message\n     * @param {string} canvasContainerId id of container of th\n     *        canvas.\n     * @return {string} The html.\n     */\n    var makeFailHTML = function (msg) {\n        return '' +\n            '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n        return '' +\n            '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n            '<td align=\"center\">' +\n            '<div style=\"display: table-cell; vertical-align: middle;\">' +\n            '<div style=\"\">' + msg + '</div>' +\n            '</div>' +\n            '</td></tr></table>';\n    };\n    /**\n     * Mesasge for getting a webgl browser\n     * @type {string}\n     */\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n    /**\n     * Mesasge for need better hardware\n     * @type {string}\n     */\n    var OTHER_PROBLEM = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n    /**\n     * Creates a webgl context. If creation fails it will\n     * change the contents of the container of the <canvas>\n     * tag to an error message with the correct links for WebGL.\n     * @param {Element} canvas. The canvas element to create a\n     *     context from.\n     * @param {WebGLContextCreationAttirbutes} opt_attribs Any\n     *     creation attributes you want to pass in.\n     * @param {function:(msg)} opt_onError An function to call\n     *     if there is an error during creation.\n     * @return {WebGLRenderingContext} The created context.\n     */\n    var setupWebGL = function (canvas, opt_attribs, opt_onError) {\n        function handleCreationError(msg) {\n            var container = document.getElementsByTagName(\"body\")[0];\n            //var container = canvas.parentNode;\n            if (container) {\n                var str = window.WebGLRenderingContext ?\n                    OTHER_PROBLEM :\n                    GET_A_WEBGL_BROWSER;\n                if (msg) {\n                    str += \"<br/><br/>Status: \" + msg;\n                }\n                container.innerHTML = makeFailHTML(str);\n            }\n        }\n        ;\n        opt_onError = opt_onError || handleCreationError;\n        if (canvas.addEventListener) {\n            canvas.addEventListener(\"webglcontextcreationerror\", function (event) {\n                opt_onError(event.statusMessage);\n            }, false);\n        }\n        var context = create3DContext(canvas, opt_attribs);\n        if (!context) {\n            if (!window.WebGLRenderingContext) {\n                opt_onError(\"\");\n            }\n            else {\n                opt_onError(\"\");\n            }\n        }\n        return context;\n    };\n    /**\n     * Creates a webgl context.\n     * @param {!Canvas} canvas The canvas tag to get context\n     *     from. If one is not passed in one will be created.\n     * @return {!WebGLContext} The created context.\n     */\n    var create3DContext = function (canvas, opt_attribs) {\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n        var context = null;\n        for (var ii = 0; ii < names.length; ++ii) {\n            try {\n                context = canvas.getContext(names[ii], opt_attribs);\n            }\n            catch (e) { }\n            if (context) {\n                break;\n            }\n        }\n        return context;\n    };\n    return {\n        create3DContext: create3DContext,\n        setupWebGL: setupWebGL\n    };\n}\nexports.WebGLUtils = WebGLUtils;\n/**\n * Provides requestAnimationFrame in a cross browser\n * way.\n */\nif (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            //window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {\n                window.setTimeout(callback, 1000 / 60);\n            };\n    })();\n}\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.\n *\n * Cancels an animation frame request.\n * Checks for cross-browser support, falls back to clearTimeout.\n * @param {number}  Animation frame request. */\nif (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = (window.cancelRequestAnimationFrame ||\n        //window.webkitCancelAnimationFrame || \n        window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame ||\n        window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame ||\n        window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame ||\n        window.clearTimeout);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webgl_utils_1 = require(\"./webgl/webgl-utils\");\nconst CurveSceneView_1 = require(\"./views/CurveSceneView\");\nconst CurveModel_1 = require(\"./models/CurveModel\");\nconst WireEventListener_1 = require(\"./views/WireEventListener\");\nconst AppCurvesAndSurfaces_1 = require(\"./webComponents/AppCurvesAndSurfaces\");\nconst CurveScene3dView_1 = require(\"./views/CurveScene3dView\");\nconst Wire3dEventListener_1 = require(\"./views/Wire3dEventListener\");\nconst CopyrightYears_1 = require(\"./webComponents/CopyrightYears\");\nconst CurveModel3d_1 = require(\"./models/CurveModel3d\");\nfunction main() {\n    let canvas2d = document.getElementById(\"webgl\");\n    let canvas3d = document.getElementById(\"webgl2\");\n    let gl = webgl_utils_1.WebGLUtils().setupWebGL(canvas2d);\n    if (!gl) {\n        console.log('Failed to get the rendering context for WebGL');\n        return;\n    }\n    let gl2 = webgl_utils_1.WebGLUtils().setupWebGL(canvas3d);\n    if (!gl2) {\n        console.log('Failed to get the rendering context for WebGL');\n        return;\n    }\n    gl2.enable(gl.DEPTH_TEST);\n    let curveModel = new CurveModel_1.CurveModel();\n    let curveSceneView = new CurveSceneView_1.CurveSceneView(canvas2d, gl, curveModel);\n    let curveModel3d = new CurveModel3d_1.CurveModel3d();\n    let curve3dSceneView = new CurveScene3dView_1.CurveScene3dView(canvas3d, gl2, curveModel3d);\n    curve3dSceneView.renderFrame();\n    window.customElements.define('app-curves-and-surfaces', AppCurvesAndSurfaces_1.AppCurvesAndSurfaces);\n    window.customElements.define('copy-right-years', CopyrightYears_1.CopyrightYears);\n    WireEventListener_1.wireEventListener(canvas2d, curveSceneView);\n    Wire3dEventListener_1.wire3dEventListener(canvas3d, curve3dSceneView);\n}\nexports.main = main;\nmain();\n"],"names":[],"sourceRoot":""}